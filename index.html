<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <title>Learn Your Letters!</title>

    <!-- Modern Libraries via CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css">

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap');

        :root {
            --primary: #6366F1;
            --primary-dark: #4F46E5;
            --secondary: #EC4899;
            --secondary-dark: #DB2777;
            --success: #10B981;
            --warning: #F59E0B;
            --error: #EF4444;
            --gray-50: #F9FAFB;
            --gray-100: #F3F4F6;
            --gray-200: #E5E7EB;
            --gray-300: #D1D5DB;
            --gray-400: #9CA3AF;
            --gray-500: #6B7280;
            --gray-600: #4B5563;
            --gray-700: #374151;
            --gray-800: #1F2937;
            --gray-900: #111827;
            --gray-950: #030712;
            --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.05);
            --shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1);
            --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
            --shadow-xl: 0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1);
            --shadow-2xl: 0 25px 50px -12px rgb(0 0 0 / 0.15);
            --shadow-inner: inset 0 2px 4px 0 rgb(0 0 0 / 0.05);
            --shadow-colored: 0 10px 40px -10px var(--primary);

            /* Timing functions */
            --ease-spring: cubic-bezier(0.175, 0.885, 0.32, 1.275);
            --ease-out-expo: cubic-bezier(0.19, 1, 0.22, 1);
            --radius-sm: 6px;
            --radius: 8px;
            --radius-md: 12px;
            --radius-lg: 16px;
            --radius-xl: 24px;
            --radius-2xl: 32px;

            /* Consistent spacing scale */
            --space-1: 4px;
            --space-2: 8px;
            --space-3: 12px;
            --space-4: 16px;
            --space-5: 20px;
            --space-6: 24px;
            --space-8: 32px;
            --space-10: 40px;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
        }

        /* Global reduce-motion support */
        .reduce-motion * {
            animation: none !important;
            transition: none !important;
        }

        html,
        body {
            margin: 0;
            padding: 0;
            width: 100%;
            /* Use dynamic viewport sizing that adapts to iOS browser chrome */
            min-height: 100vh;
            /* Fallback */
            min-height: 100svh;
            /* Small viewport height when toolbars are shown */
            min-height: 100dvh;
            /* Dynamic viewport height */
            overscroll-behavior: none;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
            background: linear-gradient(135deg, #a78bfa 0%, #ec4899 50%, #fbbf24 100%);
            background-size: 200% 200%;
            /* reduce continuous background motion for focus */
            /* animation: gradientShift 15s ease infinite; */
            /* Avoid fixing the body; let it size to the dynamic viewport to prevent clipping under iOS chrome */
            overflow: hidden;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            touch-action: none;
        }

        @keyframes gradientShift {

            0%,
            100% {
                background-position: 0% 50%;
            }

            50% {
                background-position: 100% 50%;
            }
        }

        /* Magical floating orbs */
        body::before {
            content: '';
            position: fixed;
            width: 300px;
            height: 300px;
            background: radial-gradient(circle, rgba(255, 255, 255, 0.3) 0%, transparent 70%);
            border-radius: 50%;
            top: -150px;
            left: -150px;
            /* disable floating orb animation for calmer UI */
            display: none;
            animation: none;
            pointer-events: none;
        }

        body::after {
            content: '';
            position: fixed;
            width: 400px;
            height: 400px;
            background: radial-gradient(circle, rgba(168, 85, 247, 0.2) 0%, transparent 70%);
            border-radius: 50%;
            bottom: -200px;
            right: -200px;
            /* disable floating orb animation for calmer UI */
            display: none;
            animation: none;
            pointer-events: none;
        }

        @keyframes floatOrb {

            0%,
            100% {
                transform: translate(0, 0) scale(1);
            }

            33% {
                transform: translate(100px, -50px) scale(1.1);
            }

            66% {
                transform: translate(-50px, 100px) scale(0.9);
            }
        }

        /* Magical floating bubbles for kids */
        .bubble {
            position: fixed;
            border-radius: 50%;
            background: radial-gradient(circle at 30% 30%, rgba(255, 255, 255, 0.8), transparent),
                linear-gradient(135deg, rgba(168, 85, 247, 0.3), rgba(236, 72, 153, 0.3));
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            pointer-events: none;
            z-index: -1;
            /* disable floating bubbles by default */
            display: none;
            animation: none;
            box-shadow: inset 0 0 20px rgba(255, 255, 255, 0.5),
                0 0 20px rgba(168, 85, 247, 0.2);
        }

        @keyframes magicalBubbleFloat {

            0%,
            100% {
                transform: translateY(50vh) translateX(0) scale(0.8) rotate(0deg);
                opacity: 0;
            }

            10% {
                opacity: 0.7;
            }

            50% {
                transform: translateY(-50vh) translateX(60px) scale(1.1) rotate(120deg);
                opacity: 0.5;
            }

            90% {
                opacity: 0.7;
            }
        }

        @keyframes float {

            0%,
            100% {
                transform: translateY(0) translateX(0) scale(1);
            }

            33% {
                transform: translateY(-100px) translateX(50px) scale(1.1);
            }

            66% {
                transform: translateY(50px) translateX(-50px) scale(0.9);
            }
        }

        .container {
            width: 100%;
            /* Allow container to grow/shrink with dynamic viewport without forcing a fixed height */
            min-height: 100vh;
            /* Fallback */
            min-height: 100svh;
            /* Small viewport */
            min-height: 100dvh;
            /* Dynamic viewport */
            display: flex;
            flex-direction: column;
            background: rgba(255, 255, 255, 0.85);
            backdrop-filter: blur(30px) saturate(200%);
            -webkit-backdrop-filter: blur(30px) saturate(200%);
            position: relative;
            z-index: 1;
            overflow: hidden;
            padding-bottom: env(safe-area-inset-bottom, 0px);
            box-shadow: inset 0 0 200px rgba(255, 255, 255, 0.5),
                inset 0 1px 0 rgba(255, 255, 255, 0.6);
        }

        .header {
            background: rgba(255, 255, 255, 0.7);
            backdrop-filter: blur(20px) saturate(200%);
            -webkit-backdrop-filter: blur(20px) saturate(200%);
            padding: 12px 16px;
            padding-top: calc(12px + env(safe-area-inset-top, 0px));
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 18px;
            font-weight: 600;
            box-shadow: 0 8px 32px rgba(31, 38, 135, 0.15);
            border-bottom: 1px solid rgba(255, 255, 255, 0.4);
            flex: 0 0 auto;
            z-index: 50;
            position: relative;
        }

        .header::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, transparent 0%, rgba(168, 85, 247, 0.5) 50%, transparent 100%);
            background-size: 200% 100%;
            animation: shimmerHeader 5s ease-in-out infinite;
        }

        @keyframes shimmerHeader {
            0% {
                background-position: left;
                opacity: 0.3;
            }

            50% {
                background-position: right;
                opacity: 0.8;
            }

            100% {
                background-position: left;
                opacity: 0.3;
            }
        }

        .header-title {
            flex: 1;
            text-align: center;
            letter-spacing: 0.5px;
            background: linear-gradient(135deg, #a78bfa, #ec4899);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            font-weight: 700;
            filter: drop-shadow(0 2px 4px rgba(168, 85, 247, 0.3));
            /* remove continuous title pulse for focus */
        }

        @keyframes titlePulse {

            0%,
            100% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.02);
            }
        }

        .settings-btn {
            background: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 2px solid rgba(168, 85, 247, 0.3);
            font-size: 20px;
            width: 44px;
            height: 44px;
            padding: 0;
            border-radius: 14px;
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 20px rgba(168, 85, 247, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.6);
            position: relative;
            overflow: hidden;
        }

        .settings-btn::before {
            content: '';
            position: absolute;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, transparent, rgba(168, 85, 247, 0.3));
            transform: translateX(-100%);
            transition: transform 0.6s;
        }

        /* hover effects scoped in media query below */

        .settings-btn:hover {
            /* tone down hover transform for touch devices */
            box-shadow: 0 6px 25px rgba(168, 85, 247, 0.3);
        }

        .settings-btn:active {
            /* provide tactile feedback without gimmicky rotation */
            background: rgba(168, 85, 247, 0.4);
        }

        /* Achievement Badge Button */
        .badges-btn {
            background: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 2px solid rgba(251, 191, 36, 0.4);
            font-size: 20px;
            width: 44px;
            height: 44px;
            padding: 0;
            border-radius: 14px;
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 20px rgba(251, 191, 36, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.6);
            position: relative;
        }

        @keyframes trophyFloat {

            0%,
            100% {
                transform: translateY(0) rotate(-5deg);
            }

            50% {
                transform: translateY(-5px) rotate(5deg);
            }
        }

        .badges-btn:hover {
            /* keep hover subtle on touch devices */
            box-shadow: 0 6px 25px rgba(251, 191, 36, 0.4);
        }

        /* Triggered only when a new achievement is unlocked */
        .badges-btn.new-achievement {
            animation: trophyShake 0.6s ease-in-out;
        }

        @keyframes trophyShake {

            0%,
            100% {
                transform: rotate(0deg);
            }

            25% {
                transform: rotate(-10deg);
            }

            75% {
                transform: rotate(10deg);
            }
        }

        .badges-btn:active {
            transform: scale(0.95);
            animation: trophyShake 0.5s ease-in-out;
        }

        .badge-count {
            position: absolute;
            top: -6px;
            right: -6px;
            background: var(--secondary);
            color: white;
            font-size: 10px;
            font-weight: 600;
            padding: 2px 5px;
            border-radius: 999px;
            min-width: 16px;
            height: 16px;
            display: none;
            align-items: center;
            justify-content: center;
            text-align: center;
            box-shadow: var(--shadow-sm);
        }

        @keyframes badgePulse {

            0%,
            100% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.1);
            }
        }

        .mode-selector {
            display: flex;
            gap: 12px;
            padding: 16px;
            background: var(--gray-50);
            border-bottom: 1px solid var(--gray-100);
        }

        .mode-btn {
            flex: 1;
            padding: 12px 16px;
            border: 1px solid var(--gray-200);
            background: white;
            border-radius: var(--radius-md);
            font-size: 14px;
            font-weight: 600;
            color: var(--gray-700);
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
            overflow: hidden;
        }

        .mode-btn:before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }

        .mode-btn.active:before {
            width: 300%;
            height: 300%;
        }

        .mode-btn.active {
            color: white;
            background: var(--primary);
            border-color: var(--primary);
            box-shadow: var(--shadow-md);
        }

        .mode-btn span {
            position: relative;
            z-index: 1;
        }

        .score-panel {
            padding: 20px 24px;
            background: linear-gradient(180deg, white 0%, var(--gray-50) 100%);
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: nowrap;
            overflow-x: auto;
            gap: 8px;
            font-weight: 600;
            color: var(--gray-700);
            border-bottom: 1px solid rgba(0, 0, 0, 0.05);
            position: relative;
        }

        .score-panel:after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, transparent, var(--gray-200), transparent);
        }

        .score-left {
            display: flex;
            flex-direction: column;
            gap: 6px;
            font-size: 14px;
            flex: 1;
        }

        .score-right {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 6px;
            flex: 1;
        }

        .stars {
            font-size: 24px;
            display: flex;
            gap: 4px;
        }

        .star {
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            display: inline-block;
            filter: grayscale(1);
            opacity: 0.3;
        }

        .star.filled {
            animation: starPop 0.5s;
            filter: grayscale(0);
            opacity: 1;
        }

        @keyframes starPop {
            0% {
                transform: scale(0) rotate(0deg);
            }

            50% {
                transform: scale(1.3) rotate(180deg);
            }

            100% {
                transform: scale(1) rotate(360deg);
            }
        }

        .score-value {
            font-size: 20px;
            background: linear-gradient(135deg, var(--primary), var(--primary-dark));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            font-weight: 700;
            letter-spacing: -0.02em;
            font-variant-numeric: tabular-nums;
        }

        .timer-display {
            font-size: 24px;
            font-weight: bold;
            color: #667eea;
            margin: 10px 0;
            text-align: center;
            min-height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            padding: 5px;
            line-height: 1;
            /* ensure emoji like ðŸ”Š are centered and not clipped */
            font-family: -apple-system, system-ui, "Apple Color Emoji", "Segoe UI Emoji", "Noto Color Emoji", sans-serif;
        }

        /* When no timer text is present, collapse the area entirely (fixes blank gap on iPhone) */
        .timer-display:empty {
            display: none;
        }

        .timer-display.warning {
            animation: pulse-red 0.5s infinite;
            color: #dc2626;
        }

        .timer-display.critical {
            animation: shake 0.3s infinite;
            color: #ff0000;
            font-size: 32px;
        }

        @keyframes pulse-red {

            0%,
            100% {
                transform: scale(1);
                opacity: 1;
            }

            50% {
                transform: scale(1.1);
                opacity: 0.8;
            }
        }

        @keyframes shake {

            0%,
            100% {
                transform: translateX(0);
            }

            25% {
                transform: translateX(-5px);
            }

            75% {
                transform: translateX(5px);
            }
        }

        .timer-bar {
            width: 80%;
            height: 6px;
            background: #e5e7eb;
            border-radius: 3px;
            overflow: hidden;
            margin: 0 auto;
        }

        .timer-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #4ade80, #22c55e);
            transition: width 1s linear;
            border-radius: 3px;
        }

        .timer-bar-fill.warning {
            background: linear-gradient(90deg, #fbbf24, #f59e0b);
        }

        .timer-bar-fill.critical {
            background: linear-gradient(90deg, #ef4444, #dc2626);
        }

        .game-area {
            flex: 1 1 auto;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
            padding: 12px 16px 16px;
            padding-bottom: max(28px, calc(28px + env(safe-area-inset-bottom, 0px)));
            overflow: hidden; /* absolutely no scrolling for kids */
            background: rgba(255, 255, 255, 0.3);
            backdrop-filter: blur(15px) saturate(150%);
            -webkit-backdrop-filter: blur(15px) saturate(150%);
            border-radius: 24px 24px 0 0;
            box-shadow: inset 0 2px 20px rgba(255, 255, 255, 0.4), 0 -5px 20px rgba(168, 85, 247, 0.1);
            margin-top: 8px;
        }

        /* When the start screen is visible, use top alignment to avoid wasted space
           and keep the CTA comfortably above the home indicator */
        .game-area:has(.start-screen) {
            justify-content: flex-start;
            padding-top: clamp(8px, 2vh, 16px);
            /* Ensure CTA isn't clipped by rounded container + safe area */
            padding-bottom: calc(40px + env(safe-area-inset-bottom, 0px));
        }

        /* When a prominent sound button is present, reserve top space so nothing overlaps it */
        .game-area.with-sound {
            /* Minimal top padding â€“ speaker floats over the grid */
            padding-top: clamp(8px, 1.8vmin, 16px);
        }

        /* Keep speaker visible using a separate composited layer */
        .game-area.with-sound .sound-btn {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -58%);
            z-index: 20;
            margin-bottom: 0;
            will-change: transform;
            /* slightly smaller when floating so letters remain visible */
            width: clamp(72px, 16vmin, 110px);
            height: clamp(72px, 16vmin, 110px);
        }

        /* Make any clickable/touch-start element avoid tap highlight */
        [onclick],
        [ontouchstart] {
            -webkit-tap-highlight-color: transparent;
        }

        /* Allow vertical scroll in modal content areas on iOS */
        .settings-content,
        .achievement-content,
        .player-modal-content,
        .round-content,
        .streak-modal-content,
        .parent-dashboard {
            touch-action: pan-y;
            -webkit-overflow-scrolling: touch;
        }

        /* Make interactive elements feel native on iOS */
        button,
        .mode-btn,
        .option-btn,
        .sound-btn,
        .toggle-btn,
        .settings-btn,
        .badges-btn,
        .continue-btn,
        .player-modal-btn,
        .start-btn {
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }

        /* Extra tap highlight suppression */
        button,
        .option-btn,
        .sound-btn {
            -webkit-tap-highlight-color: transparent;
        }

        /* Enhanced Sound Button */
        .sound-btn {
            width: clamp(80px, 17.5vmin, 118px);
            height: clamp(80px, 17.5vmin, 118px);
            border-radius: 50%;
            background: linear-gradient(135deg, white 0%, var(--gray-50) 100%);
            border: none;
            box-shadow: 0 4px 14px rgba(0, 0, 0, 0.08),
                0 1px 3px rgba(0, 0, 0, 0.12),
                inset 0 -2px 0 rgba(0, 0, 0, 0.04);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: clamp(36px, 6vmin, 48px);
            line-height: 1;
            padding: 10px;
            /* prevent vertical cropping of emoji */
            cursor: pointer;
            transition: all 0.2s var(--ease-spring);
            margin-bottom: var(--space-8);
            position: relative;
            overflow: hidden;
            color: initial;
            /* allow native color emoji */
            font-family: -apple-system, system-ui, "Apple Color Emoji", "Segoe UI Emoji", "Noto Color Emoji", sans-serif;
        }

        .sound-btn:hover {
            transform: scale(1.05) translateY(-2px);
            box-shadow: 0 8px 24px rgba(99, 102, 241, 0.25),
                0 2px 6px rgba(0, 0, 0, 0.1);
        }

        .sound-btn:active {
            transform: scale(0.95);
        }

        .sound-btn.playing {
            background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
            color: initial;
            box-shadow: 0 8px 32px rgba(99, 102, 241, 0.35),
                0 2px 8px rgba(0, 0, 0, 0.1);
        }

        /* Cheaper pulse using pseudo-elements */
        .sound-btn::before,
        .sound-btn::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border-radius: 50%;
            background: rgba(102, 126, 234, 0.2);
            transform: scale(0.8);
            opacity: 0;
            pointer-events: none;
        }

        .sound-btn.playing::before {
            animation: soundPulse 0.8s ease-out;
        }

        .sound-btn.playing::after {
            animation: soundPulse 1s ease-out;
        }

        @keyframes soundPulse {
            0% {
                transform: scale(0.8);
                opacity: 0.6;
            }

            100% {
                transform: scale(1.6);
                opacity: 0;
            }
        }

        /* Modal body lock */
        body.modal-open {
            overflow: hidden;
            position: fixed;
            width: 100%;
        }

        /* Phonics skip button */
        .phonics-skip {
            position: absolute;
            bottom: 20px;
            right: 20px;
            padding: 8px 16px;
            border-radius: 20px;
            background: #9ca3af;
            color: white;
            border: none;
            font-weight: 600;
        }

        @media (prefers-reduced-motion: reduce) {

            .bubble,
            body::before,
            body::after {
                animation: none !important;
            }
        }

        /* Enhanced Options Grid */
        .options {
            display: grid;
            grid-template-columns: repeat(2, minmax(0, 1fr));
            gap: clamp(8px, 2.4vmin, 16px);
            width: 100%;
            max-width: 360px;
            /* create space under floating speaker so boxes are never covered */
            padding-top: clamp(36px, 9.5vmin, 72px);
        }

        .option-btn {
            padding: 0;
            /* Make all letter options perfect squares for consistent layout */
            width: 100%;
            aspect-ratio: 1 / 1;
            min-height: 96px;
            /* sensible floor for very narrow devices */
            font-size: clamp(36px, 8vmin, 48px);
            border: 2px solid transparent;
            background: white;
            background-image: linear-gradient(white, white),
                linear-gradient(135deg, var(--gray-100), var(--gray-200));
            background-origin: border-box;
            background-clip: padding-box, border-box;
            border-radius: var(--radius-lg);
            cursor: pointer;
            transition: all 0.2s var(--ease-spring);
            font-weight: 700;
            position: relative;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.04), 0 1px 2px rgba(0, 0, 0, 0.06);
            color: var(--gray-800);
            display: flex;
            align-items: center;
            justify-content: center;
            letter-spacing: -0.02em;
            touch-action: manipulation;
        }

        /* Very narrow devices like iPhone SE */
        @media (max-width: 375px) {
            .options {
                grid-template-columns: repeat(2, 1fr);
                gap: 8px;
            }

            .option-btn {
                min-height: 100px;
                font-size: 48px;
            }
        }

        .option-btn:hover {
            background-image: linear-gradient(white, white),
                linear-gradient(135deg, var(--primary), var(--primary-dark));
        }

        /* Apply hover effects only on devices that support hover */
        @media (hover: hover) and (pointer: fine) {
            .settings-btn:hover::before {
                transform: translateX(100%);
            }

            .option-btn:hover {
                transform: translateY(-2px) scale(1.02);
                box-shadow: 0 12px 24px rgba(99, 102, 241, 0.15), 0 4px 8px rgba(0, 0, 0, 0.05);
            }
        }

        .option-btn:before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, transparent, rgba(99, 102, 241, 0.03));
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .option-btn:hover:before {
            opacity: 1;
        }

        .option-btn:active {
            transform: scale(0.95);
        }

        .option-btn.correct {
            animation: correctBounce 0.6s var(--ease-spring);
            background: linear-gradient(135deg, var(--success), #059669);
            color: white;
            border: none;
            box-shadow: 0 8px 24px rgba(16, 185, 129, 0.35);
        }

        .option-btn.wrong {
            animation: wrongWobbleRich 0.6s;
            background: var(--error);
            color: white;
            border-color: var(--error);
        }

        @keyframes correctBounce {
            0% {
                transform: scale(1);
            }

            25% {
                transform: scale(0.97);
            }

            50% {
                transform: scale(1.06);
            }

            100% {
                transform: scale(1);
            }
        }

        @keyframes wrongWobbleRich {

            0%,
            100% {
                transform: translateX(0) rotate(0deg) scale(1);
            }

            15% {
                transform: translateX(-4px) rotate(-2deg) scale(0.98);
            }

            30% {
                transform: translateX(4px) rotate(2deg) scale(0.98);
            }

            45% {
                transform: translateX(-3px) rotate(-1deg) scale(0.99);
            }

            60% {
                transform: translateX(3px) rotate(1deg) scale(0.99);
            }

            75% {
                transform: translateX(-2px) rotate(-0.5deg) scale(1.0);
            }

            85% {
                transform: translateX(2px) rotate(0.5deg) scale(1.0);
            }
        }

        @keyframes wrongWobbleSoft {

            0%,
            100% {
                transform: translateX(0) rotate(0deg);
            }

            25% {
                transform: translateX(-4px) rotate(-2deg);
            }

            75% {
                transform: translateX(4px) rotate(2deg);
            }
        }

        /* Tone it down when reduced motion is enabled */
        .reduce-motion .option-btn.wrong {
            animation: wrongWobbleSoft 0.4s;
        }

        /* Celebration Particles (CSS-based) */
        @keyframes celebrationParticle {
            0% {
                transform: translate(0, 0) scale(0) rotate(0deg);
                opacity: 0;
            }

            20% {
                transform: translate(0, 0) scale(1.2) rotate(90deg);
                opacity: 1;
            }

            100% {
                transform:
                    translateX(calc(cos(var(--angle)) * var(--distance))) translateY(calc(sin(var(--angle)) * var(--distance))) scale(0.3) rotate(360deg);
                opacity: 0;
            }
        }

        .celebration-particle {
            will-change: transform, opacity;
        }

        @keyframes correctPop {
            0% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.15);
            }

            100% {
                transform: scale(1);
                box-shadow: 0 0 0 10px rgba(74, 222, 128, 0);
            }
        }

        /* Draw Mode Styles */
        .canvas-container {
            position: relative;
            border: 5px solid transparent;
            background: linear-gradient(white, white) padding-box,
                linear-gradient(90deg, #667eea, #764ba2) border-box;
            border-radius: 25px;
            overflow: hidden; /* prevent content from bleeding outside rounded corners */
            margin-bottom: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
        }

        canvas {
            display: block;
            cursor: crosshair;
            border-radius: 20px;
            background: white;
            will-change: transform;
        }

        .letter-guide {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 220px;
            color: #667eea;
            opacity: 0; /* hidden by default; will fade in as hint */
            transition: opacity 0.6s linear;
            pointer-events: none;
            font-family: 'Georgia', serif;
            font-weight: bold;
        }

        .controls {
            display: flex;
            gap: 12px;
            width: 100%;
            max-width: 350px;
            /* ensure controls never sit below iOS home bar */
            margin-bottom: env(safe-area-inset-bottom, 0px);
        }

        .control-btn {
            flex: 1;
            padding: 16px;
            font-size: 18px;
            font-weight: bold;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }

        .clear-btn {
            background: linear-gradient(135deg, #fbbf24, #f59e0b);
            color: white;
        }

        .check-btn {
            background: linear-gradient(135deg, #4ade80, #22c55e);
            color: white;
        }

        .control-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.15);
        }

        .control-btn:active {
            transform: scale(0.95);
        }

        /* Enhanced Feedback Modal */
        .feedback {
            position: fixed;
            top: calc(50% + env(safe-area-inset-top, 0px));
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
            font-weight: 600;
            color: white;
            padding: 24px 48px;
            border-radius: var(--radius-xl);
            z-index: 1000;
            display: none;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.2), 0 0 0 1px rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            letter-spacing: -0.02em;
        }

        @media (max-height: 450px) {
            .feedback {
                padding: 16px 32px;
                font-size: 24px;
                transform: translate(-50%, -50%) scale(0.9);
            }
        }

        .feedback.success {
            background: rgba(16, 185, 129, 0.95);
            animation: successPop 0.5s var(--ease-spring);
        }

        .feedback.error {
            background: rgba(239, 68, 68, 0.95);
            animation: errorShake 0.5s var(--ease-spring);
        }

        /* Loading skeleton animation */
        @keyframes shimmerSkeleton {
            0% {
                background-position: -1000px 0;
            }

            100% {
                background-position: 1000px 0;
            }
        }

        .skeleton {
            background: linear-gradient(90deg, var(--gray-100) 0%, var(--gray-50) 50%, var(--gray-100) 100%);
            background-size: 1000px 100%;
            animation: shimmerSkeleton 2s infinite;
            border-radius: var(--radius);
        }

        /* Smooth page transitions */
        .fade-transition {
            animation: fadeTransition 0.3s ease-out;
        }

        @keyframes fadeTransition {
            from {
                opacity: 0;
                transform: translateY(4px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Info feedback style for subtle hints */
        .feedback.info {
            background: linear-gradient(135deg, #60a5fa, #3b82f6);
            font-size: 24px;
            animation: successPop 0.6s;
        }

        @keyframes successPop {
            0% {
                transform: translate(-50%, -50%) scale(0) rotate(0deg);
            }

            50% {
                transform: translate(-50%, -50%) scale(1.2) rotate(10deg);
            }

            100% {
                transform: translate(-50%, -50%) scale(1) rotate(0deg);
            }
        }

        @keyframes errorShake {
            0% {
                transform: translate(-50%, -50%) scale(0);
            }

            20% {
                transform: translate(-50%, -50%) scale(1.1) rotate(-5deg);
            }

            40% {
                transform: translate(-48%, -50%) scale(1) rotate(5deg);
            }

            60% {
                transform: translate(-52%, -50%) scale(1) rotate(-5deg);
            }

            80% {
                transform: translate(-49%, -50%) scale(1) rotate(2deg);
            }

            100% {
                transform: translate(-50%, -50%) scale(1) rotate(0deg);
            }
        }

        .instruction {
            text-align: center;
            font-size: clamp(16px, 2.6vmin, 20px);
            color: #764ba2;
            margin-bottom: clamp(6px, 1.6vmin, 12px);
            font-weight: 600;
            animation: fadeIn 0.5s;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes fadeOut {
            from {
                opacity: 1;
                transform: translateY(0);
            }

            to {
                opacity: 0;
                transform: translateY(10px);
            }
        }

        @keyframes sparkle {
            0% {
                opacity: 0;
                transform: scale(0) rotate(0deg);
            }

            50% {
                opacity: 1;
                transform: scale(1.2) rotate(180deg);
            }

            100% {
                opacity: 0;
                transform: scale(0.8) rotate(360deg) translateY(-50px);
            }
        }

        .letter-display {
            font-size: clamp(56px, 12vmin, 90px);
            color: transparent;
            background: linear-gradient(90deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            background-clip: text;
            margin-bottom: clamp(8px, 2vmin, 16px);
            font-weight: bold;
            animation: letterFloat 3s ease-in-out infinite;
        }

        @keyframes letterFloat {

            0%,
            100% {
                transform: translateY(0);
            }

            50% {
                transform: translateY(-10px);
            }
        }

        .start-screen {
            text-align: center;
            padding: clamp(12px, 2vh, 24px);
            animation: fadeIn 0.8s;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: clamp(6px, 1.5vh, 12px);
        }

        .start-screen h2 {
            color: #764ba2;
            margin-bottom: clamp(8px, 2vh, 12px);
            font-size: clamp(22px, 3.6vh, 28px);
        }

        .start-screen p {
            color: #6b7280;
            margin-bottom: clamp(6px, 1.6vh, 10px);
            line-height: 1.4;
            font-size: clamp(14px, 2.2vh, 16px);
        }

        .start-btn {
            padding: clamp(14px, 2.4vh, 20px) clamp(28px, 6vh, 50px);
            font-size: clamp(20px, 3.2vh, 24px);
            background: linear-gradient(135deg, #f093fb, #f5576c);
            color: white;
            border: none;
            border-radius: 35px;
            cursor: pointer;
            font-weight: bold;
            animation: bounce 2s infinite;
            box-shadow: 0 10px 30px rgba(240, 147, 251, 0.3);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            /* Add a comfortable breathing room below CTA on iPhone */
            margin-bottom: calc(16px + env(safe-area-inset-bottom, 0px));
        }

        .start-btn:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 40px rgba(240, 147, 251, 0.4);
        }

        @keyframes bounce {

            0%,
            100% {
                transform: translateY(0);
            }

            50% {
                transform: translateY(-10px);
            }
        }

        /* Enhanced Settings Modal */
        .settings-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 12000;
            animation: modalFadeIn 0.2s ease-out;
            overscroll-behavior: contain;
            padding-bottom: env(safe-area-inset-bottom, 0px);
            padding-bottom: constant(safe-area-inset-bottom, 0px);
        }

        @keyframes modalFadeIn {
            from {
                opacity: 0;
                backdrop-filter: blur(0px);
                -webkit-backdrop-filter: blur(0px);
            }

            to {
                opacity: 1;
                backdrop-filter: blur(12px);
                -webkit-backdrop-filter: blur(12px);
            }
        }

        .settings-content {
            background: white;
            padding: 0;
            border-radius: var(--radius-2xl);
            width: 90%;
            max-width: 480px;
            max-height: 85vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.15), 0 0 0 1px rgba(0, 0, 0, 0.05);
            animation: modalSlideUp 0.3s var(--ease-out-expo);
            -webkit-overflow-scrolling: touch;
            overscroll-behavior: contain;
        }

        @keyframes modalSlideUp {
            from {
                transform: translateY(20px) scale(0.98);
                opacity: 0;
            }

            to {
                transform: translateY(0) scale(1);
                opacity: 1;
            }
        }

        .settings-header {
            background: white;
            color: var(--gray-900);
            padding: 24px 28px;
            font-size: 20px;
            font-weight: 700;
            text-align: center;
            border-radius: var(--radius-xl) var(--radius-xl) 0 0;
            position: sticky;
            top: 0;
            z-index: 10;
            border-bottom: 1px solid var(--gray-100);
            letter-spacing: -0.02em;
        }

        .settings-body {
            padding: 30px;
        }

        .settings-callout {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            padding: 14px 16px;
            margin-bottom: 16px;
            border-radius: var(--radius-lg);
            background: linear-gradient(135deg, #f5f3ff, #fce7f3);
            border: 1px solid var(--gray-100);
        }

        .settings-callout .callout-title {
            font-weight: 700;
            color: #4c1d95;
            letter-spacing: -0.01em;
        }

        .settings-callout .callout-subtitle {
            color: #6b7280;
            font-size: 12px;
        }

        .parent-cta {
            padding: 10px 14px;
            border-radius: 12px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            font-weight: 700;
            letter-spacing: 0.02em;
            cursor: pointer;
            box-shadow: 0 6px 18px rgba(102, 126, 234, 0.3);
            transition: transform 0.15s ease, box-shadow 0.2s ease;
            white-space: nowrap;
        }

        .parent-cta:hover {
            transform: translateY(-1px);
            box-shadow: 0 10px 26px rgba(102, 126, 234, 0.35);
        }

        .info-tip {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 16px;
            height: 16px;
            margin-left: 6px;
            border-radius: 999px;
            background: var(--gray-100);
            color: var(--gray-700);
            border: 1px solid var(--gray-200);
            font-size: 11px;
            line-height: 1;
            cursor: help;
            vertical-align: middle;
        }

        .info-tip:hover {
            background: #eef2ff;
            color: #4f46e5;
            border-color: #c7d2fe;
        }

        .settings-section {
            background: white;
            border-radius: var(--radius-md);
            padding: 20px;
            margin-bottom: 20px;
            border: 1px solid var(--gray-100);
        }

        .settings-section-title {
            font-size: 16px;
            font-weight: 600;
            color: var(--gray-800);
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--gray-100);
            letter-spacing: -0.01em;
        }

        /* Advanced settings disclosure polish */
        .advanced-settings summary {
            position: relative;
            list-style: none;
            cursor: pointer;
        }

        .advanced-settings summary::-webkit-details-marker {
            display: none;
        }

        .advanced-settings summary::after {
            content: 'â–¶ï¸';
            position: absolute;
            right: 0;
            top: 50%;
            transform: translateY(-50%) scale(0.7);
            transition: transform 0.2s;
            font-size: 16px;
        }

        .advanced-settings[open]>summary::after {
            transform: translateY(-50%) scale(0.7) rotate(90deg);
        }

        /* Compact topbar for quick toggles (e.g., Reduce Motion) */
        .settings-topbar {
            display: flex;
            align-items: center;
            justify-content: flex-end;
            gap: 10px;
            padding: 8px 12px;
            margin: -10px -10px 15px -10px;
            background: linear-gradient(135deg, #f7fafc, #edf2f7);
            border-radius: 14px;
        }

        .setting-group {
            margin-bottom: 20px;
        }

        .setting-label {
            font-weight: 500;
            color: #6b7280;
            margin-bottom: 10px;
            display: block;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        /* New Settings Styles */
        .toggle-group {
            display: flex;
            gap: 6px;
        }

        .theme-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 12px;
        }

        .theme-button {
            padding: 16px;
            background: white;
            border: 2px solid transparent;
            background-image: linear-gradient(white, white),
                linear-gradient(135deg, var(--gray-100), var(--gray-200));
            background-origin: border-box;
            background-clip: padding-box, border-box;
            border-radius: var(--radius-lg);
            text-align: center;
            cursor: pointer;
            transition: all 0.2s var(--ease-spring);
            position: relative;
        }

        .theme-button:hover {
            transform: translateY(-2px) scale(1.02);
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.08);
        }

        .theme-button.active {
            background-image: linear-gradient(white, white),
                linear-gradient(135deg, var(--primary), var(--primary-dark));
            box-shadow: 0 4px 12px rgba(99, 102, 241, 0.15);
        }

        .theme-button.active:after {
            content: 'âœ“';
            position: absolute;
            top: 8px;
            right: 8px;
            width: 20px;
            height: 20px;
            background: var(--primary);
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: 600;
            animation: checkIn 0.3s var(--ease-spring);
        }

        @keyframes checkIn {
            from {
                transform: scale(0) rotate(-180deg);
            }

            to {
                transform: scale(1) rotate(0);
            }
        }

        .theme-icon {
            font-size: 28px;
            margin-bottom: 6px;
        }

        .theme-name {
            font-size: 12px;
            font-weight: 500;
            color: #6b7280;
        }

        .theme-button.active .theme-name {
            color: #667eea;
            font-weight: 600;
        }

        .toggle-switch {
            position: relative;
            width: 48px;
            height: 24px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-switch-label {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: #e5e7eb;
            transition: all 0.3s;
            border-radius: 24px;
        }

        .toggle-switch-label:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background: white;
            transition: all 0.3s;
            border-radius: 50%;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .toggle-switch input:checked+.toggle-switch-label {
            background: #667eea;
        }

        .toggle-switch input:checked+.toggle-switch-label:before {
            transform: translateX(24px);
        }

        .toggle-btn {
            padding: 10px 20px;
            border: 1px solid var(--gray-200);
            background: white;
            border-radius: var(--radius);
            cursor: pointer;
            margin-right: 8px;
            margin-bottom: 6px;
            transition: all 0.2s ease;
            font-weight: 500;
            color: var(--gray-600);
            font-size: 13px;
            letter-spacing: -0.01em;
        }

        .toggle-btn:hover {
            background: var(--gray-50);
            border-color: var(--gray-300);
        }

        .toggle-btn.active {
            background: var(--primary);
            color: white;
            border-color: var(--primary);
        }

        .close-settings {
            background: var(--primary);
            color: white;
            border: none;
            padding: 14px 28px;
            border-radius: var(--radius-md);
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            width: 100%;
            margin-top: 20px;
            transition: all 0.2s ease;
            letter-spacing: -0.01em;
        }

        .close-settings:hover {
            background: var(--primary-dark);
            transform: translateY(-1px);
            box-shadow: var(--shadow-lg);
        }

        /* About Section Styles */
        .about-section {
            margin-top: 25px;
            animation: fadeIn 0.5s;
        }

        .about-divider {
            height: 2px;
            background: linear-gradient(90deg, transparent, #e5e7eb, transparent);
            margin-bottom: 20px;
        }

        .about-content {
            text-align: center;
            padding: 20px;
            background: linear-gradient(135deg, rgba(240, 147, 251, 0.05), rgba(245, 87, 108, 0.05));
            border-radius: 20px;
            border: 2px solid rgba(240, 147, 251, 0.1);
        }

        .about-title {
            font-size: 18px;
            font-weight: bold;
            color: #764ba2;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .about-text {
            color: #4b5563;
            font-size: 14px;
            line-height: 1.6;
            margin-bottom: 12px;
        }

        .about-text strong {
            color: #764ba2;
            font-weight: 600;
        }

        .github-link {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 12px 20px;
            background: linear-gradient(135deg, #374151, #1f2937);
            color: white;
            text-decoration: none;
            border-radius: 15px;
            font-size: 14px;
            font-weight: 600;
            margin: 15px 0;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }

        .github-link:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.2);
            background: linear-gradient(135deg, #1f2937, #111827);
        }

        .github-icon {
            width: 20px;
            height: 20px;
        }

        .about-footer {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid rgba(240, 147, 251, 0.2);
            color: #9ca3af;
            font-size: 13px;
            font-style: italic;
        }

        /* Achievement System Styles */
        .achievement-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(10px);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 4000;
            overflow-y: auto;
            overscroll-behavior: contain;
        }

        .achievement-content {
            background: linear-gradient(135deg, #ffffff, #f9fafb);
            padding: 30px;
            border-radius: 30px;
            width: 90%;
            max-width: 480px;
            max-height: 85vh;
            overflow-y: auto;
            box-shadow: 0 25px 70px rgba(0, 0, 0, 0.4);
            animation: achievementSlideIn 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        @keyframes achievementSlideIn {
            from {
                transform: translateY(100px) scale(0.8);
                opacity: 0;
            }

            to {
                transform: translateY(0) scale(1);
                opacity: 1;
            }
        }

        .achievement-header {
            text-align: center;
            margin-bottom: 25px;
        }

        .achievement-title {
            font-size: 32px;
            font-weight: bold;
            background: linear-gradient(135deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            margin-bottom: 10px;
        }

        .achievement-subtitle {
            color: #6b7280;
            font-size: 16px;
        }

        .badges-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            margin-bottom: 30px;
        }

        .badge-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 15px;
            border-radius: 20px;
            background: white;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.08);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            cursor: pointer;
            position: relative;
            overflow: hidden;
        }

        .badge-item.unlocked {
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.1), rgba(118, 75, 162, 0.1));
            box-shadow: 0 6px 25px rgba(102, 126, 234, 0.2);
        }

        .badge-item.unlocked:hover {
            transform: translateY(-5px) scale(1.05);
            box-shadow: 0 10px 35px rgba(102, 126, 234, 0.3);
        }

        .badge-item.locked {
            opacity: 0.6;
            background: #f3f4f6;
        }

        .badge-icon {
            font-size: 48px;
            margin-bottom: 8px;
            filter: grayscale(100%);
            opacity: 0.3;
            transition: all 0.5s;
        }

        .badge-item.unlocked .badge-icon {
            filter: grayscale(0%);
            opacity: 1;
            animation: badgeUnlock 0.6s;
        }

        @keyframes badgeUnlock {
            0% {
                transform: scale(0) rotate(0deg);
            }

            50% {
                transform: scale(1.2) rotate(180deg);
            }

            100% {
                transform: scale(1) rotate(360deg);
            }
        }

        .badge-name {
            font-size: 12px;
            font-weight: bold;
            color: #4b5563;
            text-align: center;
            margin-bottom: 4px;
        }

        .badge-item.unlocked .badge-name {
            color: #764ba2;
        }

        .badge-description {
            font-size: 10px;
            color: #9ca3af;
            text-align: center;
        }

        .badge-progress {
            width: 100%;
            height: 4px;
            background: #e5e7eb;
            border-radius: 2px;
            margin-top: 8px;
            overflow: hidden;
        }

        .badge-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4ade80, #22c55e);
            border-radius: 2px;
            transition: width 0.5s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .achievement-stats {
            background: linear-gradient(135deg, rgba(240, 147, 251, 0.1), rgba(245, 87, 108, 0.1));
            padding: 20px;
            border-radius: 20px;
            margin-bottom: 20px;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 12px;
            font-size: 14px;
        }

        .stat-label {
            color: #6b7280;
            font-weight: 600;
        }

        .stat-value {
            color: #764ba2;
            font-weight: bold;
        }

        .close-achievements {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 16px 35px;
            border-radius: 20px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            width: 100%;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }

        .close-achievements:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 25px rgba(102, 126, 234, 0.4);
        }

        /* Achievement Unlock Notification */
        .achievement-notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background: linear-gradient(135deg, #ffffff, #f9fafb);
            padding: 20px 25px;
            border-radius: 20px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
            display: none;
            align-items: center;
            gap: 15px;
            z-index: 15000;
            animation: notificationSlide 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
            border: 2px solid transparent;
            background-clip: padding-box;
            position: relative;
        }

        .achievement-notification:before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            background: linear-gradient(135deg, #fbbf24, #f59e0b);
            border-radius: 20px;
            z-index: -1;
            animation: shimmerNotification 2s linear infinite;
        }

        @keyframes shimmerNotification {
            0% {
                background: linear-gradient(135deg, #fbbf24, #f59e0b);
            }

            50% {
                background: linear-gradient(135deg, #f59e0b, #fbbf24);
            }

            100% {
                background: linear-gradient(135deg, #fbbf24, #f59e0b);
            }
        }

        @keyframes notificationSlide {
            from {
                transform: translateX(400px) scale(0.8);
                opacity: 0;
            }

            to {
                transform: translateX(0) scale(1);
                opacity: 1;
            }
        }

        .achievement-notification-icon {
            font-size: 48px;
            animation: celebrateIcon 1s;
        }

        @keyframes celebrateIcon {

            0%,
            100% {
                transform: scale(1) rotate(0deg);
            }

            25% {
                transform: scale(1.2) rotate(10deg);
            }

            50% {
                transform: scale(1.1) rotate(-10deg);
            }

            75% {
                transform: scale(1.15) rotate(5deg);
            }
        }

        .achievement-notification-content {
            flex: 1;
        }

        .achievement-notification-title {
            font-size: 16px;
            font-weight: bold;
            color: #764ba2;
            margin-bottom: 4px;
        }

        .achievement-notification-text {
            font-size: 14px;
            color: #6b7280;
        }

        /* Mobile adjustments */
        @media (max-width: 600px) {
            .achievement-notification {
                top: 20px;
                right: 50%;
                transform: translateX(50%);
                animation: notificationSlide 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
            }

            @keyframes notificationSlide {
                from {
                    transform: translate(50%, -150px) scale(0.8);
                    opacity: 0;
                }

                to {
                    transform: translate(50%, 0) scale(1);
                    opacity: 1;
                }
            }
        }

        /* Difficulty Indicator */
        .difficulty-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
            background: rgba(255, 255, 255, 0.9);
            padding: 6px 12px;
            border-radius: 15px;
            font-size: 12px;
            font-weight: 600;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        .difficulty-label {
            color: #6b7280;
        }

        .difficulty-level {
            color: #764ba2;
            display: flex;
            gap: 3px;
        }

        .difficulty-bar {
            width: 4px;
            height: 12px;
            background: #e5e7eb;
            border-radius: 2px;
            transition: all 0.3s;
        }

        .difficulty-bar.active {
            background: linear-gradient(to top, #4ade80, #22c55e);
        }

        .difficulty-bar.active.medium {
            background: linear-gradient(to top, #fbbf24, #f59e0b);
        }

        .difficulty-bar.active.hard {
            background: linear-gradient(to top, #f87171, #ef4444);
        }

        /* Enhanced Round Completion Modal */
        .round-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(10px);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 3000;
            overscroll-behavior: contain;
        }

        .round-content {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 40px;
            border-radius: 30px;
            width: 90%;
            max-width: 420px;
            text-align: center;
            animation: roundSlideIn 0.6s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.4);
        }

        @keyframes roundSlideIn {
            from {
                transform: translateY(-50px) scale(0.9);
                opacity: 0;
            }

            to {
                transform: translateY(0) scale(1);
                opacity: 1;
            }
        }

        .round-title {
            font-size: 32px;
            font-weight: bold;
            margin-bottom: 25px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.2);
        }

        .round-stats {
            margin-bottom: 30px;
            background: rgba(255, 255, 255, 0.15);
            padding: 20px;
            border-radius: 20px;
            backdrop-filter: blur(10px);
        }

        .round-stat {
            margin-bottom: 12px;
            font-size: 18px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .round-stat-label {
            opacity: 0.9;
        }

        .round-stat-value {
            font-weight: bold;
            font-size: 20px;
        }

        .problem-letters {
            background: rgba(255, 255, 255, 0.2);
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 25px;
            backdrop-filter: blur(10px);
        }

        .problem-letters-title {
            font-weight: bold;
            margin-bottom: 10px;
            font-size: 18px;
        }

        .problem-letters-list {
            font-size: 24px;
            letter-spacing: 8px;
            font-weight: bold;
        }

        .continue-btn {
            background: linear-gradient(135deg, #4ade80, #22c55e);
            color: white;
            border: none;
            padding: 18px 40px;
            border-radius: 25px;
            font-size: 20px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 10px 30px rgba(74, 222, 128, 0.3);
        }

        .continue-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 15px 40px rgba(74, 222, 128, 0.4);
        }

        /* Enhanced Phonics Phase */
        .phonics-phase {
            text-align: center;
            animation: phonicsSlideIn 0.5s;
            padding: 30px;
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.1), rgba(118, 75, 162, 0.1));
            border-radius: 30px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
        }

        @keyframes phonicsSlideIn {
            from {
                opacity: 0;
                transform: scale(0.9);
            }

            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        .phonics-instruction {
            font-size: clamp(16px, 3.5vh, 24px);
            color: #764ba2;
            margin-bottom: clamp(8px, 2.2vh, 20px);
            font-weight: bold;
        }

        .phonics-timer {
            font-size: clamp(42px, 12.5vh, 72px);
            font-weight: bold;
            margin-bottom: clamp(8px, 2.5vh, 20px);
            animation: phonicsCount 1s infinite;
            background: linear-gradient(90deg, #f093fb, #f5576c);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            line-height: 1;
            /* keep emoji centered when we swap to ðŸ”Š */
            font-family: -apple-system, system-ui, "Apple Color Emoji", "Segoe UI Emoji", "Noto Color Emoji", sans-serif;
            min-width: 80px;
            /* reserve space to avoid layout shift */
            display: inline-flex;
            align-items: center;
            justify-content: center;
            aspect-ratio: 1 / 1;
            height: clamp(42px, 12.5vh, 72px);
            width: auto;
        }

        @keyframes phonicsCount {

            0%,
            100% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.05);
            }
        }

        .phonics-letter {
            font-size: clamp(56px, 18vh, 100px);
            margin-top: clamp(6px, 2vh, 20px);
            font-weight: bold;
            background: linear-gradient(90deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            animation: letterPulse 2s ease-in-out infinite;
        }

        @keyframes letterPulse {

            0%,
            100% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.05);
            }
        }

        /* Mobile Responsiveness */
        @media (max-width: 480px) {
            .option-btn {
                font-size: 36px;
                padding: 16px;
            }

            .sound-btn {
                width: 100px;
                height: 100px;
                font-size: 48px;
            }

            .letter-display {
                font-size: 64px;
            }
        }

        /* Ultra-narrow devices */
        @media (max-width: 320px) {
            .header {
                font-size: 18px;
                padding: 10px 12px;
            }

            .mode-btn {
                font-size: 14px;
                padding: 10px;
            }

            .option-btn {
                font-size: 30px;
                padding: 16px;
            }

            .sound-btn {
                width: 100px;
                height: 100px;
                font-size: 50px;
            }

            .letter-display {
                font-size: 60px;
            }

            .timer-display {
                font-size: 22px;
            }

            .start-btn {
                font-size: 20px;
                padding: 16px 36px;
            }

            .stars {
                font-size: 20px;
            }

            .score-value {
                font-size: 18px;
            }

            /* Layout fixes for very small screens */
            .score-panel {
                justify-content: space-between;
            }

            .difficulty-indicator {
                width: 100%;
                margin-top: 8px;
                justify-content: center;
            }
        }

        /* Multiplayer Mode Styles */
        .player-selector {
            position: absolute;
            top: 70px;
            left: 0;
            right: 0;
            background: linear-gradient(to right, rgba(102, 126, 234, 0.1), rgba(118, 75, 162, 0.1));
            padding: 12px 20px;
            display: none;
            align-items: center;
            justify-content: space-between;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
            animation: slideDown 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        @keyframes slideDown {
            from {
                transform: translateY(-100%);
                opacity: 0;
            }

            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .player-list {
            display: flex;
            gap: 10px;
            flex: 1;
            overflow-x: auto;
            padding: 5px 0;
        }

        .player-chip {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 16px;
            background: white;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            white-space: nowrap;
            font-weight: 600;
            color: #6b7280;
            border: 2px solid transparent;
            position: relative;
        }

        .player-chip.active {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            transform: scale(1.05);
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }

        .player-chip.waiting {
            animation: playerPulse 2s infinite;
        }

        @keyframes playerPulse {

            0%,
            100% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.05);
            }
        }

        .player-avatar {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            background: linear-gradient(135deg, #fbbf24, #f59e0b);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
        }

        .player-name {
            font-size: 14px;
        }

        .player-score {
            font-size: 12px;
            opacity: 0.8;
        }

        .player-turn-indicator {
            position: absolute;
            top: -8px;
            right: -8px;
            width: 16px;
            height: 16px;
            background: #4ade80;
            border-radius: 50%;
            border: 2px solid white;
            animation: turnBlink 1s infinite;
        }

        @keyframes turnBlink {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.5;
            }
        }

        .add-player-btn {
            padding: 8px 16px;
            background: linear-gradient(135deg, #4ade80, #22c55e);
            color: white;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            font-weight: 600;
            font-size: 14px;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .add-player-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 15px rgba(74, 222, 128, 0.3);
        }

        /* Player Setup Modal */
        .player-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 5000;
            overscroll-behavior: contain;
        }

        .player-modal-content {
            background: white;
            padding: 30px;
            border-radius: 30px;
            width: 90%;
            max-width: 400px;
            box-shadow: 0 25px 70px rgba(0, 0, 0, 0.4);
            animation: modalBounce 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        @keyframes modalBounce {
            from {
                transform: scale(0.8);
                opacity: 0;
            }

            to {
                transform: scale(1);
                opacity: 1;
            }
        }

        .player-modal-title {
            font-size: 24px;
            font-weight: bold;
            color: #764ba2;
            margin-bottom: 20px;
            text-align: center;
        }

        .avatar-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 10px;
            margin-bottom: 20px;
        }

        .avatar-option {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: linear-gradient(135deg, #e5e7eb, #d1d5db);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            border: 3px solid transparent;
        }

        .avatar-option:hover {
            transform: scale(1.1);
        }

        .avatar-option.selected {
            border-color: #667eea;
            transform: scale(1.15);
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }

        .player-name-input {
            width: 100%;
            padding: 15px;
            font-size: 18px;
            border: 2px solid #e5e7eb;
            border-radius: 15px;
            margin-bottom: 20px;
            transition: all 0.3s;
        }

        .player-name-input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .player-modal-buttons {
            display: flex;
            gap: 10px;
        }

        .player-modal-btn {
            flex: 1;
            padding: 15px;
            border: none;
            border-radius: 15px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .player-modal-cancel {
            background: #f3f4f6;
            color: #6b7280;
        }

        .player-modal-save {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
        }

        .player-modal-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }

        /* Letter Formation Guide Styles */
        .formation-guide {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 10;
        }

        .stroke-path {
            fill: none;
            stroke: #667eea;
            stroke-width: 3;
            stroke-linecap: round;
            stroke-linejoin: round;
            opacity: 0.3;
        }

        .stroke-animated {
            stroke-dasharray: 1000;
            stroke-dashoffset: 1000;
            animation: drawStroke 2s ease-in-out infinite;
        }

        @keyframes drawStroke {
            to {
                stroke-dashoffset: 0;
            }
        }

        .stroke-number {
            width: 24px;
            height: 24px;
            background: linear-gradient(135deg, #f093fb, #f5576c);
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: bold;
            position: absolute;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
            animation: numberPulse 2s infinite;
        }

        @keyframes numberPulse {

            0%,
            100% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.2);
            }
        }

        .formation-controls {
            display: flex;
            gap: 12px;
            margin-top: 20px;
            justify-content: center;
            width: 100%;
            max-width: 350px; /* align with main controls width */
            align-items: stretch;
        }

        .formation-btn {
            padding: 10px 20px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            border-radius: 15px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            flex: 1; /* equal widths */
            text-align: center;
        }

        .formation-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }

        .formation-btn.secondary {
            background: #f3f4f6;
            color: #6b7280;
        }

        /* Parent Dashboard Styles */
        .parent-dashboard {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #ffffff, #f9fafb);
            display: none;
            overflow-y: auto;
            z-index: 6000;
            animation: dashboardSlide 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }

        @keyframes dashboardSlide {
            from {
                transform: translateX(100%);
            }

            to {
                transform: translateX(0);
            }
        }

        .dashboard-header {
            background: linear-gradient(90deg, #667eea, #764ba2);
            color: white;
            padding: 20px;
            position: sticky;
            top: 0;
            z-index: 100;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
        }

        .dashboard-title {
            font-size: 28px;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .dashboard-subtitle {
            opacity: 0.9;
            font-size: 16px;
        }

        .dashboard-close {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            font-size: 24px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .dashboard-close:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.1);
        }

        .dashboard-content {
            padding: 20px;
            max-width: 800px;
            margin: 0 auto;
        }

        .dashboard-section {
            background: white;
            border-radius: 20px;
            padding: 25px;
            margin-bottom: 20px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.08);
        }

        .dashboard-section-title {
            font-size: 20px;
            font-weight: bold;
            color: #764ba2;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .player-stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
        }

        .player-stat-card {
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.05), rgba(118, 75, 162, 0.05));
            padding: 20px;
            border-radius: 15px;
            border: 2px solid rgba(102, 126, 234, 0.1);
        }

        .player-stat-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
        }

        .player-stat-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea, #764ba2);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            color: white;
        }

        .player-stat-name {
            font-weight: bold;
            color: #374151;
            font-size: 18px;
        }

        .stat-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .stat-item {
            background: white;
            padding: 10px;
            border-radius: 10px;
            text-align: center;
        }

        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #667eea;
        }

        .stat-label {
            font-size: 12px;
            color: #9ca3af;
            margin-top: 4px;
        }

        .letter-heatmap {
            display: grid;
            grid-template-columns: repeat(13, 1fr);
            gap: 5px;
            margin-top: 20px;
        }

        .heatmap-cell {
            aspect-ratio: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 8px;
            font-weight: bold;
            font-size: 14px;
            transition: all 0.3s;
            cursor: pointer;
        }

        .heatmap-cell:hover {
            transform: scale(1.2);
            z-index: 10;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .heatmap-legend {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 15px;
            font-size: 12px;
            color: #6b7280;
        }

        .legend-gradient {
            flex: 1;
            height: 20px;
            background: linear-gradient(to right, #ef4444, #fbbf24, #4ade80);
            border-radius: 10px;
        }

        .insights-list {
            list-style: none;
            padding: 0;
        }

        .insight-item {
            display: flex;
            align-items: flex-start;
            gap: 15px;
            padding: 15px;
            background: linear-gradient(135deg, rgba(74, 222, 128, 0.05), rgba(34, 197, 94, 0.05));
            border-radius: 15px;
            margin-bottom: 10px;
            border-left: 4px solid #4ade80;
        }

        .insight-icon {
            font-size: 24px;
            flex-shrink: 0;
        }

        .insight-content {
            flex: 1;
        }

        .insight-title {
            font-weight: bold;
            color: #374151;
            margin-bottom: 5px;
        }

        .insight-description {
            color: #6b7280;
            font-size: 14px;
            line-height: 1.5;
        }

        .recommendation-card {
            background: linear-gradient(135deg, rgba(240, 147, 251, 0.1), rgba(245, 87, 108, 0.1));
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 15px;
        }

        .recommendation-title {
            font-weight: bold;
            color: #764ba2;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .recommendation-text {
            color: #4b5563;
            line-height: 1.6;
        }

        /* Visual Learning Styles */
        .theme-selector {
            display: flex;
            gap: 10px;
            padding: 15px;
            background: linear-gradient(to right, rgba(102, 126, 234, 0.05), rgba(118, 75, 162, 0.05));
            border-radius: 15px;
            margin-bottom: 20px;
        }

        .theme-option {
            flex: 1;
            padding: 15px;
            border: 3px solid #e5e7eb;
            background: white;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            text-align: center;
        }

        .theme-option:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }

        .theme-option.active {
            border-color: #667eea;
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.1), rgba(118, 75, 162, 0.1));
            transform: scale(1.05);
        }

        .theme-icon {
            font-size: 32px;
            margin-bottom: 8px;
        }

        .theme-name {
            font-size: 14px;
            font-weight: 600;
            color: #4b5563;
        }

        .theme-option.active .theme-name {
            color: #764ba2;
        }

        /* Visual Associations */
        .letter-association {
            position: absolute;
            bottom: -40px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            align-items: center;
            gap: 8px;
            background: white;
            padding: 8px 15px;
            border-radius: 20px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            font-size: 14px;
            font-weight: 600;
            color: #764ba2;
            animation: associationBounce 2s infinite;
        }

        @keyframes associationBounce {

            0%,
            100% {
                transform: translateX(-50%) translateY(0);
            }

            50% {
                transform: translateX(-50%) translateY(-5px);
            }
        }

        .association-icon {
            font-size: 24px;
        }

        .vowel-highlight {
            background: linear-gradient(135deg, var(--primary), var(--primary-dark));
            color: white;
            padding: 2px 6px;
            border-radius: 8px;
        }

        .consonant-highlight {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 2px 6px;
            border-radius: 8px;
        }

        /* Mini-Games Styles */
        .minigame-container {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            position: relative;
        }

        .minigame-header {
            position: absolute;
            top: 20px;
            left: 20px;
            right: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .minigame-score {
            font-size: 24px;
            font-weight: bold;
            color: #764ba2;
        }

        .minigame-timer {
            font-size: 20px;
            font-weight: 600;
            color: #f5576c;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .minigame-timer.warning {
            animation: pulse-red 0.5s infinite;
        }

        /* Letter Rain Game */
        .rain-game-area {
            position: relative;
            width: 100%;
            height: 400px;
            background: linear-gradient(to bottom, #dbeafe, #bfdbfe);
            border-radius: 20px;
            overflow: hidden;
            margin-top: 60px;
            touch-action: none;
            /* Prevent page scroll while dragging */
        }

        .rain-basket {
            position: absolute;
            bottom: 20px;
            width: 80px;
            height: 60px;
            background: linear-gradient(135deg, #f59e0b, #d97706);
            border-radius: 10px 10px 20px 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 30px;
            color: white;
            font-weight: bold;
            transition: left 0.1s;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .falling-letter {
            position: absolute;
            font-size: 36px;
            font-weight: bold;
            color: white;
            background: linear-gradient(135deg, #667eea, #764ba2);
            width: 50px;
            height: 50px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            animation: letterFall linear;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        @keyframes letterFall {
            from {
                transform: translateY(-60px) rotate(0deg);
            }

            to {
                transform: translateY(460px) rotate(360deg);
            }
        }

        .rain-target-letter {
            font-size: 48px;
            font-weight: bold;
            color: #764ba2;
            margin-bottom: 20px;
            text-align: center;
        }

        /* Memory Match Game */
        .memory-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
            max-width: 400px;
            margin: 60px auto 20px;
        }

        .memory-card {
            aspect-ratio: 1;
            background: linear-gradient(135deg, #667eea, #764ba2);
            border-radius: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 36px;
            font-weight: bold;
            color: white;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            transform-style: preserve-3d;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .memory-card:hover {
            transform: scale(1.05);
        }

        .memory-card.flipped {
            transform: rotateY(180deg);
        }

        .memory-card-front,
        .memory-card-back {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 15px;
        }

        .memory-card-front {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            font-size: 40px;
        }

        .memory-card-back {
            background: white;
            transform: rotateY(180deg);
            border: 3px solid #667eea;
        }

        .memory-card.matched {
            animation: matchCelebration 0.6s;
            pointer-events: none;
        }

        @keyframes matchCelebration {
            0% {
                transform: scale(1) rotateY(180deg);
            }

            50% {
                transform: scale(1.2) rotateY(180deg) rotate(10deg);
            }

            100% {
                transform: scale(1) rotateY(180deg);
            }
        }

        /* Voice Recording Styles */
        .voice-recorder {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            padding: 20px;
            background: linear-gradient(135deg, rgba(239, 68, 68, 0.05), rgba(220, 38, 38, 0.05));
            border-radius: 20px;
            margin-top: 20px;
        }

        .record-button {
            width: 100px;
            height: 100px;
            border-radius: 50%;
            background: linear-gradient(135deg, #ef4444, #dc2626);
            border: 5px solid white;
            box-shadow: 0 5px 20px rgba(239, 68, 68, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 40px;
            color: white;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
        }

        .record-button:hover {
            transform: scale(1.05);
            box-shadow: 0 8px 30px rgba(239, 68, 68, 0.4);
        }

        .record-button.recording {
            animation: recordPulse 1.5s infinite;
            background: linear-gradient(135deg, #dc2626, #b91c1c);
        }

        @keyframes recordPulse {
            0% {
                box-shadow: 0 5px 20px rgba(239, 68, 68, 0.3);
            }

            50% {
                box-shadow: 0 5px 40px rgba(239, 68, 68, 0.6);
            }

            100% {
                box-shadow: 0 5px 20px rgba(239, 68, 68, 0.3);
            }
        }

        .recording-indicator {
            position: absolute;
            top: -5px;
            right: -5px;
            width: 20px;
            height: 20px;
            background: #ef4444;
            border-radius: 50%;
            border: 3px solid white;
            animation: recordBlink 1s infinite;
        }

        @keyframes recordBlink {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.3;
            }
        }

        .voice-controls {
            display: flex;
            gap: 15px;
        }

        .voice-btn {
            padding: 12px 24px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            border-radius: 15px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .voice-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }

        .voice-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .recording-list {
            width: 100%;
            max-width: 400px;
            margin-top: 20px;
        }

        .recording-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 15px;
            background: white;
            border-radius: 15px;
            margin-bottom: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
            transition: all 0.3s;
        }

        .recording-item:hover {
            transform: translateX(5px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }

        .recording-info {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .recording-letter {
            width: 40px;
            height: 40px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            font-weight: bold;
        }

        .recording-timestamp {
            color: #9ca3af;
            font-size: 12px;
        }

        .play-recording-btn {
            padding: 8px 16px;
            background: linear-gradient(135deg, #4ade80, #22c55e);
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }

        .play-recording-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 2px 10px rgba(74, 222, 128, 0.3);
        }

        /* Minigame Announcement */
        .minigame-announcement {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, #ffffff, #f9fafb);
            padding: 40px;
            border-radius: 30px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            text-align: center;
            z-index: 5000;
            animation: announcementPop 0.6s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        @keyframes announcementPop {
            from {
                transform: translate(-50%, -50%) scale(0);
            }

            to {
                transform: translate(-50%, -50%) scale(1);
            }
        }

        .minigame-announcement-title {
            font-size: 32px;
            font-weight: bold;
            background: linear-gradient(135deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            margin-bottom: 10px;
        }

        .minigame-announcement-subtitle {
            font-size: 18px;
            color: #6b7280;
            margin-bottom: 20px;
        }

        .minigame-announcement-icon {
            font-size: 64px;
            margin-bottom: 20px;
            animation: iconSpin 1s;
        }

        @keyframes iconSpin {
            from {
                transform: rotate(0deg) scale(0);
            }

            to {
                transform: rotate(360deg) scale(1);
            }
        }

        /* Focus Mode Styles */
        body.focus-mode {
            background: #f0f4f8;
        }

        .focus-mode .container {
            background: white;
        }

        .focus-mode .header {
            background: #4a5568;
            animation: none;
        }

        .focus-mode .mode-btn,
        .focus-mode .option-btn {
            animation: none;
            transition: background-color 0.2s, transform 0.2s;
            border-width: 4px;
            font-size: 110%;
        }

        .focus-mode .option-btn {
            padding: 35px;
            font-size: 56px;
            border-radius: 30px;
            box-shadow: none;
            background: #f7fafc;
            border-color: #2d3748;
            color: #2d3748;
        }

        .focus-mode .option-btn:hover {
            background: #e2e8f0;
            transform: scale(1.02);
        }

        .focus-mode .option-btn.correct {
            background: #48bb78;
            color: white;
            animation: none;
        }

        .focus-mode .option-btn.wrong {
            background: #f56565;
            color: white;
            animation: focusWrongShake 0.3s;
        }

        @keyframes focusWrongShake {

            0%,
            100% {
                transform: translateX(0);
            }

            25% {
                transform: translateX(-5px);
            }

            75% {
                transform: translateX(5px);
            }
        }

        .focus-mode .sound-btn {
            width: 160px;
            height: 160px;
            font-size: 80px;
            animation: none;
            background: #4a5568;
        }

        .focus-mode .timer-display,
        .focus-mode .timer-bar {
            display: none !important;
        }

        .focus-mode .bubble,
        .focus-mode .celebration-particle {
            display: none !important;
        }

        .focus-mode .feedback {
            animation: none;
            background: #2d3748;
        }

        .focus-mode-toggle {
            margin-top: 15px;
            padding: 15px;
            background: linear-gradient(135deg, #cbd5e0, #a0aec0);
            border-radius: 15px;
        }

        .focus-mode-options {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-top: 10px;
        }

        .focus-option {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px;
            background: white;
            border-radius: 10px;
        }

        .focus-option-label {
            font-size: 14px;
            color: #4a5568;
        }

        .focus-switch {
            position: relative;
            width: 50px;
            height: 26px;
            background: #cbd5e0;
            border-radius: 13px;
            cursor: pointer;
            transition: background 0.3s;
        }

        .focus-switch.active {
            background: #48bb78;
        }

        .focus-switch-thumb {
            position: absolute;
            top: 3px;
            left: 3px;
            width: 20px;
            height: 20px;
            background: white;
            border-radius: 50%;
            transition: transform 0.3s;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .focus-switch.active .focus-switch-thumb {
            transform: translateX(24px);
        }

        /* Streak System Styles */
        .streak-display {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, #fbbf24, #f59e0b);
            color: white;
            padding: 10px 20px;
            border-radius: 25px;
            display: flex;
            align-items: center;
            gap: 10px;
            font-weight: bold;
            box-shadow: 0 4px 20px rgba(251, 191, 36, 0.4);
            z-index: 100;
            /* remove continuous float; trigger on update only */
        }

        @keyframes streakFloat {

            0%,
            100% {
                transform: translateX(-50%) translateY(0);
            }

            50% {
                transform: translateX(-50%) translateY(-5px);
            }
        }

        /* One-off streak animation when updated */
        .streak-display.streak-animate {
            animation: streakModalBounce 0.6s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        .streak-icon {
            font-size: 24px;
            animation: flameDance 1s infinite;
        }

        @keyframes flameDance {

            0%,
            100% {
                transform: scale(1) rotate(0deg);
            }

            25% {
                transform: scale(1.1) rotate(-5deg);
            }

            75% {
                transform: scale(1.1) rotate(5deg);
            }
        }

        .streak-number {
            font-size: 20px;
        }

        .streak-text {
            font-size: 14px;
        }

        .streak-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 7000;
        }

        .streak-modal-content {
            background: linear-gradient(135deg, #ffffff, #fef3c7);
            padding: 40px;
            border-radius: 30px;
            text-align: center;
            max-width: 450px;
            animation: streakModalBounce 0.6s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        @keyframes streakModalBounce {
            from {
                transform: scale(0) rotate(0deg);
            }

            to {
                transform: scale(1) rotate(360deg);
            }
        }

        .streak-milestone-icon {
            font-size: 80px;
            margin-bottom: 20px;
            animation: milestoneGlow 2s infinite;
        }

        @keyframes milestoneGlow {

            0%,
            100% {
                transform: scale(1);
                filter: drop-shadow(0 0 20px rgba(251, 191, 36, 0.5));
            }

            50% {
                transform: scale(1.1);
                filter: drop-shadow(0 0 40px rgba(251, 191, 36, 0.8));
            }
        }

        .streak-milestone-title {
            font-size: 32px;
            font-weight: bold;
            color: #f59e0b;
            margin-bottom: 10px;
        }

        .streak-milestone-subtitle {
            font-size: 18px;
            color: #92400e;
            margin-bottom: 30px;
        }

        .streak-calendar {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 8px;
            padding: 20px;
            background: white;
            border-radius: 20px;
            margin-bottom: 20px;
        }

        .calendar-day {
            aspect-ratio: 1;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: 600;
            transition: all 0.3s;
        }

        .calendar-day.played {
            background: linear-gradient(135deg, #4ade80, #22c55e);
            color: white;
            transform: scale(1.1);
        }

        .calendar-day.missed {
            background: #e5e7eb;
            color: #9ca3af;
        }

        .calendar-day.today {
            border: 3px solid #f59e0b;
            animation: todayPulse 2s infinite;
        }

        @keyframes todayPulse {

            0%,
            100% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.15);
            }
        }

        /* Celebration Customization Styles */
        .celebration-selector {
            padding: 20px;
            background: linear-gradient(135deg, rgba(244, 114, 182, 0.1), rgba(236, 72, 153, 0.1));
            border-radius: 20px;
            margin-bottom: 20px;
        }

        .celebration-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin-top: 15px;
        }

        .celebration-option {
            padding: 20px;
            background: white;
            border: 3px solid #e5e7eb;
            border-radius: 15px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .celebration-option:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
        }

        .celebration-option.selected {
            border-color: #ec4899;
            background: linear-gradient(135deg, rgba(244, 114, 182, 0.1), rgba(236, 72, 153, 0.1));
            transform: scale(1.05);
        }

        .celebration-preview {
            font-size: 48px;
            margin-bottom: 10px;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .celebration-name {
            font-size: 14px;
            font-weight: 600;
            color: #4b5563;
        }

        .celebration-option.selected .celebration-name {
            color: #ec4899;
        }

        /* Custom Celebration Animations */
        .celebration-fireworks {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 9999;
        }

        .celebration-animals {
            position: fixed;
            width: 100px;
            height: 100px;
            font-size: 80px;
            animation: animalBounce 1s;
            pointer-events: none;
            z-index: 9999;
        }

        @keyframes animalBounce {
            0% {
                transform: scale(0) rotate(0deg);
                opacity: 0;
            }

            50% {
                transform: scale(1.5) rotate(180deg);
                opacity: 1;
            }

            100% {
                transform: scale(0) rotate(360deg);
                opacity: 0;
            }
        }

        .celebration-vehicles {
            position: fixed;
            font-size: 60px;
            animation: vehicleDrive 2s linear;
            pointer-events: none;
            z-index: 9999;
        }

        @keyframes vehicleDrive {
            from {
                left: -100px;
                transform: translateY(-50%) rotate(0deg);
            }

            to {
                left: calc(100% + 100px);
                transform: translateY(-50%) rotate(360deg);
            }
        }

        .celebration-space {
            position: fixed;
            font-size: 60px;
            animation: spaceFloat 3s ease-out;
            pointer-events: none;
            z-index: 9999;
        }

        @keyframes spaceFloat {
            0% {
                bottom: 50%;
                opacity: 1;
                transform: translateX(-50%) scale(1);
            }

            100% {
                bottom: 100%;
                opacity: 0;
                transform: translateX(-50%) scale(0.5);
            }
        }

        .celebration-dinosaurs {
            position: fixed;
            font-size: 70px;
            animation: dinoStomp 1.5s;
            pointer-events: none;
            z-index: 9999;
        }

        @keyframes dinoStomp {

            0%,
            100% {
                transform: scale(1) translateY(0);
            }

            25% {
                transform: scale(1.2) translateY(-20px) rotate(-10deg);
            }

            50% {
                transform: scale(1.3) translateY(0) rotate(0deg);
            }

            75% {
                transform: scale(1.2) translateY(-20px) rotate(10deg);
            }
        }

        .celebration-hearts {
            position: fixed;
            font-size: 50px;
            animation: heartFloat 2s ease-out;
            pointer-events: none;
            z-index: 9999;
            color: #ec4899;
        }

        @keyframes heartFloat {
            0% {
                bottom: 20%;
                opacity: 1;
                transform: translateX(-50%) scale(0);
            }

            50% {
                transform: translateX(-50%) scale(1.2);
            }

            100% {
                bottom: 80%;
                opacity: 0;
                transform: translateX(-50%) scale(0.8);
            }
        }

        /* Loading animation */
        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 5px solid #f3f3f3;
            border-top: 5px solid #764ba2;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        /* Final iPhone optimizations for perfect fit */
        @supports (-webkit-touch-callout: none) {

            /* iOS-specific styles */
            .container {
                height: -webkit-fill-available;
            }

            .game-area {
                -webkit-overflow-scrolling: none;
                overflow: hidden;
            }

            /* Ensure buttons are large enough for kids */
            .option-btn {
                min-height: 60px;
                min-width: 60px;
            }
        }

        /* iPhone landscape mode */
        @media (max-height: 450px) and (orientation: landscape) {
            .header {
                padding: 8px 12px;
                padding-top: calc(8px + env(safe-area-inset-top, 0px));
            }

            .header-title {
                font-size: 14px;
            }

            .game-area {
                padding: 8px;
            }

            .letter-display {
                font-size: min(35vh, 90px);
                margin: 4px 0;
            }

            .options {
                grid-template-columns: repeat(4, 1fr);
                gap: 8px;
            }

            .option-btn {
                height: min(30vh, 65px);
                font-size: min(10vh, 30px);
            }

            .sound-btn {
                width: min(25vh, 80px);
                height: min(25vh, 80px);
                font-size: min(12vh, 40px);
                margin-bottom: 8px;
            }

            .score-panel {
                padding: 6px 10px;
                margin-bottom: 6px;
            }

            .mode-selector {
                padding: 6px 10px;
            }
        }

        /* Compact portrait (most phones): tighten spacing so 2 rows fit cleanly */
        @media (max-width: 430px) and (orientation: portrait) {
            .score-panel { padding: 12px 16px; }
            .mode-selector { padding: 10px 12px; gap: 8px; }
            .game-area { padding: 8px 12px 12px; padding-bottom: max(16px, calc(12px + env(safe-area-inset-bottom, 0px))); }
            .game-area.with-sound { padding-top: clamp(6px, 1.6vmin, 12px); }
            .game-area.with-sound .sound-btn { width: clamp(64px, 14vmin, 96px); height: clamp(64px, 14vmin, 96px); transform: translate(-50%, -61%); }
            .options { gap: clamp(8px, 2vmin, 14px); padding-top: clamp(28px, 7.5vmin, 52px); max-width: 340px; }
            .instruction { font-size: clamp(14px, 2.2vmin, 18px); margin: 4px 0 6px; }
            /* Nudge instruction slightly lower when sound button is present to avoid top overlap on iPhone */
            .game-area.with-sound .instruction { margin-top: clamp(6px, 1.8vmin, 10px); }
        }

        /* Desktop layout improvements: only on wide pointer/hover devices (keeps iPhone/mobile unchanged) */
        @media (min-width: 1024px) and (hover: hover) and (pointer: fine) {
            /* Center and normalize background to avoid right-side banding */
            body {
                background-position: center center;
                background-size: 100% 100%;
                background-attachment: fixed;
            }

            /* Center children horizontally */
            .container { align-items: center; }
            /* Constrain primary sections and center for symmetry */
            .header,
            .player-selector,
            .score-panel,
            .mode-selector,
            .game-area {
                width: min(980px, 92vw);
                margin-left: auto;
                margin-right: auto;
            }

            .header {
                margin-top: 16px;
                border-radius: 16px;
            }

            .score-panel {
                margin-top: 12px;
                border-radius: 14px;
                padding: 16px 24px;
                gap: 12px;
            }

            .game-area {
                margin-top: 12px;
                border-radius: 28px 28px 0 0;
                padding: 16px 24px 24px;
            }

            /* Larger, cleaner tiles on desktop while keeping 2x2 grid */
            .options {
                max-width: 560px;
                gap: 20px;
                padding-top: clamp(48px, 8vmin, 80px);
            }

            .option-btn {
                min-height: 150px;
                font-size: clamp(48px, 5vmin, 72px);
                border-radius: 20px;
                box-shadow: 0 6px 18px rgba(0, 0, 0, 0.08), 0 2px 6px rgba(0, 0, 0, 0.06);
            }

            /* Slightly increase the prominence of the sound button */
            .game-area.with-sound .sound-btn {
                width: clamp(96px, 10vmin, 128px);
                height: clamp(96px, 10vmin, 128px);
                transform: translate(-50%, -60%);
            }

            .instruction {
                font-size: 20px;
                margin: 8px 0 12px;
            }

            .controls {
                max-width: 420px;
                gap: 16px;
            }

            /* Ensure absolute player selector centers horizontally on desktop */
            .player-selector {
                left: 50%;
                right: auto;
                transform: translateX(-50%);
                width: min(980px, 92vw);
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="header">
            <button class="badges-btn" onclick="openAchievements()" aria-label="Open achievements">
                ðŸ†
                <span class="badge-count" id="badgeCount">0</span>
            </button>
            <div class="header-title">Letter Learning</div>
            <button class="settings-btn" onclick="openSettings()" id="settingsBtn"
                aria-label="Open settings (hold for Parent Dashboard)">âš™ï¸</button>
        </div>

        <!-- Player Selector (Multiplayer Mode) -->
        <div class="player-selector" id="playerSelector">
            <div class="player-list" id="playerList">
                <!-- Player chips will be added here -->
            </div>
            <button class="add-player-btn" onclick="showAddPlayer()" aria-label="Add player">
                <span>âž•</span>
                <span>Add Player</span>
            </button>
        </div>

        <div class="mode-selector">
            <button class="mode-btn active" onclick="setMode('identify', this)" aria-pressed="true"
                aria-label="Find letters mode">
                <span>Find Letters</span>
            </button>
            <button class="mode-btn" onclick="setMode('draw', this)" aria-pressed="false"
                aria-label="Tracing practice mode">
                <span>Tracing Practice</span>
            </button>
        </div>

        <div class="score-panel" id="scorePanel">
            <div class="score-left">
                <div class="stars" id="starsDisplay"></div>
                <div>Round <span id="roundNumber">1</span></div>
            </div>
            <div class="score-right">
                <div class="score-value">Score: <span id="scoreDisplay">0</span></div>
                <div><span id="correctCount">0</span>/<span id="totalCount">15</span> | âŒ <span id="wrongCount">0</span>
                </div>
            </div>
            <div class="difficulty-indicator" id="difficultyIndicator">
                <span class="difficulty-label">Difficulty:</span>
                <div class="difficulty-level">
                    <div class="difficulty-bar" id="diff1"></div>
                    <div class="difficulty-bar" id="diff2"></div>
                    <div class="difficulty-bar" id="diff3"></div>
                    <div class="difficulty-bar" id="diff4"></div>
                    <div class="difficulty-bar" id="diff5"></div>
                </div>
            </div>
        </div>

        <div class="timer-display" id="timerDisplay"></div>
        <div class="timer-bar" id="timerBar" style="display: none;">
            <div class="timer-bar-fill" id="timerBarFill"></div>
        </div>

        <div class="game-area" id="gameArea">
            <div class="start-screen">
                <h2>Welcome to Letter Learning! ðŸŽ‰</h2>
                <p>This fun game helps you learn letters through sounds and interaction!</p>
                <p>ðŸ”Š Make sure your volume is turned up</p>
                <p>â­ Earn stars and points as you play</p>
                <p>ðŸŽ¯ Complete rounds to unlock new challenges</p>
                <button class="start-btn" onclick="startIdentifyGame(true)" aria-label="Start the game">Let's
                    Start!</button>
            </div>
        </div>

        <div class="feedback" id="feedback" role="status" aria-live="polite" aria-atomic="true"></div>

        <!-- Streak Display -->
        <div class="streak-display" id="streakDisplay" style="display: none;">
            <span class="streak-icon">ðŸ”¥</span>
            <span class="streak-number" id="streakNumber">0</span>
            <span class="streak-text">day streak!</span>
        </div>

        <!-- Streak Milestone Modal -->
        <div class="streak-modal" id="streakModal">
            <div class="streak-modal-content">
                <div class="streak-milestone-icon" id="milestoneIcon">ðŸ†</div>
                <div class="streak-milestone-title" id="milestoneTitle">Amazing Streak!</div>
                <div class="streak-milestone-subtitle" id="milestoneSubtitle">You've been learning every day!</div>
                <div class="streak-calendar" id="streakCalendar">
                    <!-- Calendar will be generated here -->
                </div>
                <button class="continue-btn" onclick="closeStreakModal()" aria-label="Close streak milestone">Keep
                    Going!</button>
            </div>
        </div>

        <!-- Settings Modal -->
        <div class="settings-modal" id="settingsModal">
            <div class="settings-content">
                <div class="settings-header">Game Settings</div>
                <div class="settings-body">
                    <div class="settings-callout" role="region" aria-label="Parent dashboard quick access">
                        <div class="callout-text">
                            <div class="callout-title">Parent Dashboard</div>
                            <div class="callout-subtitle">See progress, trends, and manage learning options.</div>
                        </div>
                        <button class="parent-cta" onclick="openParentDashboardViaSettings()" aria-label="Open Parent Dashboard">Open</button>
                    </div>
                    <div class="settings-section">
                        <div class="settings-section-title">Basic Settings</div>
                        <div class="setting-group">
                            <label class="setting-label">Timer <span class="info-tip" title="Set a countdown for each question.">?</span></label>
                            <div class="toggle-group">
                                <button class="toggle-btn" id="timerOff" onclick="setTimerMode('off')"
                                    aria-pressed="false" aria-label="Turn timer off">Off</button>
                                <button class="toggle-btn active" id="timerOn" onclick="setTimerMode('on')"
                                    aria-pressed="true" aria-label="Turn timer on">On</button>
                            </div>
                        </div>
                        <div class="setting-group">
                            <label class="setting-label">Letters <span class="info-tip" title="Choose which letter case to practice.">?</span></label>
                            <div class="toggle-group">
                                <button class="toggle-btn" id="caseLower" onclick="setCaseMode('lower')"
                                    aria-pressed="false" aria-label="Use lowercase letters">abc</button>
                                <button class="toggle-btn" id="caseUpper" onclick="setCaseMode('upper')"
                                    aria-pressed="false" aria-label="Use uppercase letters">ABC</button>
                                <button class="toggle-btn active" id="caseMixed" onclick="setCaseMode('mixed')"
                                    aria-pressed="true" aria-label="Use both cases">Both</button>
                            </div>
                        </div>
                        <div class="setting-group">
                            <label class="setting-label">Phonics <span class="info-tip" title="Enable phonics-style prompts and guidance.">?</span></label>
                            <div class="toggle-group">
                                <button class="toggle-btn active" id="phonicsOn" onclick="setPhonicsMode('on')"
                                    aria-pressed="true" aria-label="Enable phonics flow">On</button>
                                <button class="toggle-btn" id="phonicsOff" onclick="setPhonicsMode('off')"
                                    aria-pressed="false" aria-label="Disable phonics flow">Off</button>
                            </div>
                        </div>
                        <div class="setting-group">
                            <label class="setting-label">Sound <span class="info-tip" title="Turn game sounds and speech on or off.">?</span></label>
                            <div class="toggle-group">
                                <button class="toggle-btn active" id="soundOn" onclick="setSoundMode('on')"
                                    aria-pressed="true" aria-label="Turn sound on">On</button>
                                <button class="toggle-btn" id="soundOff" onclick="setSoundMode('off')"
                                    aria-pressed="false" aria-label="Turn sound off">Off</button>
                            </div>
                        </div>
                    </div>

                    <div class="settings-section">
                        <div class="settings-section-title">Visual Theme</div>
                        <div class="theme-grid">
                            <button class="theme-button active" onclick="setVisualTheme('classic')">
                                <div class="theme-icon">ðŸ”¤</div>
                                <div class="theme-name">Classic</div>
                            </button>
                            <button class="theme-button" onclick="setVisualTheme('animals')">
                                <div class="theme-icon">ðŸ¾</div>
                                <div class="theme-name">Animals</div>
                            </button>
                            <button class="theme-button" onclick="setVisualTheme('colors')">
                                <div class="theme-icon">ðŸŽ¨</div>
                                <div class="theme-name">Colors</div>
                            </button>
                        </div>
                    </div>

                    <details class="settings-section advanced-settings" open>
                        <summary class="settings-section-title">Advanced Settings</summary>
                        <div class="setting-group">
                            <label class="setting-label">Voice Recording <span class="info-tip" title="Record the child's voice to practice and compare." >?</span></label>
                            <div class="toggle-switch">
                                <input type="checkbox" id="voiceToggle" onchange="toggleVoiceRecording(this.checked)">
                                <label for="voiceToggle" class="toggle-switch-label"></label>
                            </div>
                        </div>
                        <div class="setting-group">
                            <label class="setting-label"
                                style="display: flex; justify-content: space-between; align-items: center; cursor: pointer;">
                                <span>Focus Mode <span class="info-tip" title="Hide distractions to help kids focus.">?</span></span>
                                <div class="toggle-switch">
                                    <input type="checkbox" id="focusModeCheck" onchange="toggleFocusMode()">
                                    <label for="focusModeCheck" class="toggle-switch-label"></label>
                                </div>
                            </label>
                        </div>
                        <div class="setting-group">
                            <label class="setting-label"
                                style="display: flex; justify-content: space-between; align-items: center; cursor: pointer;">
                                <span>High Contrast <span class="info-tip" title="Boost contrast for better visibility.">?</span></span>
                                <div class="toggle-switch">
                                    <input type="checkbox" id="highContrastCheck" onchange="toggleHighContrast()">
                                    <label for="highContrastCheck" class="toggle-switch-label"></label>
                                </div>
                            </label>
                        </div>
                        <div class="setting-group">
                            <label class="setting-label"
                                style="display: flex; justify-content: space-between; align-items: center; cursor: pointer;">
                                <span>Reduce Motion <span class="info-tip" title="Reduce animations for sensitive users or older devices.">?</span></span>
                                <div class="toggle-switch">
                                    <input type="checkbox" id="reduceMotionCheck" onchange="toggleReduceMotion()">
                                    <label for="reduceMotionCheck" class="toggle-switch-label"></label>
                                </div>
                            </label>
                        </div>
                        <div class="setting-group">
                            <label class="setting-label">Parent & Teacher</label>
                            <div class="toggle-group">
                                <button class="toggle-btn" id="openParent" onclick="openParentDashboardViaSettings()"
                                    aria-label="Open parent dashboard">Open Parent Dashboard</button>
                            </div>
                        </div>
                    </details>

                    <button class="close-settings" onclick="closeSettings()">Done</button>
                </div>

                <!-- About Section -->
                <div class="about-section">
                    <div class="about-divider"></div>
                    <div class="about-content">
                        <div class="about-title">ðŸ’ About This Game</div>
                        <div class="about-text">
                            This game was created by <strong>Jeffrey Emanuel</strong> for his own children and
                            is made freely available to all families.
                        </div>
                        <div class="about-text">
                            Every child should have free access to quality educational tools without annoying ads and mind-numbing animations!
                        </div>
                        <a href="https://github.com/Dicklesworthstone/letter_learning_game" target="_blank"
                            class="github-link">
                            <svg class="github-icon" width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                                <path
                                    d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z" />
                            </svg>
                            <span>View Source Code on GitHub</span>
                        </a>
                        <div class="about-footer">
                            ðŸ¥³ Reading is FUNdamental! ðŸ¥³
                            <div style="margin-top:8px;">
                                <form action="https://www.paypal.com/donate" method="post" target="_top" style="display:inline-block;">
                                    <input type="hidden" name="business" value="B9JY8A3YAK84J" />
                                    <input type="hidden" name="amount" value="5" />
                                    <input type="hidden" name="no_recurring" value="1" />
                                    <input type="hidden" name="item_name" value="If you found this app helpful for your child and want to support this work, here is a donation button." />
                                    <input type="hidden" name="currency_code" value="USD" />
                                    <input type="image" src="https://www.paypalobjects.com/en_US/i/btn/btn_donate_LG.gif" name="submit" title="Donate (PayPal)" alt="Donate with PayPal button" style="width:128px; height:auto; opacity:0.8; filter:saturate(0.7);" />
                                    <img alt="" src="https://www.paypal.com/en_US/i/scr/pixel.gif" width="1" height="1" style="display:none;" />
                                </form>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Achievement Modal -->
        <div class="achievement-modal" id="achievementModal">
            <div class="achievement-content">
                <div class="achievement-header">
                    <div class="achievement-title">ðŸ† Your Achievements</div>
                    <div class="achievement-subtitle">Keep playing to unlock them all!</div>
                </div>

                <div class="achievement-stats">
                    <div style="display:flex; align-items:center; justify-content:center; padding: 4px 0 16px;">
                        <canvas id="masteryPie" width="200" height="200" aria-label="Letters mastered progress" style="display:block; width:180px; height:180px;"></canvas>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Total Stars Earned:</span>
                        <span class="stat-value" id="totalStarsEarned">0</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Letters Mastered:</span>
                        <span class="stat-value" id="lettersMastered">0/26</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Best Streak:</span>
                        <span class="stat-value" id="bestStreak">0</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Play Time:</span>
                        <span class="stat-value" id="totalPlayTime">0 min</span>
                    </div>
                </div>

                <div class="badges-grid" id="badgesGrid">
                    <!-- Badges will be dynamically added here -->
                </div>

                <button class="close-achievements" onclick="closeAchievements()"
                    aria-label="Close achievements">Continue Playing</button>
            </div>
        </div>

        <!-- Achievement Notification -->
        <div class="achievement-notification" id="achievementNotification">
            <div class="achievement-notification-icon" id="notificationIcon">ðŸ†</div>
            <div class="achievement-notification-content">
                <div class="achievement-notification-title" id="notificationTitle">Achievement Unlocked!</div>
                <div class="achievement-notification-text" id="notificationText">You've earned a new badge!</div>
            </div>
        </div>

        <!-- Player Setup Modal -->
        <div class="player-modal" id="playerModal">
            <div class="player-modal-content">
                <div class="player-modal-title">Create New Player</div>

                <div class="avatar-grid" id="avatarGrid">
                    <div class="avatar-option" data-avatar="ðŸ¦">ðŸ¦</div>
                    <div class="avatar-option" data-avatar="ðŸ»">ðŸ»</div>
                    <div class="avatar-option" data-avatar="ðŸ¼">ðŸ¼</div>
                    <div class="avatar-option" data-avatar="ðŸ¦Š">ðŸ¦Š</div>
                    <div class="avatar-option" data-avatar="ðŸ¸">ðŸ¸</div>
                    <div class="avatar-option" data-avatar="ðŸ¦„">ðŸ¦„</div>
                    <div class="avatar-option" data-avatar="ðŸ™">ðŸ™</div>
                    <div class="avatar-option" data-avatar="ðŸ¦‹">ðŸ¦‹</div>
                    <div class="avatar-option" data-avatar="ðŸŒŸ">ðŸŒŸ</div>
                    <div class="avatar-option" data-avatar="ðŸš€">ðŸš€</div>
                </div>

                <input type="text" class="player-name-input" id="playerNameInput" placeholder="Enter player name"
                    maxlength="15">

                <div class="player-modal-buttons">
                    <button class="player-modal-btn player-modal-cancel" onclick="closePlayerModal()">Cancel</button>
                    <button class="player-modal-btn player-modal-save" onclick="saveNewPlayer()">Create Player</button>
                </div>
            </div>
        </div>

        <!-- Parent Dashboard -->
        <div class="parent-dashboard" id="parentDashboard">
            <div class="dashboard-header">
                <div class="dashboard-title">ðŸ“Š Parent Dashboard</div>
                <div class="dashboard-subtitle">Track progress and get insights for all players</div>
                <button class="dashboard-close" onclick="closeParentDashboard()" aria-label="Close dashboard">âœ•</button>
            </div>

            <div class="dashboard-content">
                <!-- Player Progress Section -->
                <div class="dashboard-section">
                    <div class="dashboard-section-title">
                        <span>ðŸ‘¥</span>
                        <span>Player Progress</span>
                    </div>
                    <div class="player-stats-grid" id="playerStatsGrid">
                        <!-- Player stats will be added here -->
                    </div>
                </div>

                <!-- Letter Performance Heatmap -->
                <div class="dashboard-section">
                    <div class="dashboard-section-title">
                        <span>ðŸ”¤</span>
                        <span>Letter Performance Map</span>
                    </div>
                    <div class="letter-heatmap" id="letterHeatmap">
                        <!-- Heatmap cells will be added here -->
                    </div>
                    <div class="heatmap-legend">
                        <span>Needs Practice</span>
                        <div class="legend-gradient"></div>
                        <span>Mastered</span>
                    </div>
                </div>

                <!-- Insights & Recommendations -->
                <div class="dashboard-section">
                    <div class="dashboard-section-title">
                        <span>ðŸ’¡</span>
                        <span>Insights & Patterns</span>
                    </div>
                    <ul class="insights-list" id="insightsList">
                        <!-- Insights will be added here -->
                    </ul>
                </div>

                <!-- Activity Recommendations -->
                <div class="dashboard-section">
                    <div class="dashboard-section-title">
                        <span>ðŸŽ¯</span>
                        <span>Recommended Activities</span>
                    </div>
                    <div id="recommendationsList">
                        <!-- Recommendations will be added here -->
                    </div>
                </div>

                <!-- Data Management -->
                <div class="dashboard-section">
                    <div class="dashboard-section-title">
                        <span>ðŸ§¹</span>
                        <span>Data Management</span>
                    </div>
                    <div style="display:flex; gap:12px; flex-wrap: wrap;">
                        <button class="toggle-btn" onclick="resetAllStatistics()" aria-label="Reset all statistics">Reset All Statistics</button>
                        <button class="toggle-btn" onclick="resetCurrentPlayerStatistics()" aria-label="Reset current player statistics">Reset Current Player</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Round Completion Modal -->
        <div class="round-modal" id="roundModal">
            <div class="round-content">
                <div class="round-title">ðŸŽ‰ Round <span id="completedRound">1</span> Complete! ðŸŽ‰</div>
                <div class="round-stats">
                    <div class="round-stat">
                        <span class="round-stat-label">â±ï¸ Avg Time:</span>
                        <span class="round-stat-value" id="avgTime">0</span>s
                    </div>
                    <div class="round-stat">
                        <span class="round-stat-label">ðŸŽ¯ Accuracy:</span>
                        <span class="round-stat-value" id="accuracy">0</span>%
                    </div>
                    <div class="round-stat">
                        <span class="round-stat-label">â­ Points:</span>
                        <span class="round-stat-value" id="scoreGained">0</span>
                    </div>
                </div>
                <div class="problem-letters">
                    <div class="problem-letters-title">Letters to practice:</div>
                    <div class="problem-letters-list" id="problemLettersList">None - Perfect! ðŸŒŸ</div>
                </div>
                <button class="continue-btn" onclick="startNextRound()" aria-label="Continue to the next round">Continue
                    to Round <span id="nextRoundNum">2</span> â†’</button>
            </div>
        </div>
    </div>

    <script>
        // Achievement Definitions
        const ACHIEVEMENTS = [
            { id: 'first_letter', name: 'First Steps', icon: 'ðŸŒ±', description: 'Get your first letter correct', requirement: 1, type: 'correct' },
            { id: 'streak_5', name: 'Hot Streak', icon: 'ðŸ”¥', description: '5 correct in a row', requirement: 5, type: 'streak' },
            { id: 'streak_10', name: 'On Fire!', icon: 'ðŸ’¥', description: '10 correct in a row', requirement: 10, type: 'streak' },
            { id: 'speed_demon', name: 'Speed Demon', icon: 'âš¡', description: '10 answers under 2 seconds', requirement: 10, type: 'speed' },
            { id: 'perfect_round', name: 'Perfect Round', icon: 'â­', description: 'Complete a round with no mistakes', requirement: 1, type: 'perfect' },
            { id: 'letter_master', name: 'Letter Master', icon: 'ðŸŽ“', description: 'Master all 26 letters', requirement: 26, type: 'mastery' },
            { id: 'score_100', name: 'Century Club', icon: 'ðŸ’¯', description: 'Reach 100 points', requirement: 100, type: 'score' },
            { id: 'score_500', name: 'High Scorer', icon: 'ðŸ†', description: 'Reach 500 points', requirement: 500, type: 'score' },
            { id: 'score_1000', name: 'Champion', icon: 'ðŸ‘‘', description: 'Reach 1000 points', requirement: 1000, type: 'score' },
            { id: 'play_time_10', name: 'Dedicated', icon: 'â°', description: 'Play for 10 minutes', requirement: 10, type: 'time' },
            { id: 'play_time_30', name: 'Committed', icon: 'ðŸ“š', description: 'Play for 30 minutes', requirement: 30, type: 'time' },
            { id: 'round_5', name: 'Persistent', icon: 'ðŸŽ¯', description: 'Complete 5 rounds', requirement: 5, type: 'rounds' }
        ];

        // Gesture Recognition Data for Tracing Practice (normalized 100x100 grid)
        const LETTER_CHECKPOINTS = {
            'a': {
                strokes: [
                    [{ x: 75, y: 55 }, { x: 50, y: 35 }, { x: 25, y: 55 }, { x: 50, y: 75 }, { x: 75, y: 55 }],
                    [{ x: 75, y: 35 }, { x: 75, y: 85 }]
                ], tolerance: 30, feedback: { incomplete: "Make sure you draw the round part and the straight line for 'a'!", wrong: "Remember, 'a' has a circle with a tail on the side." }
            },
            'b': {
                strokes: [
                    [{ x: 25, y: 10 }, { x: 25, y: 85 }],
                    [{ x: 25, y: 50 }, { x: 50, y: 35 }, { x: 75, y: 50 }, { x: 50, y: 75 }, { x: 25, y: 50 }]
                ], tolerance: 28, feedback: { incomplete: "Don't forget the circle at the bottom of the 'b'!", wrong: "Try making a tall line down, then a circle at the bottom." }
            },
            'c': { strokes: [[{ x: 80, y: 30 }, { x: 40, y: 20 }, { x: 20, y: 50 }, { x: 40, y: 80 }, { x: 80, y: 70 }]], tolerance: 35, feedback: { incomplete: "Keep going! Make a nice big curve for the 'c'.", wrong: "That's not quite a 'c'. Try starting at the top and curving around." } },
            'd': {
                strokes: [
                    [{ x: 75, y: 10 }, { x: 75, y: 85 }],
                    [{ x: 75, y: 50 }, { x: 50, y: 35 }, { x: 25, y: 50 }, { x: 50, y: 75 }, { x: 75, y: 50 }]
                ], tolerance: 28, feedback: { incomplete: "Don't forget the circle on the left of the tall line!", wrong: "For 'd', make a circle first, then a tall line on the right." }
            },
            'e': { strokes: [[{ x: 20, y: 55 }, { x: 80, y: 55 }, { x: 75, y: 30 }, { x: 35, y: 25 }, { x: 25, y: 45 }, { x: 40, y: 75 }, { x: 75, y: 70 }]], tolerance: 35, feedback: { incomplete: "Keep curving all the way around to finish the 'e'!", wrong: "For 'e', draw a line across, then loop up and around." } },
            'f': {
                strokes: [
                    [{ x: 70, y: 20 }, { x: 50, y: 10 }, { x: 50, y: 90 }],
                    [{ x: 25, y: 45 }, { x: 75, y: 45 }]
                ], tolerance: 28, feedback: { incomplete: "The letter 'f' needs a line across the middle.", wrong: "Try a candy-cane shape, then a line across the middle." }
            },
            'g': {
                strokes: [
                    [{ x: 75, y: 55 }, { x: 50, y: 35 }, { x: 25, y: 55 }, { x: 50, y: 75 }, { x: 75, y: 55 }],
                    [{ x: 75, y: 55 }, { x: 75, y: 90 }, { x: 40, y: 90 }]
                ], tolerance: 30, feedback: { incomplete: "Don't forget the hook at the bottom of the 'g'!", wrong: "For 'g', make a circle, then a tail that hooks underneath." }
            },
            'h': {
                strokes: [
                    [{ x: 25, y: 10 }, { x: 25, y: 90 }],
                    [{ x: 25, y: 50 }, { x: 50, y: 40 }, { x: 75, y: 50 }, { x: 75, y: 90 }]
                ], tolerance: 28, feedback: { incomplete: "Now add the hump to the tall line to make an 'h'!", wrong: "Draw a tall line down, then add a hump in the middle." }
            },
            'i': { strokes: [[{ x: 50, y: 40 }, { x: 50, y: 80 }], [{ x: 50, y: 20 }]], tolerance: 25, feedback: { incomplete: "You're so close! Just add the dot on top.", wrong: "For 'i', it's just a little line with a dot on top." } },
            'j': { strokes: [[{ x: 60, y: 40 }, { x: 60, y: 90 }, { x: 30, y: 90 }], [{ x: 60, y: 20 }]], tolerance: 28, feedback: { incomplete: "Great hook! Now just add the dot on top for 'j'.", wrong: "For 'j', draw a hook shape, then put a dot on top." } },
            'k': {
                strokes: [
                    [{ x: 25, y: 10 }, { x: 25, y: 90 }],
                    [{ x: 75, y: 45 }, { x: 25, y: 65 }],
                    [{ x: 25, y: 65 }, { x: 75, y: 90 }]
                ], tolerance: 30, feedback: { incomplete: "A 'k' needs a tall line and two small slanted lines.", wrong: "Draw a tall line, then a 'less than' sign (<) next to it." }
            },
            'l': { strokes: [[{ x: 50, y: 10 }, { x: 50, y: 90 }]], tolerance: 25, feedback: { incomplete: "Just one tall, straight line down for 'l'!", wrong: "Try making one simple line from top to bottom." } },
            'm': { strokes: [[{ x: 20, y: 40 }, { x: 20, y: 90 }, { x: 20, y: 50 }, { x: 35, y: 35 }, { x: 50, y: 50 }, { x: 50, y: 90 }, { x: 50, y: 50 }, { x: 65, y: 35 }, { x: 80, y: 50 }, { x: 80, y: 90 }]], tolerance: 35, feedback: { incomplete: "Keep going, an 'm' needs two humps!", wrong: "For 'm', draw a line down, then bounce up and over twice." } },
            'n': { strokes: [[{ x: 25, y: 40 }, { x: 25, y: 90 }, { x: 25, y: 50 }, { x: 40, y: 35 }, { x: 65, y: 40 }, { x: 75, y: 50 }, { x: 75, y: 90 }]], tolerance: 30, feedback: { incomplete: "Almost! An 'n' just needs one hump.", wrong: "Draw a line down, then bounce up and over once for 'n'." } },
            'o': { strokes: [[{ x: 75, y: 50 }, { x: 50, y: 25 }, { x: 25, y: 50 }, { x: 50, y: 75 }, { x: 75, y: 50 }]], tolerance: 30, feedback: { incomplete: "Keep going all the way around to finish the 'o'!", wrong: "Try to draw a simple, round circle for the 'o'." } },
            'p': {
                strokes: [
                    [{ x: 25, y: 40 }, { x: 25, y: 95 }],
                    [{ x: 25, y: 40 }, { x: 50, y: 25 }, { x: 75, y: 40 }, { x: 50, y: 65 }, { x: 25, y: 40 }]
                ], tolerance: 28, feedback: { incomplete: "Now add the circle at the top to finish the 'p'!", wrong: "For 'p', draw a line that goes down, then add a circle at the top." }
            },
            'q': {
                strokes: [
                    [{ x: 75, y: 40 }, { x: 50, y: 25 }, { x: 25, y: 40 }, { x: 50, y: 65 }, { x: 75, y: 40 }],
                    [{ x: 75, y: 40 }, { x: 75, y: 95 }]
                ], tolerance: 28, feedback: { incomplete: "The circle looks good! Now add the line going down.", wrong: "A 'q' is a circle with a line that goes straight down on the right." }
            },
            'r': { strokes: [[{ x: 25, y: 40 }, { x: 25, y: 90 }, { x: 25, y: 50 }, { x: 40, y: 35 }, { x: 70, y: 40 }]], tolerance: 30, feedback: { incomplete: "Just a little hook at the top is needed for 'r'.", wrong: "For 'r', draw a line down, then a small hook at the top." } },
            's': { strokes: [[{ x: 75, y: 25 }, { x: 25, y: 40 }, { x: 50, y: 60 }, { x: 75, y: 75 }, { x: 25, y: 90 }]], tolerance: 35, feedback: { incomplete: "Keep curving! An 's' is like a little snake.", wrong: "Try making a curvy, snake-like line for the 's'." } },
            't': {
                strokes: [
                    [{ x: 50, y: 20 }, { x: 50, y: 90 }],
                    [{ x: 25, y: 45 }, { x: 75, y: 45 }]
                ], tolerance: 25, feedback: { incomplete: "Great line! Now cross the 't' in the middle.", wrong: "For 't', draw a line down, then a line across the middle." }
            },
            'u': { strokes: [[{ x: 25, y: 40 }, { x: 25, y: 80 }, { x: 50, y: 90 }, { x: 75, y: 80 }, { x: 75, y: 40 }]], tolerance: 30, feedback: { incomplete: "Make sure you curve at the bottom like a smile!", wrong: "A 'u' is like a cup or a smile shape." } },
            'v': { strokes: [[{ x: 15, y: 20 }, { x: 50, y: 90 }, { x: 85, y: 20 }]], tolerance: 30, feedback: { incomplete: "A 'v' needs two straight, slanted lines.", wrong: "For 'v', draw a slanted line down, and another one up!" } },
            'w': { strokes: [[{ x: 15, y: 20 }, { x: 35, y: 90 }, { x: 50, y: 50 }, { x: 65, y: 90 }, { x: 85, y: 20 }]], tolerance: 35, feedback: { incomplete: "Keep going! A 'w' has two points at the bottom.", wrong: "A 'w' is like two 'v' shapes right next to each other." } },
            'x': {
                strokes: [
                    [{ x: 20, y: 20 }, { x: 80, y: 80 }],
                    [{ x: 80, y: 20 }, { x: 20, y: 80 }]
                ], tolerance: 30, feedback: { incomplete: "An 'x' needs two crossing lines.", wrong: "For 'x', just draw two lines that cross in the middle." }
            },
            'y': {
                strokes: [
                    [{ x: 20, y: 20 }, { x: 50, y: 50 }],
                    [{ x: 80, y: 20 }, { x: 20, y: 80 }]
                ], tolerance: 30, feedback: { incomplete: "The letter 'y' needs a short line and a long line.", wrong: "Draw a small slanted line, then a long one that crosses it." }
            },
            'z': { strokes: [[{ x: 20, y: 20 }, { x: 80, y: 20 }, { x: 20, y: 80 }, { x: 80, y: 80 }]], tolerance: 30, feedback: { incomplete: "A 'z' needs a line on top, a slanted line, and a line on the bottom.", wrong: "For 'z', draw 'zig-zag-zig'!" } },

            'A': {
                strokes: [
                    [{ x: 50, y: 10 }, { x: 20, y: 90 }],
                    [{ x: 50, y: 10 }, { x: 80, y: 90 }],
                    [{ x: 35, y: 60 }, { x: 65, y: 60 }]
                ], tolerance: 25, feedback: { incomplete: "The letter 'A' needs two slanted lines and one across the middle.", wrong: "Remember the pointy top of the 'A', like a mountain with a bridge." }
            },
            'B': {
                strokes: [
                    [{ x: 20, y: 10 }, { x: 20, y: 90 }],
                    [{ x: 20, y: 10 }, { x: 60, y: 20 }, { x: 60, y: 40 }, { x: 20, y: 50 }],
                    [{ x: 20, y: 50 }, { x: 70, y: 60 }, { x: 70, y: 80 }, { x: 20, y: 90 }]
                ], tolerance: 30, feedback: { incomplete: "A 'B' needs a straight line and two round bumps on the side.", wrong: "Draw a line down, then add a small bump on top and a big bump on the bottom." }
            },
            'C': { strokes: [[{ x: 80, y: 20 }, { x: 40, y: 10 }, { x: 10, y: 50 }, { x: 40, y: 90 }, { x: 80, y: 80 }]], tolerance: 35, feedback: { incomplete: "Keep going! Make a nice big curve for the 'C'.", wrong: "That's not quite a 'C'. Try starting at the top and curving around." } },
            'D': {
                strokes: [
                    [{ x: 20, y: 10 }, { x: 20, y: 90 }],
                    [{ x: 20, y: 10 }, { x: 80, y: 30 }, { x: 80, y: 70 }, { x: 20, y: 90 }]
                ], tolerance: 30, feedback: { incomplete: "Now draw the big curve to finish the 'D'.", wrong: "For 'D', draw a straight line down, then a big curve from top to bottom." }
            },
            'E': {
                strokes: [
                    [{ x: 20, y: 10 }, { x: 20, y: 90 }],
                    [{ x: 20, y: 10 }, { x: 80, y: 10 }],
                    [{ x: 20, y: 50 }, { x: 70, y: 50 }],
                    [{ x: 20, y: 90 }, { x: 80, y: 90 }]
                ], tolerance: 25, feedback: { incomplete: "An 'E' needs three lines going to the right.", wrong: "Draw a line down, then add a line at the top, middle, and bottom." }
            },
            'F': {
                strokes: [
                    [{ x: 20, y: 10 }, { x: 20, y: 90 }],
                    [{ x: 20, y: 10 }, { x: 80, y: 10 }],
                    [{ x: 20, y: 50 }, { x: 70, y: 50 }]
                ], tolerance: 25, feedback: { incomplete: "An 'F' is like an 'E' but without the bottom line.", wrong: "Draw a line down, then add a line at the top and in the middle." }
            },
            'G': {
                strokes: [
                    [{ x: 80, y: 20 }, { x: 40, y: 10 }, { x: 10, y: 50 }, { x: 40, y: 90 }, { x: 80, y: 80 }, { x: 80, y: 50 }],
                    [{ x: 50, y: 50 }, { x: 80, y: 50 }]
                ], tolerance: 35, feedback: { incomplete: "A 'G' is a big curve with a little line inside.", wrong: "Draw a big 'C', then give it a small line pointing inwards." }
            },
            'H': {
                strokes: [
                    [{ x: 20, y: 10 }, { x: 20, y: 90 }],
                    [{ x: 80, y: 10 }, { x: 80, y: 90 }],
                    [{ x: 20, y: 50 }, { x: 80, y: 50 }]
                ], tolerance: 25, feedback: { incomplete: "An 'H' needs two tall lines and one across the middle.", wrong: "Draw two straight lines, then connect them in the middle." }
            },
            'I': {
                strokes: [
                    [{ x: 50, y: 10 }, { x: 50, y: 90 }],
                    [{ x: 30, y: 10 }, { x: 70, y: 10 }],
                    [{ x: 30, y: 90 }, { x: 70, y: 90 }]
                ], tolerance: 25, feedback: { incomplete: "An 'I' is a tall line with a hat and shoes.", wrong: "For 'I', draw a tall line with a small line across the top and bottom." }
            },
            'J': { strokes: [[{ x: 80, y: 10 }, { x: 80, y: 70 }, { x: 60, y: 90 }, { x: 20, y: 80 }]], tolerance: 30, feedback: { incomplete: "A 'J' is a line down with a hook at the bottom.", wrong: "Draw a line down, and give it a hook at the bottom, like a fish hook." } },
            'K': {
                strokes: [
                    [{ x: 20, y: 10 }, { x: 20, y: 90 }],
                    [{ x: 80, y: 10 }, { x: 20, y: 50 }],
                    [{ x: 20, y: 50 }, { x: 80, y: 90 }]
                ], tolerance: 30, feedback: { incomplete: "A 'K' needs a tall line and two slanted 'legs'.", wrong: "Draw a tall line, then have two slanted lines kick out from the middle." }
            },
            'L': { strokes: [[{ x: 20, y: 10 }, { x: 20, y: 90 }, { x: 80, y: 90 }]], tolerance: 25, feedback: { incomplete: "An 'L' needs a line down, and then a line across the bottom.", wrong: "Try drawing a straight line down, then a straight line to the right." } },
            'M': { strokes: [[{ x: 10, y: 90 }, { x: 10, y: 10 }, { x: 50, y: 70 }, { x: 90, y: 10 }, { x: 90, y: 90 }]], tolerance: 35, feedback: { incomplete: "An 'M' has four straight lines. Down, down, up, down!", wrong: "Think of jagged mountains for 'M': down, slant down, slant up, then straight down." } },
            'N': { strokes: [[{ x: 20, y: 90 }, { x: 20, y: 10 }, { x: 80, y: 90 }, { x: 80, y: 10 }]], tolerance: 30, feedback: { incomplete: "An 'N' has three straight lines.", wrong: "For 'N', draw a line down, then a long slant down, then a line straight up." } },
            'O': { strokes: [[{ x: 80, y: 50 }, { x: 50, y: 10 }, { x: 20, y: 50 }, { x: 50, y: 90 }, { x: 80, y: 50 }]], tolerance: 30, feedback: { incomplete: "Keep going all the way around to finish the 'O'!", wrong: "Try to draw a simple, round circle or oval for the 'O'." } },
            'P': {
                strokes: [
                    [{ x: 20, y: 10 }, { x: 20, y: 90 }],
                    [{ x: 20, y: 10 }, { x: 70, y: 20 }, { x: 70, y: 40 }, { x: 20, y: 50 }]
                ], tolerance: 30, feedback: { incomplete: "Now add the bump at the top to finish the 'P'!", wrong: "Draw a line down, then add a bump on the top half." }
            },
            'Q': {
                strokes: [
                    [{ x: 80, y: 50 }, { x: 50, y: 10 }, { x: 20, y: 50 }, { x: 50, y: 90 }, { x: 80, y: 50 }],
                    [{ x: 60, y: 70 }, { x: 90, y: 90 }]
                ], tolerance: 30, feedback: { incomplete: "Great circle! Now add the little tail for the 'Q'.", wrong: "For 'Q', draw a big 'O', then give it a small slanted tail at the bottom." }
            },
            'R': {
                strokes: [
                    [{ x: 20, y: 10 }, { x: 20, y: 90 }],
                    [{ x: 20, y: 10 }, { x: 70, y: 20 }, { x: 70, y: 40 }, { x: 20, y: 50 }],
                    [{ x: 40, y: 50 }, { x: 80, y: 90 }]
                ], tolerance: 30, feedback: { incomplete: "An 'R' has a bump and a leg!", wrong: "Draw a 'P', then give it a slanted leg to stand on." }
            },
            'S': { strokes: [[{ x: 80, y: 20 }, { x: 20, y: 40 }, { x: 80, y: 60 }, { x: 20, y: 80 }]], tolerance: 35, feedback: { incomplete: "Keep curving! An 'S' is like a big snake.", wrong: "Try making a curvy, snake-like line for the 'S'." } },
            'T': {
                strokes: [
                    [{ x: 10, y: 10 }, { x: 90, y: 10 }],
                    [{ x: 50, y: 10 }, { x: 50, y: 90 }]
                ], tolerance: 25, feedback: { incomplete: "Now add the tall line down from the middle of the 'T'.", wrong: "Draw a line across the top, then a line down from the middle." }
            },
            'U': { strokes: [[{ x: 20, y: 10 }, { x: 20, y: 70 }, { x: 50, y: 90 }, { x: 80, y: 70 }, { x: 80, y: 10 }]], tolerance: 30, feedback: { incomplete: "Make sure you curve at the bottom like a big smile!", wrong: "A 'U' is like a big cup or a smile shape." } },
            'V': { strokes: [[{ x: 10, y: 10 }, { x: 50, y: 90 }, { x: 90, y: 10 }]], tolerance: 30, feedback: { incomplete: "A 'V' needs two straight, slanted lines.", wrong: "For 'V', draw a slanted line down, and another one up!" } },
            'W': { strokes: [[{ x: 10, y: 10 }, { x: 30, y: 90 }, { x: 50, y: 30 }, { x: 70, y: 90 }, { x: 90, y: 10 }]], tolerance: 35, feedback: { incomplete: "Keep going! A 'W' has four straight lines.", wrong: "A 'W' is like two 'V' shapes right next to each other." } },
            'X': {
                strokes: [
                    [{ x: 10, y: 10 }, { x: 90, y: 90 }],
                    [{ x: 90, y: 10 }, { x: 10, y: 90 }]
                ], tolerance: 30, feedback: { incomplete: "An 'X' needs two crossing lines. 'X' marks the spot!", wrong: "For 'X', just draw two big lines that cross in the middle." }
            },
            'Y': {
                strokes: [
                    [{ x: 10, y: 10 }, { x: 50, y: 50 }],
                    [{ x: 90, y: 10 }, { x: 50, y: 50 }],
                    [{ x: 50, y: 50 }, { x: 50, y: 90 }]
                ], tolerance: 30, feedback: { incomplete: "A 'Y' needs the 'V' shape at the top and a line down.", wrong: "Draw a small 'V' at the top, then a straight line down from its point." }
            },
            'Z': { strokes: [[{ x: 10, y: 10 }, { x: 90, y: 10 }, { x: 10, y: 90 }, { x: 90, y: 90 }]], tolerance: 30, feedback: { incomplete: "A 'Z' needs a line on top, a slanted line, and a line on the bottom.", wrong: "For 'Z', draw 'zig-zag-zig'!" } }
        };

        // Initialize background bubbles
        function createBubbles() {
            for (let i = 0; i < 10; i++) {
                const bubble = document.createElement('div');
                bubble.className = 'bubble';
                bubble.style.width = Math.random() * 100 + 50 + 'px';
                bubble.style.height = bubble.style.width;
                bubble.style.left = Math.random() * 100 + '%';
                bubble.style.top = Math.random() * 100 + '%';
                bubble.style.animationDelay = Math.random() * 20 + 's';
                bubble.style.animationDuration = (Math.random() * 10 + 15) + 's';
                document.body.appendChild(bubble);
            }
        }
        // Background bubbles disabled for calmer experience

        // Game state
        let currentMode = 'identify';
        let currentLetter = '';
        let currentCase = 'mixed';
        let score = 0;
        let correctAnswers = 0;
        let wrongAnswers = 0;
        let totalQuestions = 0;
        let currentRound = 1;
        let roundCorrect = 0;
        let roundWrong = 0;
        let scoreAtRoundStart = 0;
        let timerEnabled = true;
        let soundEnabled = true;
        let timerDuration = 10;
        let currentTimer = null;
        let lastDrawTime = 0;
        let timerBarInterval = null;
        let questionStartTime = 0;
        let drawQuestionStartTime = 0;
        let responseTimes = [];
        let letterErrors = {};
        let problemLetters = [];
        let waitingForPhonics = false;
        let phonicsEnabled = true; // default on, can be toggled in settings
        let phonicsTimer = null;
        let speakPromptTimeout = null;
        let speakLetterTimeout = null;
        let isProcessing = false;
        let isDrawing = false;
        let ctx = null;
        let voiceRecordingEnabled = false; // Hidden by default
        let phonicsRepeatCount = 0; // counts fallback repeats per phonics step
        let phonicsEchoCleanup = null; // cleanup function for active echo step
        let drawingPoints = [];
        let recentLetters = [];
        let isAnswering = false; // lock input during answer animations
        let previouslyFocusedElement = null; // for modal focus management
        const QUESTIONS_PER_ROUND = 15; // shorter, kid-friendly rounds
        let phonicsPhaseTimeout = null; // track phonics phase start timeout
        // Idle hint state for tracing
        let idleHintTimeout = null;
        let idleHintInterval = null;
        let hintFadeOpacity = 0; // 0 â†’ 0.12
        // Draw-mode advancement guards to avoid duplicate next prompts
        let drawAdvanceTimeout = null;
        let drawAdvanceLocked = false;
        let drawHasAdvanced = false;

        function advanceToNextDrawLetterOnce() {
            if (drawHasAdvanced) return;
            drawHasAdvanced = true;
            if (drawAdvanceTimeout) { try { clearTimeout(drawAdvanceTimeout); } catch (e) {} drawAdvanceTimeout = null; }
            const modal = document.getElementById('roundModal');
            const isModalVisible = modal ? window.getComputedStyle(modal).display !== 'none' : false;
            if (!isModalVisible) {
                startDrawGame();
            }
        }
        let hintWasShown = false; // used to reduce score when hint helped
        let hasStartedTrace = false; // first stroke gate to cancel hint

        // Adaptive Difficulty State
        let letterPerformance = {};
        let correctStreak = 0;  // Track consecutive correct answers
        let bestStreak = 0;
        let speedAnswers = 0;
        let sessionStartTime = Date.now();
        let totalPlayTime = 0;
        let lettersMastered = new Set();
        let roundsCompleted = 0;
        let difficultyLevel = 1; // 1-5 scale
        let adaptivePool = [];

        // Shape-similarity tiers for targeted practice after errors
        const shapeSimilarityGroups = {
            curvedBowls: ['b', 'd', 'p', 'q'],
            straightSticks: ['i', 'l', 't'],
            humps: ['m', 'n', 'r', 'h'],
            diagonals: ['v', 'w', 'y']
        };
        const letterToShapeGroupLower = {};
        Object.entries(shapeSimilarityGroups).forEach(([groupKey, letters]) => {
            letters.forEach(l => { letterToShapeGroupLower[l] = groupKey; });
        });
        // Persist last computed weights (per concrete letter, including case)
        let latestLetterWeights = {};
        // Temporary bias window following an error to reinforce similar-shape distinctions
        let shapeBiasTargetLower = null;
        let shapeBiasRoundsRemaining = 0;

        // Achievement State
        let unlockedAchievements = new Set();
        let achievementProgress = {};

        // Multiplayer State
        let players = [];
        let currentPlayerIndex = 0;
        let currentPlayer = null;
        let multiplayerMode = false;
        let selectedAvatar = 'ðŸ¦';

        // Letter Formation Data
        const letterFormations = {
            'a': [
                { path: 'M 20 40 Q 20 20, 40 20 Q 60 20, 60 40 L 60 60', strokes: 1 },
                { path: 'M 60 40 L 60 20', strokes: 2 }
            ],
            'b': [
                { path: 'M 20 10 L 20 60', strokes: 1 },
                { path: 'M 20 35 Q 45 35, 45 45 Q 45 60, 20 60', strokes: 2 }
            ],
            'c': [
                { path: 'M 50 30 Q 30 20, 20 40 Q 30 60, 50 50', strokes: 1 }
            ],
            'd': [
                { path: 'M 50 35 Q 25 35, 25 45 Q 25 60, 50 60', strokes: 1 },
                { path: 'M 50 10 L 50 60', strokes: 2 }
            ],
            'e': [
                { path: 'M 20 40 L 50 40 Q 50 20, 30 20 Q 20 20, 20 40 Q 20 60, 40 60', strokes: 1 }
            ]
            // Add more letters as needed
        };

        // Parent Dashboard State
        let dashboardTimer = null;

        // Visual Learning Themes
        let currentTheme = 'classic';
        const letterAssociations = {
            'a': { icon: 'ðŸŽ', word: 'Apple' },
            'b': { icon: 'ðŸ»', word: 'Bear' },
            'c': { icon: 'ðŸ±', word: 'Cat' },
            'd': { icon: 'ðŸ¶', word: 'Dog' },
            'e': { icon: 'ðŸ˜', word: 'Elephant' },
            'f': { icon: 'ðŸŸ', word: 'Fish' },
            'g': { icon: 'ðŸ‡', word: 'Grapes' },
            'h': { icon: 'ðŸ ', word: 'House' },
            'i': { icon: 'ðŸ¨', word: 'Ice cream' },
            'j': { icon: 'ðŸ§ƒ', word: 'Juice' },
            'k': { icon: 'ðŸ¨', word: 'Koala' },
            'l': { icon: 'ðŸ¦', word: 'Lion' },
            'm': { icon: 'ðŸŒ™', word: 'Moon' },
            'n': { icon: 'ðŸ¥œ', word: 'Nut' },
            'o': { icon: 'ðŸ¦‰', word: 'Owl' },
            'p': { icon: 'ðŸ•', word: 'Pizza' },
            'q': { icon: 'ðŸ‘‘', word: 'Queen' },
            'r': { icon: 'ðŸŒˆ', word: 'Rainbow' },
            's': { icon: 'â˜€ï¸', word: 'Sun' },
            't': { icon: 'ðŸŒ³', word: 'Tree' },
            'u': { icon: 'â˜‚ï¸', word: 'Umbrella' },
            'v': { icon: 'ðŸŽ»', word: 'Violin' },
            'w': { icon: 'ðŸŽ‰', word: 'Watermelon' },
            'x': { icon: 'ðŸŽ¸', word: 'Xylophone' },
            'y': { icon: 'ðŸ§¡', word: 'Yo-yo' },
            'z': { icon: 'ðŸ¦“', word: 'Zebra' }
        };

        // Child-friendly word examples for each letter (used for brief, non-disruptive overlays)
        const letterWords = {
            'a': ['ant', 'apple', 'arm'],
            'b': ['ball', 'bear', 'bed'],
            'c': ['cat', 'car', 'cup'],
            'd': ['dog', 'duck', 'dad'],
            'e': ['egg', 'elephant', 'ear'],
            'f': ['fish', 'frog', 'fan'],
            'g': ['goat', 'game', 'girl'],
            'h': ['hat', 'hand', 'house'],
            'i': ['ice', 'igloo', 'insect'],
            'j': ['jam', 'jet', 'jelly'],
            'k': ['kite', 'key', 'kid'],
            'l': ['lion', 'leaf', 'leg'],
            'm': ['moon', 'milk', 'map'],
            'n': ['nose', 'nest', 'net'],
            'o': ['owl', 'orange', 'octopus'],
            'p': ['pig', 'pen', 'pizza'],
            'q': ['queen', 'quilt', 'quack'],
            'r': ['rabbit', 'rainbow', 'ring'],
            's': ['sun', 'sock', 'snake'],
            't': ['tree', 'tiger', 'top'],
            'u': ['umbrella', 'unicorn', 'up'],
            'v': ['van', 'violin', 'vest'],
            'w': ['worm', 'water', 'wagon'],
            'x': ['x-ray', 'xylophone', 'x-ray fish'],
            'y': ['yo-yo', 'yellow', 'yogurt'],
            'z': ['zebra', 'zoo', 'zip']
        };

        // Mini-games State
        let currentMinigame = null;
        let minigameScore = 0;
        let minigameTimer = null;
        let rainGameInterval = null;
        let basketPosition = 50;
        let memoryCards = [];
        let flippedCards = [];
        let matchedPairs = 0;

        // Voice Recording State
        let mediaRecorder = null;
        let audioChunks = [];
        let recordings = [];
        let isRecording = false;

        // Focus Mode State
        let focusModeEnabled = false;
        let highContrastEnabled = false;
        let reduceMotionEnabled = false;
        let previousTimerState = true;  // Store timer state before focus mode

        // Streak System State
        let currentStreak = 0;
        let lastPlayDate = null;
        let streakHistory = [];
        let streakMilestones = [3, 7, 14, 30, 50, 100];

        // Celebration State
        let celebrationType = 'fireworks';
        const celebrationEmojis = {
            fireworks: ['ðŸŽ†', 'ðŸŽ‡', 'âœ¨', 'ðŸŽ‰', 'ðŸŽŠ'],
            animals: ['ðŸ¦', 'ðŸ˜', 'ðŸ¦’', 'ðŸ¦œ', 'ðŸ¦‹', 'ðŸ§', 'ðŸ¦Š'],
            vehicles: ['ðŸš—', 'ðŸš€', 'âœˆï¸', 'ðŸš', 'ðŸŽï¸', 'ðŸš‚'],
            space: ['â­', 'ðŸŒŸ', 'ðŸ’«', 'â˜„ï¸', 'ðŸŒ™', 'ðŸª'],
            dinosaurs: ['ðŸ¦•', 'ðŸ¦–', 'ðŸ¦´'],
            hearts: ['ðŸ’–', 'ðŸ’', 'ðŸ’—', 'ðŸ’“', 'ðŸ’•']
        };

        // Load saved data
        loadGameData();

        // Speech settings
        let speechSupported = 'speechSynthesis' in window;

        // Letter collections
        const lowerLetters = 'abcdefghijklmnopqrstuvwxyz'.split('');
        const upperLetters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('');

        // Phonetic sounds spelled out for primitive TTS systems (natural pacing + anchor word)
        const phoneticSounds = {
            'a': 'ah, ah, ah, as in apple',
            'b': 'buh, buh, buh, as in ball',
            'c': 'cah, cah, cah, as in cat',
            'd': 'duh, duh, duh, as in dog',
            'e': 'eh, eh, eh, as in egg',
            'f': 'fuh, fuh, fuh, as in fish',
            'g': 'guh, guh, guh, as in goat',
            'h': 'huh, huh, huh, as in hat',
            'i': 'ih, ih, ih, as in igloo',
            'j': 'juh, juh, juh, as in jump',
            'k': 'kuh, kuh, kuh, as in kite',
            'l': 'luh, luh, luh, as in lion',
            'm': 'mmm, mmm, mmm, as in moon',
            'n': 'nuh, nuh, nuh, as in nose',
            'o': 'ah, ah, ah, as in octopus',
            'p': 'puh, puh, puh, as in pig',
            'q': 'kwee, kwee, kwee, as in queen',
            'r': 'ruh, ruh, ruh, as in rabbit',
            's': 'sss, sss, sss, as in snake',
            't': 'tuh, tuh, tuh, as in turtle',
            'u': 'uh, uh, uh, as in umbrella',
            'v': 'vuh, vuh, vuh, as in violin',
            'w': 'wuh, wuh, wuh, as in whale',
            'x': 'ks, ks, ks, as in fox',
            'y': 'yuh, yuh, yuh, as in yellow',
            'z': 'zuh, zuh, zuh, as in zebra'
        };

        // Letter names spelled to coerce clear pronunciation on basic TTS engines
        const letterNamePronunciations = {
            'a': 'ay',
            'b': 'bee',
            'c': 'see',
            'd': 'dee',
            'e': 'ee',
            'f': 'eff',
            'g': 'gee',
            'h': 'aitch',
            'i': 'eye',
            'j': 'jay',
            'k': 'kay',
            'l': 'ell',
            'm': 'em',
            'n': 'en',
            'o': 'oh',
            'p': 'pee',
            'q': 'cue',
            'r': 'ar',
            's': 'ess',
            't': 'tee',
            'u': 'yoo',
            'v': 'vee',
            'w': 'double you',
            'x': 'ex',
            'y': 'why',
            'z': 'zee'
        };

        function getLetterCollection() {
            if (currentCase === 'lower') return lowerLetters;
            if (currentCase === 'upper') return upperLetters;
            return [...lowerLetters, ...upperLetters];
        }

        function getRandomLetter() {
            let letters = getLetterCollection();

            // Adaptive difficulty algorithm
            updateAdaptivePool(letters);

            // Use adaptive pool if available
            if (adaptivePool.length > 0) {
                // Apply post-error shape bias to reinforce distinctions among similar letters
                let selectionPool = adaptivePool;
                if (shapeBiasRoundsRemaining > 0 && shapeBiasTargetLower) {
                    const groupKey = letterToShapeGroupLower[shapeBiasTargetLower];
                    if (groupKey) {
                        const peerSetLower = new Set(
                            (shapeSimilarityGroups[groupKey] || []).filter(l => l !== shapeBiasTargetLower)
                        );
                        // Create a copy and add ~50% more weight to shape peers (excluding the target itself)
                        selectionPool = adaptivePool.slice();
                        letters.forEach(letter => {
                            const lower = letter.toLowerCase();
                            if (peerSetLower.has(lower)) {
                                const baseWeight = Math.ceil((latestLetterWeights[letter] || 1));
                                const extra = Math.max(1, Math.floor(baseWeight * 0.5));
                                for (let i = 0; i < extra; i++) selectionPool.push(letter);
                            }
                        });
                    }
                    shapeBiasRoundsRemaining = Math.max(0, shapeBiasRoundsRemaining - 1);
                }
                const selected = selectionPool[Math.floor(Math.random() * selectionPool.length)];

                // Track recent letters (keep last 3)
                recentLetters.push(selected.toLowerCase());
                if (recentLetters.length > 3) recentLetters.shift();

                return selected;
            }

            // Fallback to random selection
            const selected = letters[Math.floor(Math.random() * letters.length)];
            recentLetters.push(selected.toLowerCase());
            if (recentLetters.length > 3) recentLetters.shift();

            return selected;
        }

        function updateAdaptivePool(availableLetters) {
            adaptivePool = [];

            // Calculate difficulty weights for each letter
            const letterWeights = {};

            availableLetters.forEach(letter => {
                const key = letter.toLowerCase();
                const perf = letterPerformance[key] || { correct: 0, total: 0, avgTime: 0 };

                // Calculate success rate (0-1)
                const successRate = perf.total > 0 ? perf.correct / perf.total : 0.5;

                // Calculate weight based on performance
                let weight = 1;

                // Letters with low success rate get higher weight
                if (successRate < 0.3) weight = 5;
                else if (successRate < 0.5) weight = 3;
                else if (successRate < 0.7) weight = 2;
                else if (successRate > 0.9 && perf.total > 3) weight = 0.5;

                // Increase weight for letters with errors
                if (letterErrors[key]) {
                    weight += letterErrors[key] * 0.5;
                }

                // Decrease weight for recently used letters
                if (recentLetters.includes(key)) {
                    weight *= 0.3;
                }

                // Adjust based on current difficulty level
                if (difficultyLevel <= 2) {
                    // Easy mode: focus on easier letters
                    if (successRate > 0.7) weight *= 1.5;
                } else if (difficultyLevel >= 4) {
                    // Hard mode: focus on challenging letters
                    if (successRate < 0.5) weight *= 1.5;
                }

                letterWeights[letter] = weight;
            });

            // Build weighted pool
            availableLetters.forEach(letter => {
                const weight = Math.ceil(letterWeights[letter]);
                latestLetterWeights[letter] = weight;
                for (let i = 0; i < weight; i++) {
                    adaptivePool.push(letter);
                }
            });

            // Ensure minimum pool size
            if (adaptivePool.length < 10) {
                adaptivePool = [...availableLetters];
            }
        }

        function updateLetterPerformance(letter, correct, responseTime, pointsDelta = 0) {
            const key = letter.toLowerCase();
            if (!letterPerformance[key]) {
                letterPerformance[key] = { correct: 0, total: 0, avgTime: 0, times: [], score: 0 };
            }

            const perf = letterPerformance[key];
            perf.total++;
            if (correct) {
                perf.correct++;
                perf.times.push(responseTime);

                // Keep only last 10 times
                if (perf.times.length > 10) perf.times.shift();

                // Calculate average time
                perf.avgTime = perf.times.reduce((a, b) => a + b, 0) / perf.times.length;

                // Check for mastery (>90% success rate with at least 5 attempts)
                if (perf.total >= 5 && (perf.correct / perf.total) > 0.9) {
                    lettersMastered.add(key);
                    checkAchievement('mastery', lettersMastered.size);
                }
            }

            // Track per-letter score for personalized challenges
            perf.score = (perf.score || 0) + (typeof pointsDelta === 'number' ? pointsDelta : 0);

            // Update difficulty level based on overall performance
            updateDifficultyLevel();

            // Save progress
            saveGameData();
        }

        function updateDifficultyLevel() {
            const totalPerf = Object.values(letterPerformance);
            if (totalPerf.length === 0) {
                difficultyLevel = 1;
                return;
            }

            let totalCorrect = 0;
            let totalAttempts = 0;
            totalPerf.forEach(perf => {
                totalCorrect += perf.correct;
                totalAttempts += perf.total;
            });

            const overallSuccess = totalAttempts > 0 ? totalCorrect / totalAttempts : 0;

            // Adjust difficulty based on success rate and rounds
            if (overallSuccess > 0.85 && currentRound > 2) difficultyLevel = 5;
            else if (overallSuccess > 0.75 && currentRound > 1) difficultyLevel = 4;
            else if (overallSuccess > 0.65) difficultyLevel = 3;
            else if (overallSuccess > 0.5) difficultyLevel = 2;
            else difficultyLevel = 1;

            // Update UI
            updateDifficultyIndicator();
        }

        function updateDifficultyIndicator() {
            for (let i = 1; i <= 5; i++) {
                const bar = document.getElementById(`diff${i}`);
                if (i <= difficultyLevel) {
                    bar.classList.add('active');
                    if (difficultyLevel <= 2) {
                        bar.classList.remove('medium', 'hard');
                    } else if (difficultyLevel <= 3) {
                        bar.classList.add('medium');
                        bar.classList.remove('hard');
                    } else {
                        bar.classList.add('hard');
                        bar.classList.remove('medium');
                    }
                } else {
                    bar.classList.remove('active', 'medium', 'hard');
                }
            }
        }

        function cancelSpeech() {
            if (speechSupported) {
                try { speechSynthesis.cancel(); } catch (e) { }
            }
        }

        function speakLetter(letter, callback) {
            if (!speechSupported || !soundEnabled) {
                if (callback) callback();
                return;
            }

            cancelSpeech();

            // Improved pronunciation for letter names using unified map
            let textToSpeak = letter;
            const lowerLetter = letter.toLowerCase();
            if (letterNamePronunciations[lowerLetter]) {
                textToSpeak = letterNamePronunciations[lowerLetter];
            }

            const utterance = new SpeechSynthesisUtterance(textToSpeak);
            utterance.rate = 0.7;  // Slower for young children
            utterance.pitch = 1.1;  // Friendly pitch
            utterance.volume = 1;

            const selectedVoice = getBestVoice();
            if (selectedVoice) {
                utterance.voice = selectedVoice;
            }

            if (callback) {
                utterance.onend = callback;
            }

            speechSynthesis.speak(utterance);
        }

        function speakPhrase(phrase, callback) {
            if (!speechSupported || !soundEnabled) {
                if (callback) callback();
                return;
            }

            cancelSpeech();

            // Clean up the phrase for better speech
            let cleanPhrase = phrase
                .replace(/[!]+/g, '!')  // Remove excessive exclamation marks
                .replace(/\.{2,}/g, '. ')  // Replace ellipsis with period
                .replace(/\s+/g, ' ')  // Normalize whitespace
                .trim();

            const utterance = new SpeechSynthesisUtterance(cleanPhrase);
            utterance.rate = 0.95;  // Slightly slower for clarity
            utterance.pitch = 1.05;  // Natural pitch
            utterance.volume = 1;

            const selectedVoice = getBestVoice();
            if (selectedVoice) {
                utterance.voice = selectedVoice;
            }

            if (callback) {
                utterance.onend = callback;
            }

            speechSynthesis.speak(utterance);
        }

        function speakTracePrompt(letter) {
            if (!speechSupported || !soundEnabled) return;
            // Speak as two utterances to avoid stutter/duplication on some TTS engines
            cancelSpeech();
            const selectedVoice = getBestVoice();

            const lead = new SpeechSynthesisUtterance('Trace the letter.');
            lead.rate = 0.95;
            lead.pitch = 1.05;
            lead.volume = 1;
            if (selectedVoice) lead.voice = selectedVoice;
            lead.onend = () => {
                // brief pause between sentences for clarity
                setTimeout(() => speakLetter(letter), 120);
            };
            speechSynthesis.speak(lead);
        }

        function speakPhonetics(letter, callback) {
            if (!soundEnabled) { if (callback) callback(); return; }
            const lower = letter.toLowerCase();
            const phonetic = phoneticSounds[lower];
            if (!phonetic) { if (callback) callback(); return; }

            cancelSpeech();
            const letterName = letterNamePronunciations[lower] || letter;
            const sound = phonetic.split(',')[0].trim();
            const anchorIdx = phonetic.toLowerCase().indexOf('as in');
            const anchor = anchorIdx !== -1 ? phonetic.slice(anchorIdx + 5).trim() : '';

            // Speak as multiple utterances for reliable pauses on mobile TTS
            const selectedVoice = getBestVoice();
            const parts = [
                `${sound}.`,
                `${sound}.`,
                `${sound}.`
            ];
            if (anchor) parts.push(`as in ${anchor}.`);

            let idx = 0;
            const speakNext = () => {
                if (idx >= parts.length) { if (callback) callback(); return; }
                const u = new SpeechSynthesisUtterance(parts[idx]);
                u.rate = 0.8;
                u.pitch = 1.05;
                u.volume = 1;
                if (selectedVoice) u.voice = selectedVoice;
                u.onend = () => { idx++; setTimeout(speakNext, 60); };
                speechSynthesis.speak(u);
            };
            speakNext();
        }

        function updateScoreDisplay() {
            const displayScore = currentPlayer ? currentPlayer.score : score;
            const displayCorrect = currentPlayer ? currentPlayer.roundCorrect : roundCorrect;
            const displayWrong = currentPlayer ? currentPlayer.roundWrong : roundWrong;
            const displayRound = currentPlayer ? currentPlayer.currentRound : currentRound;

            document.getElementById('scoreDisplay').textContent = Math.max(0, displayScore);
            document.getElementById('correctCount').textContent = displayCorrect;
            document.getElementById('totalCount').textContent = QUESTIONS_PER_ROUND;
            document.getElementById('wrongCount').textContent = displayWrong;
            document.getElementById('roundNumber').textContent = displayRound;

            // Update stars with animation
            const starCount = Math.min(5, Math.floor(displayScore / 100));
            const starsDisplay = document.getElementById('starsDisplay');
            starsDisplay.innerHTML = '';

            for (let i = 0; i < 5; i++) {
                const star = document.createElement('span');
                star.className = 'star';
                if (i < starCount) {
                    star.textContent = 'â­';
                    star.classList.add('filled');
                    star.style.animationDelay = `${i * 0.1}s`;
                } else {
                    star.textContent = 'â˜†';
                }
                starsDisplay.appendChild(star);
            }
        }

        function startTimer() {
            if (!timerEnabled) return;

            clearTimer();

            const duration = currentRound === 1 ? timerDuration : Math.max(5, timerDuration - 2);
            let timeLeft = duration;
            let lastSpokenCountdown = null;

            const timerDisplay = document.getElementById('timerDisplay');
            const timerBar = document.getElementById('timerBar');
            const timerBarFill = document.getElementById('timerBarFill');

            timerBar.style.display = 'block';
            timerBarFill.style.width = '100%';
            timerBarFill.className = 'timer-bar-fill';

            timerDisplay.innerHTML = `â±ï¸ <span>${timeLeft}</span>`;
            timerDisplay.className = 'timer-display';

            let startTime = Date.now();

            currentTimer = setInterval(() => {
                if (isProcessing) return; // lock prevents overlapping actions
                const elapsed = (Date.now() - startTime) / 1000;
                timeLeft = Math.max(0, Math.ceil(duration - elapsed));

                const percentage = ((duration - elapsed) / duration) * 100;
                timerBarFill.style.width = Math.max(0, percentage) + '%';

                timerDisplay.innerHTML = `â±ï¸ <span>${timeLeft}</span>`;

                if (timeLeft <= 3 && timeLeft > 0) {
                    timerDisplay.className = 'timer-display warning';
                    timerBarFill.classList.add('warning');
                    // Speak countdown once per second (no overlaps)
                    if (lastSpokenCountdown !== timeLeft && soundEnabled) {
                        lastSpokenCountdown = timeLeft;
                        cancelSpeech();
                        speakPhrase(timeLeft.toString());
                    }
                } else if (timeLeft === 0) {
                    timerDisplay.className = 'timer-display critical';
                    timerBarFill.classList.add('critical');
                }

                if (timeLeft <= 0) {
                    clearTimer();
                    timerDisplay.innerHTML = "â° Time's up!";
                    timerBarFill.style.width = '0%';
                    speakPhrase("Time's up!");
                    if (!isProcessing) {
                        isProcessing = true;
                        setTimeout(() => {
                            isProcessing = false;
                            handleTimeUp();
                        }, 1000);
                    }
                }
            }, 100);
        }

        function clearTimer() {
            if (currentTimer) {
                clearInterval(currentTimer);
                currentTimer = null;
            }
            if (timerBarInterval) {
                clearInterval(timerBarInterval);
                timerBarInterval = null;
            }
            document.getElementById('timerDisplay').innerHTML = '';
            document.getElementById('timerDisplay').className = 'timer-display';
            document.getElementById('timerBar').style.display = 'none';
        }

        function clearAllTimers() {
            clearTimer();
            if (phonicsTimer) { window.clearTimeout(phonicsTimer); phonicsTimer = null; }
            if (phonicsPhaseTimeout) { window.clearTimeout(phonicsPhaseTimeout); phonicsPhaseTimeout = null; }
            if (speakPromptTimeout) { window.clearTimeout(speakPromptTimeout); speakPromptTimeout = null; }
            if (speakLetterTimeout) { window.clearTimeout(speakLetterTimeout); speakLetterTimeout = null; }
            if (rainGameInterval) { window.clearInterval(rainGameInterval); rainGameInterval = null; }
            if (minigameTimer) { window.clearInterval(minigameTimer); minigameTimer = null; }
            if (dashboardTimer) { window.clearTimeout(dashboardTimer); dashboardTimer = null; }
            if (typeof drawAdvanceTimeout !== 'undefined' && drawAdvanceTimeout) { window.clearTimeout(drawAdvanceTimeout); drawAdvanceTimeout = null; }
            // Also clear any idle hint timers used by tracing mode
            if (typeof clearIdleHintTimers === 'function') {
                try { clearIdleHintTimers(); } catch (e) { }
            }
        }

        function handleTimeUp() {
            if (waitingForPhonics || isProcessing) return;
            isProcessing = true;

            roundWrong++;
            wrongAnswers++;
            totalQuestions++;
            score = Math.max(0, score - 10);
            trackLetterError(currentLetter);
            // Treat timeout as an incorrect attempt for SRS scheduling and per-letter scoring
            try { updateLetterPerformance(currentLetter, false, 0, -10); } catch (e) {}
            showFeedback('Too slow! â°', 'error');
            createWrongEffect();
            setTimeout(() => { isProcessing = false; startIdentifyGame(); }, 2000);
        }

        function trackLetterError(letter) {
            const key = letter.toLowerCase();
            letterErrors[key] = (letterErrors[key] || 0) + 1;
            // Trigger a brief shape-bias window to reinforce similar-shape distinctions
            shapeBiasTargetLower = key;
            shapeBiasRoundsRemaining = 3; // bias for next few selections
        }

        let lastCelebrationTime = 0;
        function createConfetti(element) {
            if (focusModeEnabled || reduceMotionEnabled) {
                showFeedback('Great job! âœ“', 'success');
                return;
            }

            const rect = element ? element.getBoundingClientRect() : { left: window.innerWidth / 2, top: window.innerHeight / 2, width: 0, height: 0 };
            const originX = rect.left + (rect.width || 0) / 2;
            const originY = rect.top + (rect.height || 0) / 2;

            const layer = document.createElement('div');
            layer.style.cssText = 'position:fixed; inset:0; pointer-events:none; z-index:9999; overflow:visible;';
            document.body.appendChild(layer);

            const emojis = celebrationEmojis[celebrationType] || celebrationEmojis.fireworks;
            const now = Date.now();
            if (now - lastCelebrationTime < 500) { layer.remove(); return; }
            lastCelebrationTime = now;
            const count = 8;

            for (let i = 0; i < count; i++) {
                const el = document.createElement('span');
                el.textContent = emojis[Math.floor(Math.random() * emojis.length)];
                el.style.cssText = `position:absolute; left:${originX}px; top:${originY}px; will-change:transform,opacity; font-size:${24 + Math.random() * 14}px;`;
                layer.appendChild(el);

                const angle = (Math.PI * 2) * (i / count) + (Math.random() * 0.6 - 0.3);
                const distance = 100 + Math.random() * 150;
                const dx = Math.cos(angle) * distance;
                const dy = Math.sin(angle) * distance - (40 + Math.random() * 40);
                const rot = (Math.random() * 720 - 360);

                if (typeof gsap !== 'undefined') {
                    gsap.fromTo(el,
                        { x: 0, y: 0, scale: 0.6, opacity: 1, rotation: 0 },
                        { x: dx, y: dy, scale: 1.1, rotation: rot, opacity: 0, duration: 1 + Math.random() * 0.4, ease: 'power2.out' }
                    );
                } else {
                    // Fallback animation using requestAnimationFrame
                    const start = performance.now();
                    const duration = 1000 + Math.random() * 400;
                    function step(t) {
                        const p = Math.min(1, (t - start) / duration);
                        const ease = 1 - Math.pow(1 - p, 2);
                        el.style.transform = `translate(${dx * ease}px, ${dy * ease}px) rotate(${rot * ease}deg) scale(${0.6 + 0.5 * ease})`;
                        el.style.opacity = String(1 - p);
                        if (p < 1) requestAnimationFrame(step);
                    }
                    requestAnimationFrame(step);
                }
            }
            if (typeof gsap !== 'undefined') {
                gsap.delayedCall(1.6, () => layer.remove());
            } else {
                setTimeout(() => layer.remove(), 1600);
            }
        }

        function createCustomCelebration(element) {
            // Alias to enhanced confetti for now
            createConfetti(element);
        }

        // Letter-specific celebrations
        function createLetterCelebration(letter, element) {
            try {
                if (focusModeEnabled || reduceMotionEnabled) {
                    showFeedback('Great job! âœ“', 'success');
                    return;
                }

                const now = Date.now();
                if (now - lastCelebrationTime < 500) return;
                lastCelebrationTime = now;

                const upper = (letter || '').toString().toUpperCase();

                const celebrations = {
                    'A': () => createAirplaneTakeoff(element),
                    'B': () => createBalloonFloat(element),
                    'C': () => createConfettiBurst(element),
                    'D': () => createDrumRoll(element),
                    'F': () => createFireworksBurst(element),
                    'G': () => createGuitarStrum(element),
                    'H': () => createHeartsRain(element),
                    'I': () => createIceSparkle(element),
                    'J': () => createJellyfishFloat(element),
                    'K': () => createKiteSoar(element),
                    'E': () => createStarExplosion(element),
                    'M': () => createMagicWand(element),
                    'N': () => createNightSky(element),
                    'L': () => createLightningStrike(element),
                    'O': () => createBubbleRise(element),
                    'P': () => createPopcornPop(element),
                    'Q': () => createQueenCrown(element),
                    'R': () => createRainbowArc(element),
                    'S': () => createSnakeWiggle(element),
                    'T': () => createTrophyShine(element),
                    'U': () => createUmbrellaSprinkle(element),
                    'V': () => createVictoryV(element),
                    'W': () => createWaveSplash(element),
                    'Y': () => createYoYoBounce(element),
                    'Z': () => createZoomRocket(element),
                    'X': () => createXMarksTheSpot(element)
                };

                // Always do a letter-specific hero burst first
                try {
                    const theme = getLetterTheme(upper);
                    createHeroLetterBurst(upper, element, theme);
                } catch (_) { /* non-fatal */ }

                // Then run the per-letter animation; fallback to a star burst
                const specific = celebrations[upper];
                if (specific) {
                    specific();
                } else {
                    createStarExplosion(element);
                }
            } catch (e) {
                // Fallback if anything goes wrong
                try { createConfetti(element); } catch (_) {}
            }
        }

        // Helpers
        function getOriginFromElement(element) {
            const rect = element ? element.getBoundingClientRect() : { left: window.innerWidth / 2, top: window.innerHeight / 2, width: 0, height: 0 };
            return {
                x: rect.left + (rect.width || 0) / 2,
                y: rect.top + (rect.height || 0) / 2
            };
        }

        function createCelebrationLayer() {
            const layer = document.createElement('div');
            layer.style.cssText = 'position:fixed; inset:0; pointer-events:none; z-index:9999; overflow:visible;';
            document.body.appendChild(layer);
            return layer;
        }

        function animateWithRAF(durationMs, onUpdate, onComplete) {
            const start = performance.now();
            function step(t) {
                const p = Math.min(1, (t - start) / durationMs);
                // easeOutCubic
                const e = 1 - Math.pow(1 - p, 3);
                onUpdate(e);
                if (p < 1) requestAnimationFrame(step); else if (onComplete) onComplete();
            }
            requestAnimationFrame(step);
        }

        // Letter-specific visual theme configuration
        function getLetterTheme(letter) {
            const themes = {
                'A': { base: '#60a5fa', accent: '#93c5fd', emojis: ['â˜ï¸','âœ¨','âœˆï¸'] },
                'B': { base: '#f472b6', accent: '#fb7185', emojis: ['ðŸŽˆ','âœ¨'] },
                'C': { base: '#f59e0b', accent: '#fbbf24', emojis: ['ðŸŽ‰','ðŸŽŠ','âœ¨'] },
                'D': { base: '#93c5fd', accent: '#a78bfa', emojis: ['ðŸ¥','ðŸŽµ'] },
                'E': { base: '#fcd34d', accent: '#fde68a', emojis: ['â­','ðŸŒŸ'] },
                'F': { base: '#ef4444', accent: '#f97316', emojis: ['ðŸŽ†','ðŸŽ‡','âœ¨'] },
                'G': { base: '#f59e0b', accent: '#fbbf24', emojis: ['ðŸŽ¸','ðŸŽµ'] },
                'H': { base: '#ef4444', accent: '#f472b6', emojis: ['â¤ï¸','ðŸ’–'] },
                'I': { base: '#93c5fd', accent: '#bfdbfe', emojis: ['â„ï¸','âœ¨'] },
                'J': { base: '#06b6d4', accent: '#22d3ee', emojis: ['ðŸª¼','âœ¨','ðŸ’§'] },
                'K': { base: '#34d399', accent: '#10b981', emojis: ['ðŸª','âœ¨'] },
                'L': { base: '#a78bfa', accent: '#8b5cf6', emojis: ['âš¡','âœ¨'] },
                'M': { base: '#f472b6', accent: '#e879f9', emojis: ['ðŸª„','âœ¨'] },
                'N': { base: '#0ea5e9', accent: '#38bdf8', emojis: ['ðŸŒ™','â­'] },
                'O': { base: '#22d3ee', accent: '#67e8f9', emojis: ['ðŸ«§','âœ¨'] },
                'P': { base: '#f97316', accent: '#fdba74', emojis: ['ðŸ¿','âœ¨'] },
                'Q': { base: '#eab308', accent: '#fde047', emojis: ['ðŸ‘‘','âœ¨'] },
                'R': { base: '#ef4444', accent: '#f59e0b', emojis: ['ðŸŒˆ','âœ¨'] },
                'S': { base: '#10b981', accent: '#34d399', emojis: ['ðŸ','ðŸŸ¢'] },
                'T': { base: '#f59e0b', accent: '#fbbf24', emojis: ['ðŸ†','âœ¨'] },
                'U': { base: '#06b6d4', accent: '#22d3ee', emojis: ['â˜”','ðŸ’§'] },
                'V': { base: '#f472b6', accent: '#e879f9', emojis: ['âœŒï¸','âœ¨'] },
                'W': { base: '#60a5fa', accent: '#93c5fd', emojis: ['ðŸŒŠ','ðŸ’¦'] },
                'X': { base: '#ef4444', accent: '#f59e0b', emojis: ['âŒ','ðŸ’¥'] },
                'Y': { base: '#a78bfa', accent: '#8b5cf6', emojis: ['ðŸª€','âœ¨'] },
                'Z': { base: '#0ea5e9', accent: '#38bdf8', emojis: ['ðŸš€','ðŸ”¥'] }
            };
            return themes[letter] || { base: '#f472b6', accent: '#fbcfe8', emojis: ['âœ¨','ðŸŽ‰'] };
        }

        // Big hero burst around the selected letter location
        function createHeroLetterBurst(letter, element, theme) {
            const origin = getOriginFromElement(element);
            const layer = createCelebrationLayer();

            const size = 160;
            const ring = document.createElement('div');
            ring.style.cssText = `position:absolute; left:${origin.x - size/2}px; top:${origin.y - size/2}px; width:${size}px; height:${size}px; border-radius:50%; background: radial-gradient(circle at 50% 50%, ${theme.accent}b3 0%, ${theme.base}66 55%, transparent 70%); filter: blur(1px); opacity:0;`;
            layer.appendChild(ring);

            const big = document.createElement('div');
            big.textContent = letter;
            big.style.cssText = `position:absolute; left:${origin.x}px; top:${origin.y}px; transform: translate(-50%, -50%); font-size:104px; font-weight:900; line-height:1; background: linear-gradient(135deg, ${theme.base}, ${theme.accent}); -webkit-background-clip: text; background-clip: text; color: transparent; text-shadow: 0 8px 0 rgba(0,0,0,.08), 0 0 28px ${theme.accent}99;`;
            layer.appendChild(big);

            // Sparkles
            const sparkleCount = 10;
            for (let i = 0; i < sparkleCount; i++) {
                const star = document.createElement('span');
                star.textContent = 'âœ¨';
                star.style.cssText = `position:absolute; left:${origin.x}px; top:${origin.y}px; font-size:${14 + Math.random() * 10}px; opacity:0;`;
                layer.appendChild(star);
                const angle = Math.random() * Math.PI * 2;
                const dist = 90 + Math.random() * 70;
                const dx = Math.cos(angle) * dist;
                const dy = Math.sin(angle) * dist;
                const dur = 800 + Math.random() * 300;
                if (typeof gsap !== 'undefined') {
                    gsap.fromTo(star, { x: 0, y: 0, opacity: 0 }, { x: dx, y: dy, opacity: 1, duration: dur / 1000, ease: 'sine.out' });
                    gsap.to(star, { opacity: 0, duration: 0.3, delay: (dur / 1000) - 0.15, ease: 'sine.in' });
                } else {
                    animateWithRAF(dur, (e) => {
                        star.style.transform = `translate(${dx * e}px, ${dy * e}px)`;
                        star.style.opacity = String(e < 0.85 ? e : Math.max(0, 1 - (e - 0.85) * 6));
                    });
                }
            }

            // Themed emoji particles
            const particles = theme.emojis || ['âœ¨'];
            const particleCount = 14;
            for (let i = 0; i < particleCount; i++) {
                const p = document.createElement('span');
                p.textContent = particles[Math.floor(Math.random() * particles.length)];
                p.style.cssText = `position:absolute; left:${origin.x}px; top:${origin.y}px; font-size:${18 + Math.random() * 12}px; opacity:1;`;
                layer.appendChild(p);
                const angle = (Math.PI * 2) * (i / particleCount) + (Math.random() * 0.6 - 0.3);
                const dist = 120 + Math.random() * 120;
                const dx = Math.cos(angle) * dist;
                const dy = Math.sin(angle) * dist - 30;
                const rot = (Math.random() * 360 - 180);
                const dur = 1000 + Math.random() * 400;
                if (typeof gsap !== 'undefined') {
                    gsap.fromTo(p, { x: 0, y: 0, rotation: 0, opacity: 1, scale: 0.8 }, { x: dx, y: dy, rotation: rot, opacity: 0, scale: 1.1, duration: dur / 1000, ease: 'power2.out' });
                } else {
                    animateWithRAF(dur, (e) => {
                        p.style.transform = `translate(${dx * e}px, ${dy * e}px) rotate(${rot * e}deg) scale(${0.8 + 0.3 * e})`;
                        p.style.opacity = String(1 - e);
                    });
                }
            }

            // Animate hero letter and ring
            if (typeof gsap !== 'undefined') {
                const tl = gsap.timeline();
                tl.fromTo(big, { scale: 0, rotation: -10, opacity: 0 }, { scale: 1.2, rotation: 0, opacity: 1, duration: 0.5, ease: 'back.out(1.8)' })
                  .to(big, { scale: 1, duration: 0.2, ease: 'power1.out' }, '-=0.05');
                gsap.fromTo(ring, { scale: 0.2, opacity: 0.6 }, { scale: 1.6, opacity: 0, duration: 0.8, ease: 'sine.out' });
            } else {
                animateWithRAF(700, (e) => {
                    big.style.transform = `translate(-50%, -50%) scale(${e * 1.2})`;
                    big.style.opacity = String(e);
                });
                animateWithRAF(800, (e) => {
                    ring.style.transform = `scale(${0.2 + 1.4 * e})`;
                    ring.style.opacity = String(0.6 * (1 - e));
                });
            }

            setTimeout(() => layer.remove(), 1600);
        }

        // Individual animations
        function createBalloonFloat(element) {
            const origin = getOriginFromElement(element);
            const layer = createCelebrationLayer();
            const count = 8;
            for (let i = 0; i < count; i++) {
                const el = document.createElement('span');
                el.textContent = 'ðŸŽˆ';
                el.style.cssText = `position:absolute; left:${origin.x}px; top:${origin.y}px; font-size:${28 + Math.random() * 14}px;`;
                layer.appendChild(el);
                const dx = (Math.random() * 120 - 60);
                const dy = - (220 + Math.random() * 180);
                const rot = (Math.random() * 30 - 15);
                const duration = 1200 + Math.random() * 600;
                if (typeof gsap !== 'undefined') {
                    gsap.fromTo(el, { x: 0, y: 0, rotation: 0, opacity: 1 }, { x: dx, y: dy, rotation: rot, opacity: 0.2, duration: duration / 1000, ease: 'sine.out' });
                } else {
                    animateWithRAF(duration, (e) => {
                        const sway = Math.sin(e * Math.PI * 2) * 12;
                        el.style.transform = `translate(${dx * e + sway}px, ${dy * e}px) rotate(${rot * e}deg)`;
                        el.style.opacity = String(1 - e * 0.8);
                    });
                }
            }
            setTimeout(() => layer.remove(), 2000);
        }

        function createRainbowArc(element) {
            const origin = getOriginFromElement(element);
            const layer = createCelebrationLayer();
            const rainbow = document.createElement('span');
            rainbow.textContent = 'ðŸŒˆ';
            rainbow.style.cssText = `position:absolute; left:${origin.x}px; top:${origin.y}px; font-size:80px; transform-origin:center;`;
            layer.appendChild(rainbow);
            const dx = 260, dy = -120;
            const duration = 1200;
            if (typeof gsap !== 'undefined') {
                gsap.fromTo(rainbow, { x: 0, y: 0, scale: 0.4, rotation: -20, opacity: 0 }, { x: dx, y: dy, scale: 1, rotation: 0, opacity: 1, duration: duration / 1000, ease: 'power2.out' });
            } else {
                animateWithRAF(duration, (e) => {
                    const angle = -Math.PI / 3 + e * (Math.PI / 3);
                    const x = dx * e;
                    const y = dy * e - Math.sin(e * Math.PI) * 30;
                    rainbow.style.transform = `translate(${x}px, ${y}px) rotate(${angle * (180 / Math.PI)}deg) scale(${0.4 + 0.6 * e})`;
                    rainbow.style.opacity = String(e);
                });
            }
            // add some twinkles
            for (let i = 0; i < 6; i++) {
                const star = document.createElement('span');
                star.textContent = 'âœ¨';
                star.style.cssText = `position:absolute; left:${origin.x}px; top:${origin.y}px; font-size:${18 + Math.random() * 12}px;`;
                layer.appendChild(star);
                const sdx = (Math.random() * 220 - 110);
                const sdy = - (60 + Math.random() * 120);
                const dur = 900 + Math.random() * 400;
                if (typeof gsap !== 'undefined') {
                    gsap.fromTo(star, { x: 0, y: 0, opacity: 0 }, { x: sdx, y: sdy, opacity: 1, duration: dur / 1000, ease: 'sine.out' });
                } else {
                    animateWithRAF(dur, (e) => {
                        star.style.transform = `translate(${sdx * e}px, ${sdy * e}px)`;
                        star.style.opacity = String(e);
                    });
                }
            }
            setTimeout(() => layer.remove(), 2000);
        }

        function createXMarksTheSpot(element) {
            const origin = getOriginFromElement(element);
            const layer = createCelebrationLayer();
            const x = document.createElement('span');
            x.textContent = 'âŒ';
            x.style.cssText = `position:absolute; left:${origin.x}px; top:${origin.y}px; font-size:72px; transform-origin:center;`;
            layer.appendChild(x);
            const duration = 700;
            if (typeof gsap !== 'undefined') {
                gsap.fromTo(x, { scale: 0, rotation: -180, opacity: 0 }, { scale: 1.2, rotation: 0, opacity: 1, duration: duration / 1000, ease: 'back.out(1.7)' });
                gsap.to(x, { scale: 1, duration: 0.2, delay: duration / 1000 });
            } else {
                animateWithRAF(duration, (e) => {
                    x.style.transform = `translate(-36px, -36px) rotate(${(-180 + 180 * e)}deg) scale(${e * 1.2})`;
                    x.style.opacity = String(e);
                });
            }
            for (let i = 0; i < 6; i++) {
                const burst = document.createElement('span');
                burst.textContent = 'ðŸ’¥';
                burst.style.cssText = `position:absolute; left:${origin.x}px; top:${origin.y}px; font-size:${22 + Math.random() * 10}px;`;
                layer.appendChild(burst);
                const angle = (Math.PI * 2) * (i / 6) + Math.random() * 0.4;
                const dist = 120 + Math.random() * 40;
                const dx = Math.cos(angle) * dist;
                const dy = Math.sin(angle) * dist;
                const dur = 800 + Math.random() * 300;
                if (typeof gsap !== 'undefined') {
                    gsap.fromTo(burst, { x: 0, y: 0, scale: 0.6, opacity: 1 }, { x: dx, y: dy, scale: 1.1, opacity: 0, duration: dur / 1000, ease: 'power2.out' });
                } else {
                    animateWithRAF(dur, (e) => {
                        burst.style.transform = `translate(${dx * e}px, ${dy * e}px) scale(${0.6 + 0.5 * e})`;
                        burst.style.opacity = String(1 - e);
                    });
                }
            }
            setTimeout(() => layer.remove(), 1600);
        }

        function createSnakeWiggle(element) {
            const origin = getOriginFromElement(element);
            const layer = createCelebrationLayer();
            const snake = document.createElement('span');
            snake.textContent = 'ðŸ';
            snake.style.cssText = `position:absolute; left:${origin.x}px; top:${origin.y}px; font-size:64px;`;
            layer.appendChild(snake);
            const dx = 300, dy = -40;
            const duration = 1400;
            if (typeof gsap !== 'undefined') {
                gsap.fromTo(snake, { x: 0, y: 0, rotation: -5 }, { x: dx, y: dy, rotation: 5, duration: duration / 1000, ease: 'sine.inOut', yoyo: true, repeat: 1 });
            } else {
                animateWithRAF(duration, (e) => {
                    const wave = Math.sin(e * Math.PI * 4) * 20;
                    snake.style.transform = `translate(${dx * e}px, ${dy * e + wave}px) rotate(${wave * 0.3}deg)`;
                });
            }
            // green confetti scales for added flair
            for (let i = 0; i < 6; i++) {
                const dot = document.createElement('span');
                dot.textContent = 'ðŸŸ¢';
                dot.style.cssText = `position:absolute; left:${origin.x}px; top:${origin.y}px; font-size:${16 + Math.random() * 8}px;`;
                layer.appendChild(dot);
                const angle = Math.random() * Math.PI * 2;
                const dist = 80 + Math.random() * 80;
                const dx2 = Math.cos(angle) * dist;
                const dy2 = Math.sin(angle) * dist - 40;
                const dur = 900 + Math.random() * 300;
                if (typeof gsap !== 'undefined') {
                    gsap.fromTo(dot, { x: 0, y: 0, opacity: 1 }, { x: dx2, y: dy2, opacity: 0, duration: dur / 1000, ease: 'power1.out' });
                } else {
                    animateWithRAF(dur, (e) => {
                        dot.style.transform = `translate(${dx2 * e}px, ${dy2 * e}px)`;
                        dot.style.opacity = String(1 - e);
                    });
                }
            }
            setTimeout(() => layer.remove(), 1800);
        }

        function createConfettiBurst(element) {
            // A more focused, celebratory burst using party emojis
            const origin = getOriginFromElement(element);
            const layer = createCelebrationLayer();
            const particles = ['ðŸŽ‰', 'ðŸŽŠ', 'âœ¨'];
            const count = 12;
            for (let i = 0; i < count; i++) {
                const el = document.createElement('span');
                el.textContent = particles[Math.floor(Math.random() * particles.length)];
                el.style.cssText = `position:absolute; left:${origin.x}px; top:${origin.y}px; font-size:${22 + Math.random() * 10}px;`;
                layer.appendChild(el);
                const angle = (Math.PI * 2) * (i / count) + (Math.random() * 0.4 - 0.2);
                const dist = 140 + Math.random() * 80;
                const dx = Math.cos(angle) * dist;
                const dy = Math.sin(angle) * dist - 40;
                const rot = (Math.random() * 360 - 180);
                const duration = 1000 + Math.random() * 400;
                if (typeof gsap !== 'undefined') {
                    gsap.fromTo(el, { x: 0, y: 0, rotation: 0, opacity: 1 }, { x: dx, y: dy, rotation: rot, opacity: 0, duration: duration / 1000, ease: 'power2.out' });
                } else {
                    animateWithRAF(duration, (e) => {
                        el.style.transform = `translate(${dx * e}px, ${dy * e}px) rotate(${rot * e}deg)`;
                        el.style.opacity = String(1 - e);
                    });
                }
            }
            setTimeout(() => layer.remove(), 1600);
        }

        function createStarExplosion(element) {
            const origin = getOriginFromElement(element);
            const layer = createCelebrationLayer();
            const stars = ['â­', 'ðŸŒŸ'];
            const count = 10;
            for (let i = 0; i < count; i++) {
                const el = document.createElement('span');
                el.textContent = stars[Math.floor(Math.random() * stars.length)];
                el.style.cssText = `position:absolute; left:${origin.x}px; top:${origin.y}px; font-size:${24 + Math.random() * 12}px;`;
                layer.appendChild(el);
                const angle = Math.random() * Math.PI * 2;
                const dist = 150 + Math.random() * 80;
                const dx = Math.cos(angle) * dist;
                const dy = Math.sin(angle) * dist - 30;
                const duration = 1100 + Math.random() * 400;
                if (typeof gsap !== 'undefined') {
                    gsap.fromTo(el, { x: 0, y: 0, scale: 0.4, opacity: 1 }, { x: dx, y: dy, scale: 1.2, opacity: 0, duration: duration / 1000, ease: 'power2.out' });
                } else {
                    animateWithRAF(duration, (e) => {
                        el.style.transform = `translate(${dx * e}px, ${dy * e}px) scale(${0.4 + 0.8 * e})`;
                        el.style.opacity = String(1 - e);
                    });
                }
            }
            setTimeout(() => layer.remove(), 1700);
        }

        function createLightningStrike(element) {
            const origin = getOriginFromElement(element);
            const layer = createCelebrationLayer();
            for (let i = 0; i < 3; i++) {
                const bolt = document.createElement('span');
                bolt.textContent = 'âš¡';
                bolt.style.cssText = `position:absolute; left:${origin.x - 32 + i * 16}px; top:${origin.y - 100}px; font-size:64px;`;
                layer.appendChild(bolt);
                const duration = 500 + i * 80;
                if (typeof gsap !== 'undefined') {
                    gsap.fromTo(bolt, { y: -140, opacity: 0 }, { y: 0, opacity: 1, duration: duration / 1000, ease: 'power2.out' });
                    gsap.to(bolt, { opacity: 0, duration: 0.25, delay: duration / 1000 });
                } else {
                    animateWithRAF(duration, (e) => {
                        bolt.style.transform = `translate(0px, ${(-140 + 140 * e)}px)`;
                        bolt.style.opacity = String(Math.min(1, e * 2));
                    });
                    setTimeout(() => { bolt.style.opacity = '0'; }, duration);
                }
            }
            setTimeout(() => layer.remove(), 1200);
        }

        function createBubbleRise(element) {
            const origin = getOriginFromElement(element);
            const layer = createCelebrationLayer();
            const count = 10;
            for (let i = 0; i < count; i++) {
                const el = document.createElement('span');
                el.textContent = 'ðŸ«§';
                el.style.cssText = `position:absolute; left:${origin.x}px; top:${origin.y}px; font-size:${16 + Math.random() * 14}px;`;
                layer.appendChild(el);
                const dx = (Math.random() * 140 - 70);
                const dy = - (160 + Math.random() * 180);
                const duration = 1400 + Math.random() * 500;
                if (typeof gsap !== 'undefined') {
                    gsap.fromTo(el, { x: 0, y: 0, opacity: 0.9 }, { x: dx, y: dy, opacity: 0, duration: duration / 1000, ease: 'sine.out' });
                } else {
                    animateWithRAF(duration, (e) => {
                        const sway = Math.sin(e * Math.PI * 2) * 10;
                        el.style.transform = `translate(${dx * e + sway}px, ${dy * e}px)`;
                        el.style.opacity = String(0.9 - 0.9 * e);
                    });
                }
            }
            setTimeout(() => layer.remove(), 2000);
        }

        function createPopcornPop(element) {
            const origin = getOriginFromElement(element);
            const layer = createCelebrationLayer();
            const count = 8;
            for (let i = 0; i < count; i++) {
                const el = document.createElement('span');
                el.textContent = 'ðŸ¿';
                el.style.cssText = `position:absolute; left:${origin.x}px; top:${origin.y}px; font-size:${20 + Math.random() * 10}px;`;
                layer.appendChild(el);
                const dx = (Math.random() * 200 - 100);
                const dy = - (120 + Math.random() * 120);
                const duration = 900 + Math.random() * 400;
                if (typeof gsap !== 'undefined') {
                    gsap.fromTo(el, { x: 0, y: 0, scale: 0.8, opacity: 1 }, { x: dx, y: dy, scale: 1.1, opacity: 0, duration: duration / 1000, ease: 'back.out(1.4)' });
                } else {
                    animateWithRAF(duration, (e) => {
                        el.style.transform = `translate(${dx * e}px, ${dy * e}px) scale(${0.8 + 0.3 * e})`;
                        el.style.opacity = String(1 - e);
                    });
                }
            }
            setTimeout(() => layer.remove(), 1600);
        }

        function createAirplaneTakeoff(element) {
            const origin = getOriginFromElement(element);
            const layer = createCelebrationLayer();
            const plane = document.createElement('span');
            plane.textContent = 'âœˆï¸';
            plane.style.cssText = `position:absolute; left:${origin.x}px; top:${origin.y}px; font-size:56px;`;
            layer.appendChild(plane);
            const dx = 320, dy = -180;
            const duration = 1200;
            if (typeof gsap !== 'undefined') {
                gsap.fromTo(plane, { x: 0, y: 0, rotation: -10, opacity: 1 }, { x: dx, y: dy, rotation: -10, opacity: 0.8, duration: duration / 1000, ease: 'power2.out' });
            } else {
                animateWithRAF(duration, (e) => {
                    plane.style.transform = `translate(${dx * e}px, ${dy * e}px) rotate(-10deg)`;
                    plane.style.opacity = String(0.5 + 0.5 * e);
                });
            }
            for (let i = 0; i < 5; i++) {
                const cloud = document.createElement('span');
                cloud.textContent = 'â˜ï¸';
                cloud.style.cssText = `position:absolute; left:${origin.x - 20}px; top:${origin.y + 10}px; font-size:${26 + Math.random() * 10}px;`;
                layer.appendChild(cloud);
                const cdx = - (30 + Math.random() * 40);
                const cdy = - (20 + Math.random() * 30);
                const dur = 1200 + Math.random() * 500;
                if (typeof gsap !== 'undefined') {
                    gsap.fromTo(cloud, { x: 0, y: 0, opacity: 0.8 }, { x: cdx, y: cdy, opacity: 0, duration: dur / 1000, ease: 'sine.out' });
                } else {
                    animateWithRAF(dur, (e) => {
                        cloud.style.transform = `translate(${cdx * e}px, ${cdy * e}px)`;
                        cloud.style.opacity = String(0.8 - 0.8 * e);
                    });
                }
            }
            setTimeout(() => layer.remove(), 1800);
        }

        function createTrophyShine(element) {
            const origin = getOriginFromElement(element);
            const layer = createCelebrationLayer();
            const trophy = document.createElement('span');
            trophy.textContent = 'ðŸ†';
            trophy.style.cssText = `position:absolute; left:${origin.x}px; top:${origin.y}px; font-size:72px;`;
            layer.appendChild(trophy);
            const duration = 900;
            if (typeof gsap !== 'undefined') {
                gsap.fromTo(trophy, { scale: 0, opacity: 0 }, { scale: 1.1, opacity: 1, duration: duration / 1000, ease: 'back.out(1.8)' });
                gsap.to(trophy, { scale: 1, duration: 0.2, delay: duration / 1000 });
            } else {
                animateWithRAF(duration, (e) => {
                    trophy.style.transform = `translate(-36px, -36px) scale(${e * 1.1})`;
                    trophy.style.opacity = String(e);
                });
            }
            for (let i = 0; i < 6; i++) {
                const sparkle = document.createElement('span');
                sparkle.textContent = 'âœ¨';
                sparkle.style.cssText = `position:absolute; left:${origin.x}px; top:${origin.y}px; font-size:${16 + Math.random() * 10}px;`;
                layer.appendChild(sparkle);
                const angle = Math.random() * Math.PI * 2;
                const dist = 80 + Math.random() * 60;
                const dx = Math.cos(angle) * dist;
                const dy = Math.sin(angle) * dist - 20;
                const dur = 900 + Math.random() * 300;
                if (typeof gsap !== 'undefined') {
                    gsap.fromTo(sparkle, { x: 0, y: 0, opacity: 0 }, { x: dx, y: dy, opacity: 1, duration: dur / 1000, ease: 'sine.out' });
                } else {
                    animateWithRAF(dur, (e) => {
                        sparkle.style.transform = `translate(${dx * e}px, ${dy * e}px)`;
                        sparkle.style.opacity = String(e);
                    });
                }
            }
            setTimeout(() => layer.remove(), 1600);
        }

        // New animations for more letters
        function createDrumRoll(element) {
            const origin = getOriginFromElement(element);
            const layer = createCelebrationLayer();
            for (let i = 0; i < 2; i++) {
                const drum = document.createElement('span');
                drum.textContent = i === 0 ? 'ðŸ¥' : 'ðŸŽµ';
                drum.style.cssText = `position:absolute; left:${origin.x - 24 + i * 36}px; top:${origin.y}px; font-size:48px;`;
                layer.appendChild(drum);
                const duration = 900 + i * 100;
                if (typeof gsap !== 'undefined') {
                    gsap.fromTo(drum, { y: 0, scale: 0.8, opacity: 0.9 }, { y: -60, scale: 1.1, opacity: 0, duration: duration / 1000, ease: 'back.out(1.5)' });
                } else {
                    animateWithRAF(duration, (e) => {
                        drum.style.transform = `translate(0px, ${-60 * e}px) scale(${0.8 + 0.3 * e})`;
                        drum.style.opacity = String(0.9 - 0.9 * e);
                    });
                }
            }
            setTimeout(() => layer.remove(), 1400);
        }

        function createFireworksBurst(element) {
            const origin = getOriginFromElement(element);
            const layer = createCelebrationLayer();
            const colors = ['ðŸŽ†', 'ðŸŽ‡', 'âœ¨'];
            for (let i = 0; i < 3; i++) {
                const fw = document.createElement('span');
                fw.textContent = colors[i % colors.length];
                fw.style.cssText = `position:absolute; left:${origin.x}px; top:${origin.y}px; font-size:${50 + i * 8}px;`;
                layer.appendChild(fw);
                const dx = (i - 1) * 140;
                const dy = -120 - i * 20;
                const duration = 1000 + i * 150;
                if (typeof gsap !== 'undefined') {
                    gsap.fromTo(fw, { x: 0, y: 0, scale: 0.4, opacity: 0.8 }, { x: dx, y: dy, scale: 1, opacity: 0, duration: duration / 1000, ease: 'power2.out' });
                } else {
                    animateWithRAF(duration, (e) => {
                        fw.style.transform = `translate(${dx * e}px, ${dy * e}px) scale(${0.4 + 0.6 * e})`;
                        fw.style.opacity = String(0.8 - 0.8 * e);
                    });
                }
            }
            setTimeout(() => layer.remove(), 1700);
        }

        function createGuitarStrum(element) {
            const origin = getOriginFromElement(element);
            const layer = createCelebrationLayer();
            const guitar = document.createElement('span');
            guitar.textContent = 'ðŸŽ¸';
            guitar.style.cssText = `position:absolute; left:${origin.x}px; top:${origin.y}px; font-size:56px;`;
            layer.appendChild(guitar);
            const duration = 900;
            if (typeof gsap !== 'undefined') {
                gsap.fromTo(guitar, { rotation: -15, scale: 0.9, opacity: 1 }, { rotation: 15, scale: 1.1, opacity: 0.9, duration: duration / 1000, ease: 'sine.inOut', yoyo: true, repeat: 1 });
            } else {
                animateWithRAF(duration, (e) => {
                    const angle = -15 + 30 * e;
                    guitar.style.transform = `translate(-28px, -28px) rotate(${angle}deg) scale(${0.9 + 0.2 * e})`;
                });
            }
            for (let i = 0; i < 6; i++) {
                const note = document.createElement('span');
                note.textContent = ['ðŸŽµ','ðŸŽ¶'][i % 2];
                note.style.cssText = `position:absolute; left:${origin.x}px; top:${origin.y}px; font-size:${18 + Math.random() * 10}px;`;
                layer.appendChild(note);
                const dx = (Math.random() * 160 - 80);
                const dy = - (80 + Math.random() * 120);
                const dur = 1000 + Math.random() * 400;
                if (typeof gsap !== 'undefined') {
                    gsap.fromTo(note, { x: 0, y: 0, opacity: 1 }, { x: dx, y: dy, opacity: 0, duration: dur / 1000, ease: 'power2.out' });
                } else {
                    animateWithRAF(dur, (e) => {
                        note.style.transform = `translate(${dx * e}px, ${dy * e}px)`;
                        note.style.opacity = String(1 - e);
                    });
                }
            }
            setTimeout(() => layer.remove(), 1700);
        }

        function createHeartsRain(element) {
            const origin = getOriginFromElement(element);
            const layer = createCelebrationLayer();
            const count = 10;
            for (let i = 0; i < count; i++) {
                const heart = document.createElement('span');
                heart.textContent = i % 2 === 0 ? 'â¤ï¸' : 'ðŸ’–';
                heart.style.cssText = `position:absolute; left:${origin.x + (Math.random()*160-80)}px; top:${origin.y - 120}px; font-size:${20 + Math.random() * 16}px;`;
                layer.appendChild(heart);
                const dy = 200 + Math.random() * 120;
                const duration = 1200 + Math.random() * 500;
                if (typeof gsap !== 'undefined') {
                    gsap.fromTo(heart, { y: -40, opacity: 0.9 }, { y: dy, opacity: 0, duration: duration / 1000, ease: 'sine.in' });
                } else {
                    animateWithRAF(duration, (e) => {
                        heart.style.transform = `translate(0px, ${(-40 + dy * e)}px)`;
                        heart.style.opacity = String(0.9 - 0.9 * e);
                    });
                }
            }
            setTimeout(() => layer.remove(), 1900);
        }

        function createIceSparkle(element) {
            const origin = getOriginFromElement(element);
            const layer = createCelebrationLayer();
            for (let i = 0; i < 8; i++) {
                const ice = document.createElement('span');
                ice.textContent = i % 2 === 0 ? 'â„ï¸' : 'âœ¨';
                ice.style.cssText = `position:absolute; left:${origin.x}px; top:${origin.y}px; font-size:${18 + Math.random() * 12}px;`;
                layer.appendChild(ice);
                const angle = Math.random() * Math.PI * 2;
                const dist = 120 + Math.random() * 80;
                const dx = Math.cos(angle) * dist;
                const dy = Math.sin(angle) * dist;
                const duration = 1100 + Math.random() * 300;
                if (typeof gsap !== 'undefined') {
                    gsap.fromTo(ice, { x: 0, y: 0, opacity: 1 }, { x: dx, y: dy, opacity: 0, duration: duration / 1000, ease: 'power1.out' });
                } else {
                    animateWithRAF(duration, (e) => {
                        ice.style.transform = `translate(${dx * e}px, ${dy * e}px)`;
                        ice.style.opacity = String(1 - e);
                    });
                }
            }
            setTimeout(() => layer.remove(), 1600);
        }

        function createJellyfishFloat(element) {
            const origin = getOriginFromElement(element);
            const layer = createCelebrationLayer();
            const jelly = document.createElement('span');
            jelly.textContent = 'ðŸª¼';
            jelly.style.cssText = `position:absolute; left:${origin.x}px; top:${origin.y}px; font-size:56px;`;
            layer.appendChild(jelly);
            const dx = (Math.random() * 80 - 40);
            const dy = -160;
            const duration = 1600;
            if (typeof gsap !== 'undefined') {
                gsap.fromTo(jelly, { x: 0, y: 0, opacity: 1 }, { x: dx, y: dy, opacity: 0, duration: duration / 1000, ease: 'sine.out' });
            } else {
                animateWithRAF(duration, (e) => {
                    const bob = Math.sin(e * Math.PI * 4) * 10;
                    jelly.style.transform = `translate(${dx * e}px, ${dy * e + bob}px)`;
                    jelly.style.opacity = String(1 - e);
                });
            }
            setTimeout(() => layer.remove(), 1700);
        }

        function createKiteSoar(element) {
            const origin = getOriginFromElement(element);
            const layer = createCelebrationLayer();
            const kite = document.createElement('span');
            kite.textContent = 'ðŸª';
            kite.style.cssText = `position:absolute; left:${origin.x}px; top:${origin.y}px; font-size:56px;`;
            layer.appendChild(kite);
            const dx = 260, dy = -180;
            const duration = 1400;
            if (typeof gsap !== 'undefined') {
                gsap.fromTo(kite, { x: 0, y: 0, rotation: -10, opacity: 1 }, { x: dx, y: dy, rotation: 10, opacity: 0.9, duration: duration / 1000, ease: 'sine.inOut' });
            } else {
                animateWithRAF(duration, (e) => {
                    const sway = Math.sin(e * Math.PI * 2) * 10;
                    kite.style.transform = `translate(${dx * e}px, ${dy * e}px) rotate(${(-10 + 20 * e)}deg)`;
                    kite.style.opacity = String(0.8 + 0.2 * e);
                });
            }
            setTimeout(() => layer.remove(), 1700);
        }

        function createMagicWand(element) {
            const origin = getOriginFromElement(element);
            const layer = createCelebrationLayer();
            const wand = document.createElement('span');
            wand.textContent = 'ðŸª„';
            wand.style.cssText = `position:absolute; left:${origin.x}px; top:${origin.y}px; font-size:52px;`;
            layer.appendChild(wand);
            const duration = 800;
            if (typeof gsap !== 'undefined') {
                gsap.fromTo(wand, { scale: 0, rotation: -20, opacity: 0 }, { scale: 1, rotation: 0, opacity: 1, duration: duration / 1000, ease: 'back.out(1.7)' });
            } else {
                animateWithRAF(duration, (e) => {
                    wand.style.transform = `translate(-26px, -26px) rotate(${-20 + 20 * e}deg) scale(${e})`;
                    wand.style.opacity = String(e);
                });
            }
            for (let i = 0; i < 8; i++) {
                const spark = document.createElement('span');
                spark.textContent = 'âœ¨';
                spark.style.cssText = `position:absolute; left:${origin.x}px; top:${origin.y}px; font-size:${14 + Math.random() * 10}px;`;
                layer.appendChild(spark);
                const angle = Math.random() * Math.PI * 2;
                const dist = 120 + Math.random() * 60;
                const dx = Math.cos(angle) * dist;
                const dy = Math.sin(angle) * dist;
                const dur = 900 + Math.random() * 300;
                if (typeof gsap !== 'undefined') {
                    gsap.fromTo(spark, { x: 0, y: 0, opacity: 0 }, { x: dx, y: dy, opacity: 1, duration: dur / 1000, ease: 'sine.out' });
                } else {
                    animateWithRAF(dur, (e) => {
                        spark.style.transform = `translate(${dx * e}px, ${dy * e}px)`;
                        spark.style.opacity = String(e);
                    });
                }
            }
            setTimeout(() => layer.remove(), 1600);
        }

        function createNightSky(element) {
            const origin = getOriginFromElement(element);
            const layer = createCelebrationLayer();
            const moon = document.createElement('span');
            moon.textContent = 'ðŸŒ™';
            moon.style.cssText = `position:absolute; left:${origin.x}px; top:${origin.y}px; font-size:64px;`;
            layer.appendChild(moon);
            const duration = 1200;
            if (typeof gsap !== 'undefined') {
                gsap.fromTo(moon, { y: 0, opacity: 0.8 }, { y: -120, opacity: 1, duration: duration / 1000, ease: 'sine.out' });
            } else {
                animateWithRAF(duration, (e) => {
                    moon.style.transform = `translate(0px, ${-120 * e}px)`;
                    moon.style.opacity = String(0.8 + 0.2 * e);
                });
            }
            for (let i = 0; i < 8; i++) {
                const star = document.createElement('span');
                star.textContent = 'â­';
                star.style.cssText = `position:absolute; left:${origin.x + (Math.random()*200-100)}px; top:${origin.y - 120 + (Math.random()*60-30)}px; font-size:${14 + Math.random() * 10}px;`;
                layer.appendChild(star);
                const dur = 1000 + Math.random() * 400;
                if (typeof gsap !== 'undefined') {
                    gsap.fromTo(star, { opacity: 0 }, { opacity: 1, duration: dur / 1000, ease: 'sine.inOut', yoyo: true, repeat: 1 });
                } else {
                    animateWithRAF(dur, (e) => {
                        star.style.opacity = String(e < 0.5 ? e * 2 : (1 - (e - 0.5) * 2));
                    });
                }
            }
            setTimeout(() => layer.remove(), 1800);
        }

        function createQueenCrown(element) {
            const origin = getOriginFromElement(element);
            const layer = createCelebrationLayer();
            const crown = document.createElement('span');
            crown.textContent = 'ðŸ‘‘';
            crown.style.cssText = `position:absolute; left:${origin.x}px; top:${origin.y}px; font-size:64px;`;
            layer.appendChild(crown);
            const duration = 800;
            if (typeof gsap !== 'undefined') {
                gsap.fromTo(crown, { scale: 0, opacity: 0 }, { scale: 1, opacity: 1, duration: duration / 1000, ease: 'back.out(1.7)' });
            } else {
                animateWithRAF(duration, (e) => {
                    crown.style.transform = `translate(-32px, -32px) scale(${e})`;
                    crown.style.opacity = String(e);
                });
            }
            for (let i = 0; i < 6; i++) {
                const sparkle = document.createElement('span');
                sparkle.textContent = 'âœ¨';
                sparkle.style.cssText = `position:absolute; left:${origin.x}px; top:${origin.y}px; font-size:${16 + Math.random() * 8}px;`;
                layer.appendChild(sparkle);
                const angle = Math.random() * Math.PI * 2;
                const dist = 90 + Math.random() * 50;
                const dx = Math.cos(angle) * dist;
                const dy = Math.sin(angle) * dist;
                const dur = 900 + Math.random() * 300;
                if (typeof gsap !== 'undefined') {
                    gsap.fromTo(sparkle, { x: 0, y: 0, opacity: 0 }, { x: dx, y: dy, opacity: 1, duration: dur / 1000, ease: 'sine.out' });
                } else {
                    animateWithRAF(dur, (e) => {
                        sparkle.style.transform = `translate(${dx * e}px, ${dy * e}px)`;
                        sparkle.style.opacity = String(e);
                    });
                }
            }
            setTimeout(() => layer.remove(), 1600);
        }

        function createUmbrellaSprinkle(element) {
            const origin = getOriginFromElement(element);
            const layer = createCelebrationLayer();
            const umbrella = document.createElement('span');
            umbrella.textContent = 'â˜”';
            umbrella.style.cssText = `position:absolute; left:${origin.x}px; top:${origin.y}px; font-size:56px;`;
            layer.appendChild(umbrella);
            const duration = 1000;
            if (typeof gsap !== 'undefined') {
                gsap.fromTo(umbrella, { y: 0, opacity: 1 }, { y: -20, opacity: 1, duration: duration / 1000, ease: 'sine.inOut' });
            } else {
                animateWithRAF(duration, (e) => {
                    umbrella.style.transform = `translate(0px, ${-20 * e}px)`;
                });
            }
            for (let i = 0; i < 10; i++) {
                const drop = document.createElement('span');
                drop.textContent = 'ðŸ’§';
                drop.style.cssText = `position:absolute; left:${origin.x + (Math.random()*120-60)}px; top:${origin.y - 20}px; font-size:${14 + Math.random() * 8}px;`;
                layer.appendChild(drop);
                const dy = 140 + Math.random() * 100;
                const dur = 900 + Math.random() * 300;
                if (typeof gsap !== 'undefined') {
                    gsap.fromTo(drop, { y: 0, opacity: 1 }, { y: dy, opacity: 0, duration: dur / 1000, ease: 'sine.in' });
                } else {
                    animateWithRAF(dur, (e) => {
                        drop.style.transform = `translate(0px, ${dy * e}px)`;
                        drop.style.opacity = String(1 - e);
                    });
                }
            }
            setTimeout(() => layer.remove(), 1600);
        }

        function createVictoryV(element) {
            const origin = getOriginFromElement(element);
            const layer = createCelebrationLayer();
            const v = document.createElement('span');
            v.textContent = 'âœŒï¸';
            v.style.cssText = `position:absolute; left:${origin.x}px; top:${origin.y}px; font-size:64px;`;
            layer.appendChild(v);
            const duration = 900;
            if (typeof gsap !== 'undefined') {
                gsap.fromTo(v, { scale: 0, opacity: 0 }, { scale: 1.1, opacity: 1, duration: duration / 1000, ease: 'back.out(1.7)' });
                gsap.to(v, { scale: 1, duration: 0.2, delay: duration / 1000 });
            } else {
                animateWithRAF(duration, (e) => {
                    v.style.transform = `translate(-32px, -32px) scale(${e * 1.1})`;
                    v.style.opacity = String(e);
                });
            }
            for (let i = 0; i < 6; i++) {
                const sparkle = document.createElement('span');
                sparkle.textContent = 'âœ¨';
                sparkle.style.cssText = `position:absolute; left:${origin.x}px; top:${origin.y}px; font-size:${14 + Math.random() * 8}px;`;
                layer.appendChild(sparkle);
                const angle = Math.random() * Math.PI * 2;
                const dist = 80 + Math.random() * 50;
                const dx = Math.cos(angle) * dist;
                const dy = Math.sin(angle) * dist - 20;
                const dur = 900 + Math.random() * 300;
                if (typeof gsap !== 'undefined') {
                    gsap.fromTo(sparkle, { x: 0, y: 0, opacity: 0 }, { x: dx, y: dy, opacity: 1, duration: dur / 1000, ease: 'sine.out' });
                } else {
                    animateWithRAF(dur, (e) => {
                        sparkle.style.transform = `translate(${dx * e}px, ${dy * e}px)`;
                        sparkle.style.opacity = String(e);
                    });
                }
            }
            setTimeout(() => layer.remove(), 1600);
        }

        function createWaveSplash(element) {
            const origin = getOriginFromElement(element);
            const layer = createCelebrationLayer();
            const wave = document.createElement('span');
            wave.textContent = 'ðŸŒŠ';
            wave.style.cssText = `position:absolute; left:${origin.x}px; top:${origin.y}px; font-size:64px;`;
            layer.appendChild(wave);
            const dx = 220, dy = -40;
            const duration = 1100;
            if (typeof gsap !== 'undefined') {
                gsap.fromTo(wave, { x: 0, y: 0, rotation: 0, opacity: 1 }, { x: dx, y: dy, rotation: 0, opacity: 0.9, duration: duration / 1000, ease: 'sine.inOut' });
            } else {
                animateWithRAF(duration, (e) => {
                    const roll = Math.sin(e * Math.PI * 2) * 6;
                    wave.style.transform = `translate(${dx * e}px, ${dy * e}px) rotate(${roll}deg)`;
                    wave.style.opacity = String(0.8 + 0.2 * e);
                });
            }
            for (let i = 0; i < 5; i++) {
                const splash = document.createElement('span');
                splash.textContent = 'ðŸ’¦';
                splash.style.cssText = `position:absolute; left:${origin.x}px; top:${origin.y}px; font-size:${18 + Math.random() * 8}px;`;
                layer.appendChild(splash);
                const angle = -Math.PI / 2 + (Math.random() * 0.8 - 0.4);
                const dist = 120 + Math.random() * 60;
                const dx2 = Math.cos(angle) * dist;
                const dy2 = Math.sin(angle) * dist;
                const dur = 900 + Math.random() * 300;
                if (typeof gsap !== 'undefined') {
                    gsap.fromTo(splash, { x: 0, y: 0, opacity: 1 }, { x: dx2, y: dy2, opacity: 0, duration: dur / 1000, ease: 'power1.out' });
                } else {
                    animateWithRAF(dur, (e) => {
                        splash.style.transform = `translate(${dx2 * e}px, ${dy2 * e}px)`;
                        splash.style.opacity = String(1 - e);
                    });
                }
            }
            setTimeout(() => layer.remove(), 1700);
        }

        function createYoYoBounce(element) {
            const origin = getOriginFromElement(element);
            const layer = createCelebrationLayer();
            const yoyo = document.createElement('span');
            yoyo.textContent = 'ðŸª€';
            yoyo.style.cssText = `position:absolute; left:${origin.x}px; top:${origin.y}px; font-size:56px;`;
            layer.appendChild(yoyo);
            const dy = 140;
            const duration = 900;
            if (typeof gsap !== 'undefined') {
                gsap.fromTo(yoyo, { y: 0, opacity: 1 }, { y: dy, opacity: 0.9, duration: duration / 1000, ease: 'bounce.out' });
            } else {
                animateWithRAF(duration, (e) => {
                    const bounce = Math.sin(e * Math.PI) * dy;
                    yoyo.style.transform = `translate(0px, ${bounce}px)`;
                });
            }
            setTimeout(() => layer.remove(), 1300);
        }

        function createZoomRocket(element) {
            const origin = getOriginFromElement(element);
            const layer = createCelebrationLayer();
            const rocket = document.createElement('span');
            rocket.textContent = 'ðŸš€';
            rocket.style.cssText = `position:absolute; left:${origin.x}px; top:${origin.y}px; font-size:56px;`;
            layer.appendChild(rocket);
            const dx = 280, dy = -220;
            const duration = 1100;
            if (typeof gsap !== 'undefined') {
                gsap.fromTo(rocket, { x: 0, y: 0, rotation: -20, opacity: 1 }, { x: dx, y: dy, rotation: -20, opacity: 0.9, duration: duration / 1000, ease: 'power2.out' });
            } else {
                animateWithRAF(duration, (e) => {
                    rocket.style.transform = `translate(${dx * e}px, ${dy * e}px) rotate(-20deg)`;
                    rocket.style.opacity = String(0.8 + 0.2 * e);
                });
            }
            for (let i = 0; i < 6; i++) {
                const flame = document.createElement('span');
                flame.textContent = 'ðŸ”¥';
                flame.style.cssText = `position:absolute; left:${origin.x - 12}px; top:${origin.y + 12}px; font-size:${16 + Math.random() * 8}px;`;
                layer.appendChild(flame);
                const dx2 = - (40 + Math.random() * 40);
                const dy2 = (20 + Math.random() * 40);
                const dur = 800 + Math.random() * 300;
                if (typeof gsap !== 'undefined') {
                    gsap.fromTo(flame, { x: 0, y: 0, opacity: 0.9 }, { x: dx2, y: dy2, opacity: 0, duration: dur / 1000, ease: 'power1.out' });
                } else {
                    animateWithRAF(dur, (e) => {
                        flame.style.transform = `translate(${dx2 * e}px, ${dy2 * e}px)`;
                        flame.style.opacity = String(0.9 - 0.9 * e);
                    });
                }
            }
            setTimeout(() => layer.remove(), 1700);
        }

        function createWrongEffect() {
            // Create a red flash effect
            const flash = document.createElement('div');
            flash.style.position = 'fixed';
            flash.style.top = '0';
            flash.style.left = '0';
            flash.style.width = '100%';
            flash.style.height = '100%';
            flash.style.background = 'rgba(239, 68, 68, 0.2)';
            flash.style.pointerEvents = 'none';
            flash.style.zIndex = '999';
            flash.style.animation = 'fadeIn 0.3s';
            document.body.appendChild(flash);

            setTimeout(() => {
                if (flash.parentNode) {
                    flash.parentNode.removeChild(flash);
                }
            }, 300);
        }

        function setMode(mode, buttonEl) {
            if (currentMode === mode) return;
            currentMode = mode;

            document.querySelectorAll('.mode-btn').forEach(btn => {
                btn.classList.remove('active');
                btn.setAttribute('aria-pressed', 'false');
            });
            if (buttonEl) {
                buttonEl.classList.add('active');
                buttonEl.setAttribute('aria-pressed', 'true');
            }

            clearAllTimers();
            cancelSpeech();
            waitingForPhonics = false;

            if (mode === 'identify') {
                startIdentifyGame(true);
            } else {
                startDrawGame();
            }
        }

        function startIdentifyGame(resetRound = false) {
            // In multiplayer mode, require a player to be selected
            if (multiplayerMode && !currentPlayer) {
                const gameArea = document.getElementById('gameArea');
                gameArea.innerHTML = `
                    <div class="start-screen" style="text-align:center; padding: 24px;">
                        <h2 style="margin-bottom:8px;">Select a Player!</h2>
                        <p>Tap on a player at the top to begin.</p>
                    </div>
                `;
                const selector = document.getElementById('playerSelector');
                if (selector) {
                    selector.style.transition = 'background-color 0.3s';
                    selector.style.backgroundColor = 'rgba(168, 85, 247, 0.2)';
                    setTimeout(() => { selector.style.backgroundColor = ''; }, 600);
                }
                return;
            }
            // Only reset counters when explicitly starting a new round/mode
            if (resetRound) {
                roundCorrect = 0;
                roundWrong = 0;
                responseTimes = [];
                scoreAtRoundStart = currentPlayer ? currentPlayer.score : score;
            }
            if (waitingForPhonics) return;
            isAnswering = false;

            clearAllTimers();
            cancelSpeech();

            currentLetter = getRandomLetter();
            const letters = (currentLetter === currentLetter.toLowerCase()) ? lowerLetters : upperLetters; // distractors in same case as target
            const options = [currentLetter];

            // Generate 3 different options from a filtered pool
            const letterPool = letters.filter(l => l !== currentLetter);
            while (options.length < 4) {
                const letter = letterPool[Math.floor(Math.random() * letterPool.length)];
                if (!options.includes(letter)) {
                    options.push(letter);
                }
            }

            // Shuffle options
            options.sort(() => Math.random() - 0.5);

            const gameArea = document.getElementById('gameArea');

            // Add visual theme enhancements
            let optionsHTML = '';
            if (currentTheme === 'colors') {
                // Color code vowels vs consonants
                optionsHTML = options.map(letter => {
                    const isVowel = 'aeiouAEIOU'.includes(letter);
                    const highlightClass = isVowel ? 'vowel-highlight' : 'consonant-highlight';
                    return `<button class="option-btn" data-letter="${letter}" onclick="checkAnswer('${letter}')" aria-label="Choose letter ${letter}"><span class="${highlightClass}">${letter}</span></button>`;
                }).join('');
            } else if (currentTheme === 'animals') {
                // Show with associations
                optionsHTML = options.map(letter =>
                    `<button class="option-btn" data-letter="${letter}" onclick="checkAnswer('${letter}')" style="position: relative;" aria-label="Choose letter ${letter}">
                        ${letter}
                        ${letter.toLowerCase() === currentLetter.toLowerCase() ?
                        `<div class="letter-association">
                                <span class="association-icon">${letterAssociations[letter.toLowerCase()]?.icon || 'â­'}</span>
                                <span>${letterAssociations[letter.toLowerCase()]?.word || letter}</span>
                            </div>` : ''}
                    </button>`
                ).join('');
            } else {
                // Classic mode
                optionsHTML = options.map(letter =>
                    `<button class="option-btn" data-letter="${letter}" onclick="checkAnswer('${letter}')" aria-label="Choose letter ${letter}">${letter}</button>`
                ).join('');
            }

            gameArea.innerHTML = `
                <div class="instruction">Tap the speaker, then find the letter!</div>
                <div class="options">${optionsHTML}</div>
                <button class="sound-btn" id="soundBtn" onclick="playCurrentLetter()" aria-label="Play the current letter sound">ðŸ”Š</button>
                ${voiceRecordingEnabled ? getVoiceRecorderHTML() : ''}
            `;
            // Reserve space so the floating sound button doesn't overlap content
            gameArea.classList.add('with-sound');

            document.getElementById('scorePanel').style.display = 'flex';
            updateScoreDisplay();

            questionStartTime = Date.now();
            startTimer();

            // Automatically play the letter sound with natural pacing
            const thisQuestionLetter = currentLetter;
            const letterNameSpoken = letterNamePronunciations[thisQuestionLetter.toLowerCase()] || thisQuestionLetter;
            speakPromptTimeout = setTimeout(() => {
                const afterPrompt = () => {
                    speakLetterTimeout = setTimeout(() => {
                        speakLetter(thisQuestionLetter);
                    }, 1000);
                };
                if (currentTheme === 'animals' && letterAssociations[thisQuestionLetter.toLowerCase()]) {
                    const assoc = letterAssociations[thisQuestionLetter.toLowerCase()];
                    speakPhrase(`Find the letter ${letterNameSpoken} for ${assoc.word}.`, afterPrompt);
                } else {
                    speakPhrase(`Find the letter ${letterNameSpoken}.`, afterPrompt);
                }
            }, 300);
        }

        function getVoiceRecorderHTML() {
            return `
                <div class="voice-recorder">
                    <button class="record-button" id="recordBtn" onclick="toggleRecording()" aria-label="Start recording">
                        <span id="recordIcon">ðŸŽ¤</span>
                    </button>
                    <div class="voice-controls">
                        <button class="voice-btn" onclick="playLastRecording()" id="playBtn" disabled aria-label="Play last recording">
                            <span>â–¶ï¸</span>
                            <span>Play</span>
                        </button>
                        <button class="voice-btn" onclick="compareWithCorrect()" id="compareBtn" disabled aria-label="Compare with correct pronunciation">
                            <span>ðŸŽ™ï¸</span>
                            <span>Compare</span>
                        </button>
                    </div>
                </div>
            `;
        }

        function playCurrentLetter() {
            const soundBtn = document.getElementById('soundBtn');
            soundBtn.classList.add('playing');
            // Subtle press animation
            if (typeof gsap !== 'undefined') {
                gsap.fromTo(soundBtn, { scale: 1 }, { scale: 0.95, duration: 0.2, yoyo: true, repeat: 1, ease: 'power2.inOut' });
            }
            speakLetter(currentLetter, () => {
                soundBtn.classList.remove('playing');
            });
        }

        function checkAnswer(letter) {
            if (waitingForPhonics || isAnswering || isProcessing) return;
            // Disable all buttons immediately to prevent rapid double clicks
            document.querySelectorAll('.option-btn').forEach(btn => btn.style.pointerEvents = 'none');
            clearTimer();
            isAnswering = true;
            isProcessing = true;

            const clickedButton = document.querySelector(`.option-btn[data-letter="${letter}"]`);

            if (letter === currentLetter) {
                clickedButton.classList.add('correct');
                createLetterCelebration(currentLetter, clickedButton);
                roundCorrect++;
                correctAnswers++;
                const responseTime = (Date.now() - questionStartTime) / 1000;
                responseTimes.push(responseTime);
                totalQuestions++;

                // Update correct answer streak
                correctStreak++;
                if (correctStreak > bestStreak) {
                    bestStreak = correctStreak;
                }

                // Check streak achievements
                checkAchievement('streak', correctStreak);

                // Dynamic scoring: base and time bonus with per-round cap
                const base = 10 + (difficultyLevel * 5);
                const bonus = Math.max(0, 30 - responseTime * 3);
                let points = Math.floor(base + bonus);
                const gainedThisRound = Math.max(0, (currentPlayer ? currentPlayer.score : score) - scoreAtRoundStart);
                if (gainedThisRound + points > 50) {
                    points = Math.max(0, 50 - gainedThisRound);
                }
                score += points;

                // Check score achievements
                checkAchievement('score', score);
                checkAchievement('correct', correctAnswers);

                // Update letter performance with per-letter score
                updateLetterPerformance(currentLetter, true, responseTime, points);

                showFeedback(`Excellent! +${points} ðŸŽ‰`, 'success');

                // Use GSAP for celebration animation if available
                if (typeof gsap !== 'undefined') {
                    gsap.from(clickedButton, {
                        scale: 0.8,
                        duration: 0.5,
                        ease: "back.out(1.7)"
                    });
                }

                let showedExamples = false; // declared early so TTS callback can reference it
                speakPhrase('Excellent! That\'s correct!', () => {
                    const baseDelay = phonicsEnabled ? 1500 : 1200;
                    const extraDelay = (!phonicsEnabled && showedExamples) ? 300 : 0;
                    if (phonicsEnabled) {
                        if (phonicsPhaseTimeout) { clearTimeout(phonicsPhaseTimeout); phonicsPhaseTimeout = null; }
                        phonicsPhaseTimeout = setTimeout(() => { isProcessing = false; startPhonicsPhase(); }, baseDelay + extraDelay);
                    } else {
                        setTimeout(() => { isProcessing = false; startIdentifyGame(); }, baseDelay + extraDelay);
                        // Re-enable buttons only if not transitioning into phonics
                        setTimeout(() => {
                            document.querySelectorAll('.option-btn').forEach(btn => btn.style.pointerEvents = 'auto');
                        }, 1500);
                    }
                });

                // Occasionally show brief word examples once the child is doing well
                if (roundCorrect > 10 && Math.random() < 0.3) {
                    const key = currentLetter.toLowerCase();
                    const examples = letterWords[key];
                    if (examples && examples.length) {
                        showedExamples = true;
                        showWordExamples(currentLetter, examples);
                    }
                }

            } else {
                clickedButton.classList.add('wrong');
                roundWrong++;
                wrongAnswers++;
                totalQuestions++;
                score = Math.max(0, score - 10);
                trackLetterError(currentLetter);

                // Reset correct answer streak
                correctStreak = 0;

                // Update letter performance with penalty
                updateLetterPerformance(currentLetter, false, 0, -10);

                showFeedback('Try again! ðŸ’ª', 'error');
                createWrongEffect();
                speakPhrase('Not quite. Try again!');

                // Briefly highlight the correct answer to guide learning
                const correctButton = document.querySelector(`.option-btn[data-letter="${currentLetter}"]`);
                if (correctButton) {
                    correctButton.style.transition = 'transform 0.2s, background-color 0.2s';
                    correctButton.style.backgroundColor = '#a7f3d0';
                    correctButton.style.transform = 'scale(1.05)';
                    setTimeout(() => {
                        correctButton.style.backgroundColor = '';
                        correctButton.style.transform = '';
                    }, 1200);
                }

                setTimeout(() => {
                    clickedButton.classList.remove('wrong');
                    isAnswering = false;
                    isProcessing = false;
                    // Restart timer fresh for another attempt
                    startTimer();
                    // Re-enable buttons for retry
                    document.querySelectorAll('.option-btn').forEach(btn => btn.style.pointerEvents = 'auto');
                }, 1000);
            }

            updateScoreDisplay();
            checkRoundCompletion();
        }

        function startPhonicsPhase() {
            if (!phonicsEnabled) {
                // Skip phonics entirely when disabled
                waitingForPhonics = false;
                setTimeout(() => startIdentifyGame(), 300);
                return;
            }
            waitingForPhonics = true;
            phonicsRepeatCount = 0;
            if (phonicsEchoCleanup) { try { phonicsEchoCleanup(true); } catch (e) { } phonicsEchoCleanup = null; }
            clearTimer();
            cancelSpeech();

            const gameArea = document.getElementById('gameArea');
            gameArea.innerHTML = `
                <div class="phonics-phase">
                    <div class="phonics-instruction">What sound does "${currentLetter}" make?</div>
                    <div class="phonics-timer" id="phonicsTimer">3</div>
                    <div class="phonics-letter">${currentLetter}</div>
                    <button class="phonics-skip" onclick="skipPhonics()" aria-label="Skip phonics">Skip â†’</button>
                </div>
            `;
            // Speak the prompt for non-readers, then start the countdown
            const promptName = letterNamePronunciations[currentLetter.toLowerCase()] || currentLetter;
            let timeLeft = 3;
            const timerElement = document.getElementById('phonicsTimer');

            // Allow skipping phonics by tapping anywhere in the game area
            const skipPhonicsHandler = () => {
                if (!waitingForPhonics) return;
                waitingForPhonics = false;
                if (phonicsTimer) { clearTimeout(phonicsTimer); phonicsTimer = null; }
                gameArea.removeEventListener('click', skipPhonicsHandler);
                startIdentifyGame();
            };
            gameArea.addEventListener('click', skipPhonicsHandler);

            function updatePhonicsTimer() {
                timeLeft--;
                if (timeLeft > 0) {
                    timerElement.textContent = timeLeft;
                    phonicsTimer = setTimeout(updatePhonicsTimer, 1000);
                } else {
                    timerElement.innerHTML = 'ðŸ—£ï¸';  // Speaker icon for pronunciation phase
                    if (phonicsTimer) { clearTimeout(phonicsTimer); phonicsTimer = null; }
                    speakPhonetics(currentLetter, () => {
                        // Interactive echo step: mic-based when available, fallback repeat button otherwise
                        const phaseEl = gameArea.querySelector('.phonics-phase');
                        const canUseMic = !!voiceRecordingEnabled
                            && !!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia)
                            && (location.protocol === 'https:' || location.hostname === 'localhost' || location.hostname === '127.0.0.1');

                        // Keep phonics active during echo so skip still works
                        waitingForPhonics = true;

                        const finishEcho = (delayMs) => {
                            waitingForPhonics = false;
                            try { gameArea.removeEventListener('click', skipPhonicsHandler); } catch (e) { }
                            setTimeout(() => startIdentifyGame(), delayMs);
                            phonicsEchoCleanup = null;
                        };

                        function setupRepeatButton() {
                            const instructionEl = phaseEl ? phaseEl.querySelector('.phonics-instruction') : null;
                            if (instructionEl) instructionEl.textContent = 'Repeat after me!';
                            let repeatBtn = phaseEl ? phaseEl.querySelector('.phonics-repeat') : null;
                            if (!repeatBtn && phaseEl) {
                                repeatBtn = document.createElement('button');
                                repeatBtn.className = 'phonics-repeat';
                                repeatBtn.textContent = 'Repeat after me ðŸ”';
                                repeatBtn.setAttribute('aria-label', 'Repeat after me');
                                repeatBtn.onclick = () => {
                                    cancelSpeech();
                                    speakPhonetics(currentLetter);
                                    if (phonicsRepeatCount < 2) {
                                        phonicsRepeatCount++;
                                        score += 3;
                                        updateScoreDisplay();
                                        checkAchievement('score', score);
                                        showFeedback('Great repeating! +3', 'success');
                                    }
                                };
                                phaseEl.appendChild(repeatBtn);
                            }

                            phonicsEchoCleanup = () => {
                                if (repeatBtn && repeatBtn.parentNode) {
                                    repeatBtn.parentNode.removeChild(repeatBtn);
                                }
                            };

                            setTimeout(() => {
                                if (phonicsEchoCleanup) { try { phonicsEchoCleanup(); } catch (e) { } }
                                finishEcho(0);
                            }, 3500);
                        }

                        if (canUseMic) {
                            const instructionEl = phaseEl ? phaseEl.querySelector('.phonics-instruction') : null;
                            if (instructionEl) instructionEl.textContent = 'Your turn! Say it!';
                            let stopped = false;

                            navigator.mediaDevices.getUserMedia({ audio: true }).then(stream => {
                                const AudioCtx = window.AudioContext || window.webkitAudioContext;
                                const audioCtx = new AudioCtx();
                                const source = audioCtx.createMediaStreamSource(stream);
                                const analyser = audioCtx.createAnalyser();
                                analyser.fftSize = 2048;
                                source.connect(analyser);
                                const data = new Uint8Array(analyser.fftSize);

                                let speakingSince = null;
                                const startAt = performance.now();
                                const listenMs = 2200;

                                function stopAll() {
                                    if (stopped) return;
                                    stopped = true;
                                    try { stream.getTracks().forEach(t => t.stop()); } catch (e) { }
                                    try { audioCtx.close(); } catch (e) { }
                                }

                                function tick(now) {
                                    if (stopped) return;
                                    analyser.getByteTimeDomainData(data);
                                    let sum = 0;
                                    for (let i = 0; i < data.length; i++) {
                                        const v = (data[i] - 128) / 128;
                                        sum += v * v;
                                    }
                                    const rms = Math.sqrt(sum / data.length);
                                    const threshold = 0.08;

                                    if (rms > threshold) {
                                        if (speakingSince === null) speakingSince = now;
                                        if (now - speakingSince > 250) {
                                            stopAll();
                                            score += 5;
                                            updateScoreDisplay();
                                            checkAchievement('score', score);
                                            showFeedback('Nice echo! +5', 'success');
                                            finishEcho(800);
                                            return;
                                        }
                                    } else {
                                        speakingSince = null;
                                    }

                                    if (now - startAt < listenMs) {
                                        requestAnimationFrame(tick);
                                    } else {
                                        stopAll();
                                        finishEcho(800);
                                    }
                                }

                                phonicsEchoCleanup = () => { stopAll(); };
                                requestAnimationFrame(tick);
                            }).catch(() => {
                                // Fallback to button if mic fails
                                setupRepeatButton();
                            });
                        } else {
                            // No mic: show repeat button and track engagement
                            setupRepeatButton();
                        }
                    });
                }
            }

            // Start countdown only after the prompt finishes speaking (or immediately if speech is disabled)
            speakPhrase(`What sound does ${promptName} make?`, () => {
                if (!waitingForPhonics) return; // in case it was skipped
                phonicsTimer = setTimeout(updatePhonicsTimer, 1000);
            });
        }

        function skipPhonics() {
            const gameArea = document.getElementById('gameArea');
            if (!waitingForPhonics) return;
            waitingForPhonics = false;
            isProcessing = true;
            if (phonicsTimer) { window.clearTimeout(phonicsTimer); phonicsTimer = null; }
            if (phonicsEchoCleanup) { try { phonicsEchoCleanup(true); } catch (e) { } phonicsEchoCleanup = null; }
            if (gameArea) gameArea.onclick = null;
            startIdentifyGame();
        }

        // Settings controls
        function setPhonicsMode(mode) {
            phonicsEnabled = mode === 'on';
            try { localStorage.setItem('letterLearningPhonics', phonicsEnabled ? 'on' : 'off'); } catch (e) { }
            const onBtn = document.getElementById('phonicsOn');
            const offBtn = document.getElementById('phonicsOff');
            if (onBtn && offBtn) {
                onBtn.classList.toggle('active', phonicsEnabled);
                onBtn.setAttribute('aria-pressed', String(phonicsEnabled));
                offBtn.classList.toggle('active', !phonicsEnabled);
                offBtn.setAttribute('aria-pressed', String(!phonicsEnabled));
            }
        }

        function checkRoundCompletion() {
            if (waitingForPhonics || isProcessing) return;
            // Check if it's time for a mini-game break
            if (roundCorrect > 0 && roundCorrect % 10 === 0 && Math.random() < 0.5) {
                showMinigameAnnouncement();
            } else if (roundCorrect >= QUESTIONS_PER_ROUND) {
                showRoundCompletion();
            }
        }

        // Mini-game Functions
        function showMinigameAnnouncement() {
            clearAllTimers();
            cancelSpeech();

            const games = ['letterRain', 'memoryMatch'];
            const selectedGame = games[Math.floor(Math.random() * games.length)];

            const gameInfo = {
                letterRain: {
                    title: 'Letter Rain!',
                    subtitle: 'Catch the falling letters!',
                    icon: 'ðŸŒ§ï¸'
                },
                memoryMatch: {
                    title: 'Memory Match!',
                    subtitle: 'Match the letter pairs!',
                    icon: 'ðŸ§ '
                }
            };

            const info = gameInfo[selectedGame];

            const announcement = document.createElement('div');
            announcement.className = 'minigame-announcement';
            announcement.innerHTML = `
                <div class="minigame-announcement-icon">${info.icon}</div>
                <div class="minigame-announcement-title">${info.title}</div>
                <div class="minigame-announcement-subtitle">${info.subtitle}</div>
            `;

            document.body.appendChild(announcement);

            speakPhrase(`Time for a fun break! Let's play ${info.title}`);

            setTimeout(() => {
                announcement.remove();
                if (selectedGame === 'letterRain') {
                    startLetterRain();
                } else {
                    startMemoryMatch();
                }
            }, 3000);
        }

        function startLetterRain() {
            currentMinigame = 'letterRain';
            minigameScore = 0;
            const targetLetter = getRandomLetter();

            const gameArea = document.getElementById('gameArea');
            gameArea.innerHTML = `
                <div class="minigame-container">
                    <div class="minigame-header">
                        <div class="minigame-score">Score: <span id="minigameScore">0</span></div>
                        <div class="minigame-timer" id="minigameTimer">
                            <span>â±ï¸</span>
                            <span id="minigameTime">30</span>s
                        </div>
                    </div>
                    <div class="rain-target-letter">Catch: ${targetLetter}</div>
                    <div class="rain-game-area" id="rainGameArea">
                        <div class="rain-basket" id="rainBasket" style="left: 50%;">${targetLetter}</div>
                    </div>
                </div>
            `;

            // Set up controls
            const gameAreaEl = document.getElementById('rainGameArea');
            gameAreaEl.addEventListener('mousemove', moveBasket);
            gameAreaEl.addEventListener('touchmove', moveBasket, { passive: false });

            // Start spawning letters
            startRainGame(targetLetter);

            // Start timer
            startMinigameTimer(30, () => endLetterRain());
        }

        function moveBasket(e) {
            const gameArea = document.getElementById('rainGameArea');
            const basket = document.getElementById('rainBasket');
            const rect = gameArea.getBoundingClientRect();

            let x;
            if (e.touches) {
                e.preventDefault(); // avoid scrolling while dragging
                x = e.touches[0].clientX - rect.left;
            } else {
                x = e.clientX - rect.left;
            }

            const percentage = (x / rect.width) * 100;
            basket.style.left = Math.max(5, Math.min(85, percentage)) + '%';
        }

        function startRainGame(targetLetter) {
            rainGameInterval = setInterval(() => {
                const gameArea = document.getElementById('rainGameArea');
                if (!gameArea) return;

                const letter = document.createElement('div');
                letter.className = 'falling-letter';
                letter.textContent = Math.random() < 0.7 ? targetLetter : getRandomLetter();
                letter.style.left = Math.random() * 80 + 10 + '%';
                letter.style.animationDuration = (Math.random() * 2 + 3) + 's';

                gameArea.appendChild(letter);
                // Ensure cleanup after animation completes
                letter.addEventListener('animationend', () => {
                    if (letter && letter.parentElement) {
                        letter.remove();
                    }
                });

                // Check for collision
                const checkCollision = setInterval(() => {
                    if (!letter.parentElement) {
                        clearInterval(checkCollision);
                        return;
                    }

                    const basket = document.getElementById('rainBasket');
                    const letterRect = letter.getBoundingClientRect();
                    const basketRect = basket.getBoundingClientRect();

                    if (letterRect.bottom >= basketRect.top &&
                        letterRect.left < basketRect.right &&
                        letterRect.right > basketRect.left) {

                        if (letter.textContent === targetLetter) {
                            minigameScore += 10;
                            document.getElementById('minigameScore').textContent = minigameScore;
                            createConfetti(basket);
                            speakPhrase('Good catch!');
                        } else {
                            minigameScore = Math.max(0, minigameScore - 5);
                            document.getElementById('minigameScore').textContent = minigameScore;
                        }

                        letter.remove();
                        clearInterval(checkCollision);
                    } else if (letterRect.top > window.innerHeight) {
                        letter.remove();
                        clearInterval(checkCollision);
                    }
                }, 50);
            }, 800);
        }

        function endLetterRain() {
            clearInterval(rainGameInterval);
            currentMinigame = null;

            showFeedback(`Great job! Score: ${minigameScore}`, 'success');
            speakPhrase(`Nice work! You scored ${minigameScore} points!`);

            setTimeout(() => startIdentifyGame(), 3000);
        }

        function startMemoryMatch() {
            currentMinigame = 'memoryMatch';
            minigameScore = 0;
            matchedPairs = 0;
            flippedCards = [];

            // Create pairs of letters
            const letters = [];
            for (let i = 0; i < 8; i++) {
                const letter = getRandomLetter();
                letters.push(letter, letter);
            }
            letters.sort(() => Math.random() - 0.5);

            const gameArea = document.getElementById('gameArea');
            gameArea.innerHTML = `
                <div class="minigame-container">
                    <div class="minigame-header">
                        <div class="minigame-score">Matches: <span id="minigameScore">0</span>/8</div>
                        <div class="minigame-timer" id="minigameTimer">
                            <span>â±ï¸</span>
                            <span id="minigameTime">45</span>s
                        </div>
                    </div>
                    <div class="memory-grid" id="memoryGrid">
                        ${letters.map((letter, index) => `
                            <div class="memory-card" data-letter="${letter}" data-index="${index}" onclick="flipCard(this)">
                                <div class="memory-card-front">?</div>
                                <div class="memory-card-back">${letter}</div>
                            </div>
                        `).join('')}
                    </div>
                </div>
            `;

            startMinigameTimer(45, () => endMemoryMatch());
        }

        function flipCard(card) {
            if (flippedCards.length >= 2) return;
            if (card.classList.contains('flipped')) return;
            if (card.classList.contains('matched')) return;

            card.classList.add('flipped');
            flippedCards.push(card);

            if (flippedCards.length === 2) {
                const [card1, card2] = flippedCards;

                if (card1.dataset.letter === card2.dataset.letter) {
                    // Match!
                    setTimeout(() => {
                        card1.classList.add('matched');
                        card2.classList.add('matched');
                        matchedPairs++;
                        minigameScore = matchedPairs;
                        document.getElementById('minigameScore').textContent = minigameScore;

                        speakLetter(card1.dataset.letter);

                        if (matchedPairs === 8) {
                            endMemoryMatch();
                        }
                    }, 500);
                } else {
                    // No match
                    setTimeout(() => {
                        card1.classList.remove('flipped');
                        card2.classList.remove('flipped');
                    }, 1000);
                }

                setTimeout(() => {
                    flippedCards = [];
                }, 1000);
            }
        }

        function endMemoryMatch() {
            clearInterval(minigameTimer);
            currentMinigame = null;

            showFeedback(`Excellent! ${matchedPairs} matches!`, 'success');
            speakPhrase(`Great memory! You found ${matchedPairs} pairs!`);

            setTimeout(() => startIdentifyGame(), 3000);
        }

        function startMinigameTimer(duration, callback) {
            let timeLeft = duration;
            const timerEl = document.getElementById('minigameTime');
            const timerContainer = document.getElementById('minigameTimer');

            minigameTimer = setInterval(() => {
                timeLeft--;
                timerEl.textContent = timeLeft;

                if (timeLeft <= 5) {
                    timerContainer.classList.add('warning');
                }

                if (timeLeft <= 0) {
                    clearInterval(minigameTimer);
                    callback();
                }
            }, 1000);
        }

        function showRoundCompletion() {
            clearAllTimers();
            cancelSpeech();

            // Calculate stats
            const avgTime = responseTimes.length > 0 ?
                (responseTimes.reduce((a, b) => a + b, 0) / responseTimes.length).toFixed(1) : 0;
            const accuracy = (roundCorrect + roundWrong) > 0 ?
                Math.round((roundCorrect / (roundCorrect + roundWrong)) * 100) : 0;
            const scoreGained = Math.max(0, score - scoreAtRoundStart);

            // Update rounds completed
            roundsCompleted++;
            checkAchievement('rounds', roundsCompleted);

            // Check for perfect round
            if (roundWrong === 0 && roundCorrect >= QUESTIONS_PER_ROUND) {
                checkAchievement('perfect', 1);
            }

            // Identify problem letters (those with 2+ errors)
            problemLetters = Object.entries(letterErrors)
                .filter(([letter, errors]) => errors >= 2)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 5)
                .map(([letter]) => letter);

            // Update modal content
            document.getElementById('completedRound').textContent = currentRound;
            document.getElementById('avgTime').textContent = avgTime;
            document.getElementById('accuracy').textContent = accuracy;
            document.getElementById('scoreGained').textContent = scoreGained;
            document.getElementById('nextRoundNum').textContent = currentRound + 1;

            const problemList = document.getElementById('problemLettersList');
            if (problemLetters.length > 0) {
                // Format letters based on current case setting
                const formattedLetters = problemLetters.map(l => {
                    if (currentCase === 'upper') return l.toUpperCase();
                    if (currentCase === 'lower') return l.toLowerCase();
                    return l; // mixed case
                }).join(' ');
                problemList.textContent = formattedLetters;
            } else {
                problemList.innerHTML = 'None - Perfect! ðŸŒŸ';
            }

            // Show modal with animation
            const modal = document.getElementById('roundModal');
            modal.style.display = 'flex';
            previouslyFocusedElement = document.activeElement;
            setTimeout(() => trapFocus(modal.querySelector('.round-content')), 50);
            // Close when tapping outside content
            modal.onclick = function (e) {
                if (e.target === modal) {
                    startNextRound();
                }
            };

            document.body.classList.add('modal-open');

            // Play celebration sound
            speakPhrase(`Congratulations! You completed round ${currentRound}!`);
        }

        function startNextRound() {
            currentRound++;
            roundCorrect = 0;
            roundWrong = 0;
            responseTimes = [];
            letterErrors = {};
            scoreAtRoundStart = score;

            document.getElementById('roundModal').style.display = 'none';
            document.body.classList.remove('modal-open');
            startIdentifyGame();
        }

        function startDrawGame() {
            // Reset round-specific state when (re)starting this mode
            roundCorrect = 0;
            roundWrong = 0;
            scoreAtRoundStart = currentPlayer ? currentPlayer.score : score;
            clearAllTimers();
            cancelSpeech();
            // Clear any pending auto-advance from prior round and unlock
            if (drawAdvanceTimeout) { try { clearTimeout(drawAdvanceTimeout); } catch (e) {} drawAdvanceTimeout = null; }
            drawAdvanceLocked = false;
            drawHasAdvanced = false;
            currentLetter = getRandomLetter();
            // reset hint state
            hintWasShown = false;
            hasStartedTrace = false;
            clearIdleHintTimers();

            const gameArea = document.getElementById('gameArea');
            // Compute space: keep everything fully in view without scrolling
            const headerHeight = 0; // header is outside game-area; padding already applied
            const reservedTop = Math.max(72, Math.min(window.innerHeight * 0.14, 120));
            const verticalGutters = reservedTop + 12 /*bottom padding*/ + 140 /*controls+labels*/;
            const maxSquare = Math.min(window.innerWidth - 36, window.innerHeight - verticalGutters);
            // make the draw area much larger for kids; allow up to available square
            const canvasSize = Math.max(260, Math.min(560, maxSquare));
            gameArea.innerHTML = `
                <div class="instruction">Trace the letter: <span class="letter-display">${currentLetter}</span></div>
                <div class="canvas-container">
                    <div class="letter-guide">${currentLetter}</div>
                    <svg class="formation-guide" width="${canvasSize}" height="${canvasSize}" id="formationGuide">
                        <!-- Letter formation guide will be added here -->
                    </svg>
                    <canvas id="drawCanvas" width="${canvasSize}" height="${canvasSize}"></canvas>
                </div>
                <div class="formation-controls">
                    <button class="formation-btn secondary" onclick="showFormationGuide()">Show How to Write</button>
                    <button class="formation-btn secondary" onclick="hideFormationGuide()">Hide Guide</button>
                </div>
                <div class="controls">
                    <button class="control-btn clear-btn" onclick="clearCanvas()">Clear âœ¨</button>
                    <button class="control-btn check-btn" onclick="checkDrawing()">I'm Done!</button>
                </div>
            `;

            setupCanvas();
            // Ensure the canvas fits within the visible game area with buttons visible
            resizeDrawLayout();
            // Bind relayout on viewport changes (only once per session)
            if (!window.__drawLayoutBound) {
                window.__drawLayoutBound = true;
                const relayout = () => requestAnimationFrame(resizeDrawLayout);
                window.addEventListener('resize', relayout, { passive: true });
                window.addEventListener('orientationchange', relayout, { passive: true });
                if (window.visualViewport) {
                    window.visualViewport.addEventListener('resize', relayout);
                }
            }
            gameArea.classList.remove('with-sound');
            document.getElementById('scorePanel').style.display = 'flex';
            updateScoreDisplay();

            // Speak prompt using two-part sequence to avoid stutter on some engines
            speakTracePrompt(currentLetter);
            // start idle hint timer after the initial prompt
            startIdleHintTimer();
        }

        function resizeDrawLayout() {
            const gameArea = document.getElementById('gameArea');
            if (!gameArea) return;
            const container = gameArea.querySelector('.canvas-container');
            const canvas = document.getElementById('drawCanvas');
            const guide = document.getElementById('formationGuide');
            const letterGuide = gameArea.querySelector('.letter-guide');
            if (!container || !canvas || !guide) return;

            const getOuterHeight = (el) => {
                if (!el) return 0;
                const styles = getComputedStyle(el);
                const mt = parseFloat(styles.marginTop) || 0;
                const mb = parseFloat(styles.marginBottom) || 0;
                return el.offsetHeight + mt + mb;
            };

            const instruction = gameArea.querySelector('.instruction');
            const formationControls = gameArea.querySelector('.formation-controls');
            const controls = gameArea.querySelector('.controls');

            const verticalGaps = 16; // breathing room
            const availableHeight = Math.max(
                160,
                gameArea.clientHeight
                - getOuterHeight(instruction)
                - getOuterHeight(formationControls)
                - getOuterHeight(controls)
                - verticalGaps
            );

            const availableWidth = Math.max(160, gameArea.clientWidth - 32);
            // Prefer large square while keeping controls visible; minimum significantly larger than before
            const size = Math.floor(Math.max(260, Math.min(availableWidth, availableHeight)));

            // Apply size to canvas, guide and container
            canvas.width = size;
            canvas.height = size;
            canvas.style.width = size + 'px';
            canvas.style.height = size + 'px';
            guide.setAttribute('width', String(size));
            guide.setAttribute('height', String(size));
            container.style.width = size + 'px';
            container.style.height = size + 'px';

            if (letterGuide) {
                letterGuide.style.fontSize = Math.round(size * 0.72) + 'px';
            }
        }

        function showFormationGuide() {
            const guide = document.getElementById('formationGuide');
            const letterData = letterFormations[currentLetter.toLowerCase()];

            if (!letterData) {
                // Fallback for letters without formation data
                const size = Math.min(guide.clientWidth || 300, guide.clientHeight || 300);
                guide.innerHTML = `
                    <text x="50%" y="50%" font-size="${Math.floor(size * 0.7)}" fill="#667eea" opacity="0.25" text-anchor="middle" dominant-baseline="middle">
                        ${currentLetter}
                    </text>
                `;
                return;
            }

            guide.innerHTML = '';

            // Scale paths to fit within viewBox proportionally (letter data is on 100x100 grid)
            const bboxSize = Math.min(guide.clientWidth || 300, guide.clientHeight || 300);
            guide.setAttribute('viewBox', '0 0 100 100');
            guide.style.width = '100%';
            guide.style.height = '100%';

            letterData.forEach((stroke, index) => {
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('d', stroke.path);
                path.setAttribute('class', 'stroke-path stroke-animated');
                path.style.animationDelay = `${index * 2}s`;
                guide.appendChild(path);

                // Add stroke number (with safety check)
                const pathMatch = stroke.path.match(/M\s*(\d+)\s+(\d+)/);
                if (pathMatch) {
                    const [startX, startY] = pathMatch.slice(1).map(Number);
                    const number = document.createElement('div');
                    number.className = 'stroke-number';
                    number.textContent = stroke.strokes;
                    // Position using percentage within the container to keep inside bounds
                    number.style.left = `${startX}%`;
                    number.style.top = `${startY}%`;
                    number.style.animationDelay = `${index * 2}s`;
                    guide.parentElement.appendChild(number);
                }
            });

            speakPhrase(`Watch how to write ${currentLetter}`);
        }

        function hideFormationGuide() {
            const guide = document.getElementById('formationGuide');
            guide.innerHTML = '';
            const numbers = document.querySelectorAll('.stroke-number');
            numbers.forEach(n => n.remove());
            // remove viewBox so future resizes reset cleanly
            guide.removeAttribute('viewBox');
        }

        function setupCanvas() {
            const canvas = document.getElementById('drawCanvas');
            // Prevent page scroll during drawing on touch devices
            canvas.style.touchAction = 'none';
            ctx = canvas.getContext('2d');
            ctx.lineWidth = 8;
            ctx.lineCap = 'round';
            ctx.strokeStyle = '#764ba2';
            drawingPoints = [];
            lastDrawTime = 0;

            // Touch events
            canvas.addEventListener('touchstart', startDrawing, { passive: false });
            canvas.addEventListener('touchmove', draw, { passive: false });
            canvas.addEventListener('touchend', stopDrawing, { passive: false });

            // Mouse events
            canvas.addEventListener('mousedown', startDrawing);
            canvas.addEventListener('mousemove', draw);
            canvas.addEventListener('mouseup', stopDrawing);
            canvas.addEventListener('mouseout', stopDrawing);
        }

        function startDrawing(e) {
            e.preventDefault();
            isDrawing = true;
            hasStartedTrace = true; // stop any idle hint
            clearIdleHintTimers();
            const rect = e.target.getBoundingClientRect();
            const x = (e.touches ? e.touches[0].clientX : e.clientX) - rect.left;
            const y = (e.touches ? e.touches[0].clientY : e.clientY) - rect.top;

            ctx.beginPath();
            ctx.moveTo(x, y);
            // Keep existing points for multi-stroke drawing
            drawingPoints.push({ x, y, newStroke: true });
        }

        function draw(e) {
            if (!isDrawing) return;
            e.preventDefault();
            // throttle to ~60fps to reduce lag on older devices
            const now = Date.now();
            if (now - lastDrawTime < 16) return;
            lastDrawTime = now;

            const rect = e.target.getBoundingClientRect();
            const x = (e.touches ? e.touches[0].clientX : e.clientX) - rect.left;
            const y = (e.touches ? e.touches[0].clientY : e.clientY) - rect.top;

            ctx.lineTo(x, y);
            ctx.stroke();
            drawingPoints.push({ x, y });
            if (drawingPoints.length > 1000) {
                drawingPoints = drawingPoints.slice(-500);
            }
        }

        function stopDrawing(e) {
            e.preventDefault();
            isDrawing = false;
            // Don't clear points - allow multiple strokes
        }

        function clearCanvas() {
            const canvas = document.getElementById('drawCanvas');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawingPoints = [];
            hasStartedTrace = false;
            // restart idle hint if user clears without drawing immediately
            startIdleHintTimer();

            // Add clear animation
            const container = document.querySelector('.canvas-container');
            container.style.animation = 'shake 0.3s';
            setTimeout(() => {
                container.style.animation = '';
            }, 300);
        }

        function checkDrawing() {
            // Phase 1: quick checks
            if (drawingPoints.length < 20) {
                showFeedback('Keep drawing! Try to complete the letter. âœï¸', 'info');
                speakPhrase('Add a little more to your drawing!');
                return;
            }

            const letterData = LETTER_CHECKPOINTS[currentLetter];
            if (!letterData) {
                // Fallback: reward practice without strict validation
                showFeedback("Great practice! Let's try another one. ðŸ‘", 'info');
                speakPhrase('Good job practicing that letter!');
                setTimeout(() => startDrawGame(), 2000);
                return;
            }

            // Slightly more forgiving tolerance, with per-letter boosts for tricky shapes
            let effectiveTolerance = (letterData && typeof letterData.tolerance === 'number') ? letterData.tolerance : 28;
            const baseForgiveness = 8; // global softening on 100x100 grid
            const toleranceBoosts = {
                // common tricky letters or with optional ornaments/crossbars
                'k': 6, 'K': 6,
                'r': 6, 'R': 8,
                'v': 6, 'V': 6,
                'i': 5, 'j': 5, 'I': 4, 'J': 5,
                's': 6, 'S': 6,
                'z': 8, 'Z': 8, // allow zig segments and optional slash
                'w': 6, 'W': 6, 'm': 6, 'M': 6, 'n': 6, 'N': 6,
                'x': 6, 'X': 6, 'y': 6, 'Y': 6,
                't': 6, 'T': 6, 'f': 6, 'F': 6,
                'q': 6, 'Q': 6, 'g': 6, 'G': 6,
                'a': 6, 'A': 8, 'h': 4, 'H': 6, 'p': 4, 'P': 6, 'B': 6, 'D': 6, 'E': 6,
                'o': 10, 'O': 10 // accept imperfect circles/ovals
            };
            effectiveTolerance += baseForgiveness + (toleranceBoosts[currentLetter] || 0);

            // Phase 2: normalize strokes to 100x100 grid
            let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
            drawingPoints.forEach(p => { minX = Math.min(minX, p.x); maxX = Math.max(maxX, p.x); minY = Math.min(minY, p.y); maxY = Math.max(maxY, p.y); });
            const width = maxX - minX, height = maxY - minY;
            if (width < 25 && height < 25) {
                showFeedback('Try to make your letter bigger! ðŸŽ¨', 'info');
                speakPhrase('Draw the letter a bit bigger so I can see it.');
                return;
            }

            const userStrokes = [];
            let stroke = [];
            drawingPoints.forEach(p => {
                if (p.newStroke && stroke.length) { userStrokes.push(stroke); stroke = []; }
                stroke.push(p);
            });
            if (stroke.length) userStrokes.push(stroke);

            const normalizedUserStrokes = userStrokes.map(s => s.map(p => ({
                x: width === 0 ? 50 : ((p.x - minX) / width) * 100,
                y: height === 0 ? 50 : ((p.y - minY) / height) * 100
            })));
            // Some letters are often drawn as several smaller strokes instead of one continuous path
            const allowSplitConcat = new Set(['z', 'Z', 'w', 'W', 'm', 'M', 'n', 'N', 'x', 'X', 'y', 'Y', 'b', 'B', 'p', 'P', 'd', 'D', 'q', 'Q', 'g', 'G']).has(currentLetter);
            const allowStrokeReuse = new Set(['x', 'X', 'y', 'Y', 't', 'T', 'a', 'A', 'h', 'H', 'b', 'B', 'p', 'P', 'd', 'D', 'q', 'Q', 'I', 'g', 'G']).has(currentLetter);

            const buildComposedStrokes = (strokes, maxSegments) => {
                const out = [];
                for (let i = 0; i < strokes.length; i++) {
                    // concatenate up to maxSegments consecutive strokes
                    let acc = [];
                    for (let len = 2; len <= maxSegments && i + len - 1 < strokes.length; len++) {
                        if (len === 2) {
                            acc = [...strokes[i], ...strokes[i + 1]];
                            out.push(acc);
                        } else {
                            acc = [...acc, ...strokes[i + len - 1]];
                            out.push(acc);
                        }
                    }
                }
                return out;
            };

            // Phase 3: rotation-invariant matching using Hausdorff distance
            // Helpers are scoped locally to keep changes contained
            const flattenPoints = (strokes) => strokes.reduce((arr, s) => (arr.push(...s), arr), []);
            const computePCAAngle = (points) => {
                if (!points || points.length < 2) return 0;
                let cx = 0, cy = 0;
                for (const p of points) { cx += p.x; cy += p.y; }
                cx /= points.length; cy /= points.length;
                let sxx = 0, syy = 0, sxy = 0;
                for (const p of points) {
                    const dx = p.x - cx, dy = p.y - cy;
                    sxx += dx * dx; syy += dy * dy; sxy += dx * dy;
                }
                sxx /= points.length; syy /= points.length; sxy /= points.length;
                const trace = sxx + syy;
                const det = sxx * syy - sxy * sxy;
                const temp = Math.max(0, (trace * trace) / 4 - det);
                const root = Math.sqrt(temp);
                const lambda1 = trace / 2 + root;
                const lambda2 = trace / 2 - root;
                // Eigenvector for largest eigenvalue
                let vx = -sxy, vy = sxx - lambda1;
                if (Math.abs(vx) < 1e-6 && Math.abs(vy) < 1e-6) { vx = 1; vy = 0; }
                const angle = Math.atan2(vy, vx);
                const ratio = lambda2 > 1e-6 ? (lambda1 / lambda2) : 9999;
                return { angle, ratio, centroid: { x: cx, y: cy } };
            };
            const rotateAndNormalize = (strokes, angle) => {
                if (!strokes || strokes.length === 0) return strokes;
                const pts = flattenPoints(strokes);
                let cx = 0, cy = 0;
                for (const p of pts) { cx += p.x; cy += p.y; }
                cx /= pts.length; cy /= pts.length;
                const cos = Math.cos(angle), sin = Math.sin(angle);
                const rotated = strokes.map(s => s.map(p => ({
                    x: (p.x - cx) * cos - (p.y - cy) * sin + cx,
                    y: (p.x - cx) * sin + (p.y - cy) * cos + cy
                })));
                // Normalize to 0..100
                let minX2 = Infinity, maxX2 = -Infinity, minY2 = Infinity, maxY2 = -Infinity;
                rotated.forEach(s => s.forEach(p => { minX2 = Math.min(minX2, p.x); maxX2 = Math.max(maxX2, p.x); minY2 = Math.min(minY2, p.y); maxY2 = Math.max(maxY2, p.y); }));
                const w2 = Math.max(1e-6, maxX2 - minX2), h2 = Math.max(1e-6, maxY2 - minY2);
                return rotated.map(s => s.map(p => ({ x: ((p.x - minX2) / w2) * 100, y: ((p.y - minY2) / h2) * 100 })));
            };
            const downsampleStroke = (stroke, maxPts) => {
                if (stroke.length <= maxPts) return stroke;
                const out = [];
                for (let i = 0; i < maxPts; i++) {
                    const idx = Math.round((i / (maxPts - 1)) * (stroke.length - 1));
                    out.push(stroke[idx]);
                }
                return out;
            };
            const prepareStrokes = (strokes, maxPts) => strokes.map(s => downsampleStroke(s, maxPts));
            const densifyStroke = (stroke, targetPts) => {
                if (!stroke || stroke.length < 2) return stroke;
                // Compute cumulative lengths along the polyline
                const segLens = [];
                let total = 0;
                for (let i = 0; i < stroke.length - 1; i++) {
                    const dx = stroke[i + 1].x - stroke[i].x;
                    const dy = stroke[i + 1].y - stroke[i].y;
                    const len = Math.hypot(dx, dy);
                    segLens.push(len);
                    total += len;
                }
                if (total === 0) return stroke;
                const out = [];
                let segIndex = 0;
                let segStartDist = 0;
                for (let i = 0; i < targetPts; i++) {
                    const t = i / (targetPts - 1);
                    const dist = t * total;
                    while (segIndex < segLens.length - 1 && segStartDist + segLens[segIndex] < dist) {
                        segStartDist += segLens[segIndex];
                        segIndex++;
                    }
                    const segLen = segLens[segIndex] || 1e-6;
                    const localT = Math.max(0, Math.min(1, (dist - segStartDist) / segLen));
                    const p0 = stroke[segIndex];
                    const p1 = stroke[segIndex + 1] || p0;
                    out.push({ x: p0.x + (p1.x - p0.x) * localT, y: p0.y + (p1.y - p0.y) * localT });
                }
                return out;
            };
            const hausdorff = (a, b) => {
                const d = (p, q) => Math.hypot(p.x - q.x, p.y - q.y);
                const oneSided = (P, Q) => {
                    let worst = 0;
                    for (const p of P) {
                        let best = Infinity;
                        for (const q of Q) { const dist = d(p, q); if (dist < best) best = dist; }
                        if (best > worst) worst = best;
                    }
                    return worst;
                };
                return Math.max(oneSided(a, b), oneSided(b, a));
            };
            const oneSidedHd = (a, b) => {
                const d = (p, q) => Math.hypot(p.x - q.x, p.y - q.y);
                let worst = 0;
                for (const p of a) {
                    let best = Infinity;
                    for (const q of b) { const dist = d(p, q); if (dist < best) best = dist; }
                    if (best > worst) worst = best;
                }
                return worst;
            };
            const distTol = Math.max(10, Math.min(22, Math.round(effectiveTolerance * 0.4)));

            // Template prep: densify polylines for stable Hausdorff, then (light) downsample
            const templateStrokes = letterData.strokes.map(s => downsampleStroke(densifyStroke(s, 64), 64));

            // Build variants: base, rotate-to-horizontal, rotate-to-vertical
            const pca = computePCAAngle(flattenPoints(normalizedUserStrokes));
            const baseVariant = normalizedUserStrokes;
            const horizVariant = rotateAndNormalize(normalizedUserStrokes, -pca.angle);
            const vertVariant = rotateAndNormalize(normalizedUserStrokes, (Math.PI / 2) - pca.angle);
            const reflectHorizontal = (strokes) => strokes.map(s => s.map(p => ({ x: 100 - p.x, y: p.y })));
            let variants = [baseVariant, horizVariant, vertVariant];
            // Mirror-acceptance for letters where tail direction varies (e.g., 'g')
            if (({ 'g': 1, 'G': 1 })[currentLetter]) {
                const mirroredBase = reflectHorizontal(baseVariant);
                const pcaMir = computePCAAngle(flattenPoints(mirroredBase));
                const mirroredHoriz = rotateAndNormalize(mirroredBase, -pcaMir.angle);
                const mirroredVert = rotateAndNormalize(mirroredBase, (Math.PI / 2) - pcaMir.angle);
                variants = variants.concat([mirroredBase, mirroredHoriz, mirroredVert]);
            }

            let matched = 0;
            let dottedHeuristicOK = false;
            const requiredStrokes = letterData.strokes.length;

            const strokeBounds = (s) => {
                let sx = Infinity, sy = Infinity, bx = -Infinity, by = -Infinity;
                for (const p of s) { if (p.x < sx) sx = p.x; if (p.x > bx) bx = p.x; if (p.y < sy) sy = p.y; if (p.y > by) by = p.y; }
                const cx2 = (sx + bx) / 2; const cy2 = (sy + by) / 2;
                const len2 = Math.hypot(s[0].x - s[s.length - 1].x, s[0].y - s[s.length - 1].y);
                return { minX: sx, minY: sy, maxX: bx, maxY: by, width: bx - sx, height: by - sy, cx: cx2, cy: cy2, endToEnd: len2 };
            };

            const clusterSmallStrokes = (strokes) => {
                const small = strokes.map((s, i) => ({ idx: i, b: strokeBounds(s) }))
                    .filter(({ b }) => b.width <= 16 && b.height <= 16 && b.endToEnd <= 20);
                const clusters = [];
                const used = new Set();
                for (let i = 0; i < small.length; i++) {
                    if (used.has(i)) continue;
                    const c = [small[i]];
                    used.add(i);
                    for (let j = i + 1; j < small.length; j++) {
                        if (used.has(j)) continue;
                        const dx = small[j].b.cx - small[i].b.cx;
                        const dy = small[j].b.cy - small[i].b.cy;
                        if (Math.hypot(dx, dy) <= 14) { c.push(small[j]); used.add(j); }
                    }
                    clusters.push({ members: c, cx: c.reduce((a, m) => a + m.b.cx, 0) / c.length, cy: c.reduce((a, m) => a + m.b.cy, 0) / c.length });
                }
                return clusters;
            };

            const tryVariant = (variantStrokes) => {
                const variantCandidates = allowSplitConcat && variantStrokes.length > 1
                    ? [...variantStrokes, ...buildComposedStrokes(variantStrokes, 3)]
                    : [...variantStrokes];
                const availVar = [...variantCandidates];
                let matchedCount = 0;
                for (const req of templateStrokes) {
                    const reqDs = req; // already downsampled
                    let bestIdx = -1;
                    for (let i = 0; i < availVar.length; i++) {
                        const userDs = downsampleStroke(availVar[i], 64);
                        const dSym = hausdorff(userDs, reqDs);
                        if (dSym <= distTol) { bestIdx = i; break; }
                        // For letters like 'K', allow extra user stroke content using directed Hausdorff (templateâ†’user)
                        // Letters prone to merged/extra stroke content: allow directed Hausdorff (templateâ†’user)
                        if (({
                            'K':1,'k':1,'R':1,'r':1,'M':1,'m':1,'W':1,'w':1,'N':1,'n':1,
                            'Z':1,'z':1,'V':1,'v':1,'F':1,'f':1,'E':1,'e':1,'A':1,'a':1,
                            'Q':1,'q':1,'X':1,'x':1,'Y':1,'y':1,'G':1,'g':1
                        })[currentLetter]) {
                            const dDir = oneSidedHd(reqDs, userDs);
                            if (dDir <= distTol) { bestIdx = i; break; }
                        }
                    }
                    if (bestIdx !== -1) {
                        matchedCount++;
                        if (!allowStrokeReuse) { availVar.splice(bestIdx, 1); }
                    } else if (currentLetter === 'I') {
                        // Optional horizontal bars for uppercase I when a tall vertical exists
                        let rxMin = Infinity, rxMax = -Infinity, ryMin = Infinity, ryMax = -Infinity;
                        for (const p of reqDs) { if (p.x < rxMin) rxMin = p.x; if (p.x > rxMax) rxMax = p.x; if (p.y < ryMin) ryMin = p.y; if (p.y > ryMax) ryMax = p.y; }
                        const rdx = rxMax - rxMin, rdy = ryMax - ryMin;
                        const looksHorizontal = rdx >= 30 && rdy <= 8;
                        if (looksHorizontal) {
                            const hasTallVertical = variantCandidates.some(st => {
                                let sx = Infinity, sy = Infinity, bx = -Infinity, by = -Infinity;
                                for (const q of st) { if (q.x < sx) sx = q.x; if (q.x > bx) bx = q.x; if (q.y < sy) sy = q.y; if (q.y > by) by = q.y; }
                                const dw = bx - sx, dh = by - sy;
                                return dh >= 70 && dw <= 15;
                            });
                            if (hasTallVertical) {
                                matchedCount++;
                            }
                        }
                    }
                }
                // Dotted letters cluster heuristic on this variant
                let dotOK = false;
                if ((currentLetter === 'i' || currentLetter === 'j') && variantStrokes.length >= 2) {
                    const boundsList = variantStrokes.map(strokeBounds);
                    const mainIdx2 = boundsList.reduce((best, b, i) => (b.height > (boundsList[best]?.height || 0) ? i : best), 0);
                    const main2 = boundsList[mainIdx2];
                    const clusters = clusterSmallStrokes(variantStrokes);
                    if (main2 && main2.height >= 40) {
                        dotOK = clusters.some(c => Math.abs(c.cx - main2.cx) <= 20 && c.cy <= (main2.minY + 15));
                    }
                }
                return { matchedCount, dotOK };
            };

            for (const variant of variants) {
                const { matchedCount, dotOK } = tryVariant(variant);
                if (matchedCount === requiredStrokes || dotOK) {
                    matched = requiredStrokes;
                    dottedHeuristicOK = dotOK;
                    break;
                }
                // Keep best-so-far if needed (not used in final decision presently)
            }

            // Phase 4: feedback and progression
            if (matched === letterData.strokes.length || dottedHeuristicOK) {
                // Apply dynamic scoring for tracing, include hint penalty
                const responseTime = (Date.now() - drawQuestionStartTime) / 1000;
                const base = 10 + (difficultyLevel * 5);
                const bonus = Math.max(0, 30 - responseTime * 3);
                const hintPenalty = hintWasShown ? 10 : 0;
                let points = Math.max(0, Math.floor(base + bonus) - hintPenalty);
                const gainedThisRound = Math.max(0, (currentPlayer ? currentPlayer.score : score) - scoreAtRoundStart);
                if (gainedThisRound + points > 50) {
                    points = Math.max(0, 50 - gainedThisRound);
                }
                score += points;
                roundCorrect++;
                correctAnswers++;
                totalQuestions++;
                updateScoreDisplay();

                const pointsGained = points;
                // Update letter performance with per-letter score and measured time
                updateLetterPerformance(currentLetter, true, responseTime, pointsGained);
                showFeedback(`That's a perfect "${currentLetter}"! +${pointsGained} âœ¨`, 'success');
                // After the praise finishes (or immediately if speech is off), advance to the next letter
                cancelSpeech();
                speakPhrase(`Wow! That's a great ${currentLetter}!`, () => {
                    advanceToNextDrawLetterOnce();
                });
                const container = document.querySelector('.canvas-container');
                if (container) {
                    container.style.boxShadow = '0 10px 30px rgba(74, 222, 128, 0.5)';
                    container.style.transform = 'scale(1.03)';
                    setTimeout(() => { container.style.boxShadow = ''; container.style.transform = ''; }, 1000);
                }

                // Also schedule a backup auto-advance in case speech callbacks are delayed
                drawAdvanceTimeout = setTimeout(() => {
                    advanceToNextDrawLetterOnce();
                }, 2200);
            } else {
                const msg = matched > 0 ? letterData.feedback.incomplete : letterData.feedback.wrong;
                showFeedback(msg, 'error');
                speakPhrase(msg);
                const container = document.querySelector('.canvas-container');
                if (container) {
                    container.classList.add('animate__animated', 'animate__shakeX');
                    setTimeout(() => container.classList.remove('animate__animated', 'animate__shakeX'), 800);
                }
                setTimeout(() => clearCanvas(), 2000);
            }
        }

        function getDrawingBounds() {
            if (drawingPoints.length === 0) return { width: 0, height: 0 };

            let minX = Infinity, maxX = -Infinity;
            let minY = Infinity, maxY = -Infinity;

            drawingPoints.forEach(point => {
                if (!point.newStroke) {
                    minX = Math.min(minX, point.x);
                    maxX = Math.max(maxX, point.x);
                    minY = Math.min(minY, point.y);
                    maxY = Math.max(maxY, point.y);
                }
            });

            return {
                width: maxX - minX,
                height: maxY - minY
            };
        }

        function createDrawingCelebration() {
            // Create overlay celebration that doesn't disrupt the view
            const overlay = document.createElement('div');
            overlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                pointer-events: none;
                z-index: 10000;
            `;
            document.body.appendChild(overlay);

            // Add celebration elements
            for (let i = 0; i < 15; i++) {
                const star = document.createElement('div');
                star.textContent = 'â­';
                star.style.cssText = `
                    position: absolute;
                    font-size: ${20 + Math.random() * 30}px;
                    left: ${Math.random() * 100}%;
                    top: ${Math.random() * 100}%;
                    animation: sparkle 1s ease-out forwards;
                    animation-delay: ${Math.random() * 0.5}s;
                `;
                overlay.appendChild(star);
            }

            // Remove overlay after animation
            setTimeout(() => {
                overlay.remove();
            }, 2000);
        }

        function showFeedback(message, type) {
            const feedback = document.getElementById('feedback');
            feedback.textContent = message;
            feedback.className = 'feedback ' + type;
            feedback.style.display = 'block';

            setTimeout(() => {
                feedback.style.display = 'none';
            }, 2000);
        }

        // Brief, non-disruptive overlay to show 2â€“3 example words for a letter
        function showWordExamples(letter, words) {
            if (!letter || !words || words.length === 0) return;
            // Avoid stacking if one is already visible
            if (document.getElementById('wordExamplesOverlay')) return;

            const overlay = document.createElement('div');
            overlay.id = 'wordExamplesOverlay';
            overlay.style.cssText = [
                'position:fixed',
                'inset:0',
                'display:flex',
                'align-items:center',
                'justify-content:center',
                'pointer-events:none',
                'z-index:9998'
            ].join(';');

            const card = document.createElement('div');
            card.setAttribute('role', 'dialog');
            card.setAttribute('aria-live', 'polite');
            card.style.cssText = [
                'max-width:84vw',
                'width:720px',
                'box-sizing:border-box',
                'padding:16px 20px',
                'border-radius:16px',
                'background:rgba(255,255,255,0.96)',
                'box-shadow:0 10px 30px rgba(0,0,0,0.15)',
                'border:2px solid rgba(0,0,0,0.06)',
                'text-align:center',
                'pointer-events:auto'
            ].join(';');

            const title = document.createElement('div');
            title.textContent = `${letter.toUpperCase()} is forâ€¦`;
            title.style.cssText = [
                'font-size:28px',
                'font-weight:800',
                'margin-bottom:10px'
            ].join(';');

            const list = document.createElement('div');
            list.style.cssText = [
                'display:flex',
                'gap:14px',
                'justify-content:center',
                'flex-wrap:wrap'
            ].join(';');

            const examples = words.slice(0, 3);
            examples.forEach(w => {
                const chip = document.createElement('div');
                chip.textContent = w;
                chip.style.cssText = [
                    'font-size:24px',
                    'font-weight:700',
                    'padding:10px 14px',
                    'border-radius:999px',
                    'background:#f3f4f6',
                    'border:2px solid #e5e7eb',
                    'min-width:90px'
                ].join(';');
                list.appendChild(chip);
            });

            card.appendChild(title);
            card.appendChild(list);
            overlay.appendChild(card);
            document.body.appendChild(overlay);

            // Gentle entrance animation
            if (typeof gsap !== 'undefined') {
                gsap.fromTo(card, { scale: 0.9, opacity: 0 }, { scale: 1, opacity: 1, duration: 0.25, ease: 'power2.out' });
            }

            // Speak examples for non-readers
            const say = ` ${letter.toUpperCase()} is for ${examples.join(', ')}.`;
            try { speakPhrase(say); } catch (e) { }

            // Auto-dismiss quickly to avoid disrupting flow
            setTimeout(() => {
                if (typeof gsap !== 'undefined') {
                    gsap.to(card, { scale: 0.96, opacity: 0, duration: 0.18, ease: 'power2.in', onComplete: () => overlay.remove() });
                } else {
                    overlay.remove();
                }
            }, 1400);
        }

        // Idle hint logic for tracing mode
        function startIdleHintTimer() {
            clearIdleHintTimers();
            const container = document.querySelector('.canvas-container');
            const guideEl = container ? container.querySelector('.letter-guide') : null;
            if (!guideEl) return;
            hintFadeOpacity = 0;
            // Wait a few seconds before gradually revealing the hint
            idleHintTimeout = setTimeout(() => {
                hintWasShown = true;
                // fade from 0 â†’ 0.12 over several seconds in tiny steps
                idleHintInterval = setInterval(() => {
                    // If the child started drawing, stop immediately
                    if (hasStartedTrace) { clearIdleHintTimers(); return; }
                    hintFadeOpacity = Math.min(0.12, hintFadeOpacity + 0.01);
                    guideEl.style.opacity = String(hintFadeOpacity);
                    if (hintFadeOpacity >= 0.12) {
                        clearInterval(idleHintInterval);
                        idleHintInterval = null;
                    }
                }, 200);
            }, 2500);
        }

        function clearIdleHintTimers() {
            if (idleHintTimeout) { clearTimeout(idleHintTimeout); idleHintTimeout = null; }
            if (idleHintInterval) { clearInterval(idleHintInterval); idleHintInterval = null; }
            const guideEl = document.querySelector('.canvas-container .letter-guide');
            if (guideEl) guideEl.style.opacity = '0';
        }

        function openSettings() {
            const modal = document.getElementById('settingsModal');
            previouslyFocusedElement = document.activeElement;
            modal.style.display = 'flex';
            document.body.classList.add('modal-open');
            // Sync advanced settings checkboxes if present
            try {
                const savedPhonics = localStorage.getItem('letterLearningPhonics');
                if (savedPhonics) {
                    phonicsEnabled = savedPhonics === 'on';
                }
            } catch (e) { }
            setPhonicsMode(phonicsEnabled ? 'on' : 'off');
            const voiceToggle = document.getElementById('voiceToggle');
            if (voiceToggle) voiceToggle.checked = !!voiceRecordingEnabled;
            const fm = document.getElementById('focusModeCheck');
            if (fm) fm.checked = !!focusModeEnabled;
            const hc = document.getElementById('highContrastCheck');
            if (hc) hc.checked = !!highContrastEnabled;
            const rm = document.getElementById('reduceMotionCheck');
            if (rm) rm.checked = !!reduceMotionEnabled;

            // Trap focus within modal content
            setTimeout(() => trapFocus(modal.querySelector('.settings-content')), 50);

            // Close modal when clicking outside
            modal.onclick = function (e) {
                if (e.target === modal) {
                    closeSettings();
                }
            };
        }

        function closeSettings() {
            const modal = document.getElementById('settingsModal');
            modal.style.animation = 'fadeOut 0.3s';
            setTimeout(() => {
                modal.style.display = 'none';
                modal.style.animation = '';
                if (previouslyFocusedElement) previouslyFocusedElement.focus();
                document.body.classList.remove('modal-open');
            }, 300);
        }

        function setTimerMode(mode) {
            timerEnabled = mode === 'on';
            document.querySelectorAll('#timerOff, #timerOn').forEach(btn => {
                btn.classList.remove('active');
                btn.setAttribute('aria-pressed', 'false');
            });
            const activeBtn = document.getElementById('timer' + (mode === 'on' ? 'On' : 'Off'));
            activeBtn.classList.add('active');
            activeBtn.setAttribute('aria-pressed', 'true');
            // If turning timer off mid-question, clear any running timers
            if (!timerEnabled) {
                clearAllTimers();
            }
        }

        function setCaseMode(mode) {
            currentCase = mode;
            document.querySelectorAll('#caseLower, #caseUpper, #caseMixed').forEach(btn => {
                btn.classList.remove('active');
                btn.setAttribute('aria-pressed', 'false');
            });

            const btnId = mode === 'lower' ? 'caseLower' :
                mode === 'upper' ? 'caseUpper' : 'caseMixed';
            const activeBtn = document.getElementById(btnId);
            activeBtn.classList.add('active');
            activeBtn.setAttribute('aria-pressed', 'true');
        }

        function setSoundMode(mode) {
            soundEnabled = mode === 'on';
            document.querySelectorAll('#soundOn, #soundOff').forEach(btn => {
                btn.classList.remove('active');
                btn.setAttribute('aria-pressed', 'false');
            });
            const activeBtn = document.getElementById('sound' + (mode === 'on' ? 'On' : 'Off'));
            activeBtn.classList.add('active');
            activeBtn.setAttribute('aria-pressed', 'true');
        }

        function toggleVoiceRecording(enabled) {
            voiceRecordingEnabled = !!enabled;
            saveGameData();
        }

        // Visual Theme Functions
        function setVisualTheme(theme) {
            currentTheme = theme;
            // Support both legacy .theme-option and new .theme-button
            document.querySelectorAll('.theme-option, .theme-button').forEach(option => {
                option.classList.remove('active');
                if ((option.dataset && option.dataset.theme === theme) || option.getAttribute('onclick')?.includes(`'${theme}'`)) {
                    option.classList.add('active');
                }
            });

            // Save preference
            localStorage.setItem('letterLearningTheme', theme);

            // If in game, refresh with new theme
            if (document.getElementById('gameArea').innerHTML.includes('option-btn')) {
                startIdentifyGame();
            }
        }

        // Voice Recording Functions
        function toggleRecording() {
            if (isRecording) {
                stopRecording();
            } else {
                startRecording();
            }
        }

        function startRecording() {
            // iOS Safari requires HTTPS for microphone access
            if (location.protocol !== 'https:' && location.hostname !== 'localhost' && location.hostname !== '127.0.0.1') {
                alert('Voice recording requires HTTPS');
                return;
            }
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                alert('Voice recording is not supported on this device');
                return;
            }

            navigator.mediaDevices.getUserMedia({ audio: true })
                .then(stream => {
                    mediaRecorder = new MediaRecorder(stream);
                    audioChunks = [];

                    mediaRecorder.ondataavailable = event => {
                        audioChunks.push(event.data);
                    };

                    mediaRecorder.onstop = () => {
                        const audioBlob = new Blob(audioChunks, { type: 'audio/wav' });
                        const audioUrl = URL.createObjectURL(audioBlob);

                        recordings.push({
                            letter: currentLetter,
                            url: audioUrl,
                            timestamp: Date.now()
                        });

                        // Limit stored recordings and free memory
                        if (recordings.length > 10) {
                            const toRemove = recordings.splice(0, recordings.length - 10);
                            toRemove.forEach(r => { try { URL.revokeObjectURL(r.url); } catch (e) { } });
                        }

                        // Enable playback buttons
                        document.getElementById('playBtn').disabled = false;
                        document.getElementById('compareBtn').disabled = false;

                        // Stop all tracks
                        stream.getTracks().forEach(track => track.stop());
                    };

                    mediaRecorder.start();
                    isRecording = true;

                    const recordBtn = document.getElementById('recordBtn');
                    recordBtn.classList.add('recording');
                    recordBtn.innerHTML = '<span id="recordIcon">ðŸ”´</span><div class="recording-indicator"></div>';
                    recordBtn.setAttribute('aria-label', 'Stop recording');

                    speakPhrase('Recording started. Say the letter!');
                })
                .catch(err => {
                    console.error('Error accessing microphone:', err);
                    alert('Could not access microphone. Please check permissions.');
                });
        }

        function stopRecording() {
            if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                mediaRecorder.stop();
                isRecording = false;

                const recordBtn = document.getElementById('recordBtn');
                recordBtn.classList.remove('recording');
                recordBtn.innerHTML = '<span id="recordIcon">ðŸŽ¤</span>';
                recordBtn.setAttribute('aria-label', 'Start recording');

                speakPhrase('Recording saved!');
            }
        }

        function playLastRecording() {
            if (recordings.length > 0) {
                const lastRecording = recordings[recordings.length - 1];
                const audio = new Audio(lastRecording.url);
                audio.play();
            }
        }

        function compareWithCorrect() {
            if (recordings.length > 0) {
                playLastRecording();
                setTimeout(() => {
                    speakPhrase('Now listen to the correct pronunciation');
                    setTimeout(() => {
                        speakLetter(currentLetter);
                    }, 1500);
                }, 1500);
            }
        }

        // Initialize speech synthesis with better voice loading
        let voices = [];
        function loadVoices() {
            voices = speechSynthesis.getVoices().filter(v => v.lang && v.lang.startsWith('en'));
            if (voices.length > 0) {
                console.log('Speech voices loaded:', voices.length, 'English voices available');
            }
        }
        function getBestVoice() {
            if (!voices || voices.length === 0) return null;
            const voicePriorities = [
                'Google US English', 'Microsoft Zira', 'Microsoft David',
                'Google UK English Female', 'Google UK English Male',
                'Samantha', 'Daniel', 'Karen', 'Moira'
            ];
            for (const name of voicePriorities) {
                const v = voices.find(v => v.name.includes(name));
                if (v) return v;
            }
            const englishVoice = voices.find(v => v.lang && v.lang.startsWith('en'));
            if (englishVoice) return englishVoice;
            const nonEastAsian = voices.find(v => !v.lang || (!v.lang.includes('zh') && !v.lang.includes('ja') && !v.lang.includes('ko')));
            return nonEastAsian || voices[0] || null;
        }
        if (speechSupported) {
            speechSynthesis.onvoiceschanged = loadVoices;
            loadVoices();
            // Nudge some browsers to populate voices
            if (voices.length === 0) {
                const silent = new SpeechSynthesisUtterance('');
                silent.volume = 0;
                speechSynthesis.speak(silent);
                setTimeout(() => speechSynthesis.cancel(), 100);
            }
        }

        // Achievement System Functions
        function checkAchievement(type, value) {
            ACHIEVEMENTS.forEach(achievement => {
                if (achievement.type === type && !unlockedAchievements.has(achievement.id)) {
                    if (value >= achievement.requirement) {
                        unlockAchievement(achievement);
                    } else {
                        // Update progress
                        achievementProgress[achievement.id] = value;
                    }
                }
            });
            updateBadgeCount();
        }

        function unlockAchievement(achievement) {
            if (unlockedAchievements.has(achievement.id)) return;

            unlockedAchievements.add(achievement.id);
            achievementProgress[achievement.id] = achievement.requirement;

            // Show notification
            showAchievementNotification(achievement);

            // Save progress
            saveGameData();

            // Update badge count
            updateBadgeCount();
        }

        function showAchievementNotification(achievement) {
            // Toasts disabled by request: keep things subtle
            updateBadgeCount();
            const badge = document.getElementById('badgeCount');
            if (badge) {
                badge.style.transition = 'transform 0.3s';
                badge.style.transform = 'scale(1.25)';
                setTimeout(() => { badge.style.transform = ''; }, 300);
            }
            const trophyBtn = document.querySelector('.badges-btn');
            if (trophyBtn) {
                trophyBtn.classList.add('new-achievement');
                setTimeout(() => trophyBtn.classList.remove('new-achievement'), 1000);
            }
        }

        function updateBadgeCount() {
            const count = unlockedAchievements.size;
            document.getElementById('badgeCount').textContent = count;
        }

        function openAchievements() {
            const modal = document.getElementById('achievementModal');
            const grid = document.getElementById('badgesGrid');

            // Update stats
            updateAchievementStats();

            // Clear grid
            grid.innerHTML = '';

            // Add all achievements
            ACHIEVEMENTS.forEach(achievement => {
                const badge = createBadgeElement(achievement);
                grid.appendChild(badge);
            });

            previouslyFocusedElement = document.activeElement;
            modal.style.display = 'flex';
            document.body.classList.add('modal-open');
            // Trap focus inside the modal content
            setTimeout(() => trapFocus(modal.querySelector('.achievement-content')), 50);
            // Close when tapping/clicking outside of the content
            modal.onclick = function (e) {
                if (e.target === modal) {
                    closeAchievements();
                }
            };
        }

        function closeAchievements() {
            const modal = document.getElementById('achievementModal');
            modal.style.display = 'none';
            if (previouslyFocusedElement) previouslyFocusedElement.focus();
            document.body.classList.remove('modal-open');
        }

        function createBadgeElement(achievement) {
            const isUnlocked = unlockedAchievements.has(achievement.id);
            const progress = achievementProgress[achievement.id] || 0;

            const badge = document.createElement('div');
            badge.className = `badge-item ${isUnlocked ? 'unlocked' : 'locked'}`;

            const icon = document.createElement('div');
            icon.className = 'badge-icon';
            icon.textContent = achievement.icon;

            const name = document.createElement('div');
            name.className = 'badge-name';
            name.textContent = achievement.name;

            const description = document.createElement('div');
            description.className = 'badge-description';
            description.textContent = achievement.description;

            badge.appendChild(icon);
            badge.appendChild(name);
            badge.appendChild(description);

            // Add progress bar if not unlocked
            if (!isUnlocked && progress > 0) {
                const progressBar = document.createElement('div');
                progressBar.className = 'badge-progress';

                const fill = document.createElement('div');
                fill.className = 'badge-progress-fill';
                fill.style.width = `${(progress / achievement.requirement) * 100}%`;

                progressBar.appendChild(fill);
                badge.appendChild(progressBar);
            }

            // Add hover effect
            badge.addEventListener('mouseenter', () => {
                if (isUnlocked && typeof gsap !== 'undefined') {
                    gsap.to(badge, {
                        scale: 1.05,
                        duration: 0.3,
                        ease: "power2.out"
                    });
                }
            });

            badge.addEventListener('mouseleave', () => {
                if (isUnlocked && typeof gsap !== 'undefined') {
                    gsap.to(badge, {
                        scale: 1,
                        duration: 0.3,
                        ease: "power2.out"
                    });
                }
            });

            return badge;
        }

        function updateAchievementStats() {
            // Calculate total play time
            const currentSessionTime = Math.floor((Date.now() - sessionStartTime) / 60000);
            const totalTime = totalPlayTime + currentSessionTime;

            // Check time achievements
            checkAchievement('time', totalTime);

            // Update UI
            document.getElementById('totalStarsEarned').textContent = Math.floor(score / 20);
            document.getElementById('lettersMastered').textContent = `${lettersMastered.size}/26`;
            document.getElementById('bestStreak').textContent = bestStreak;
            document.getElementById('totalPlayTime').textContent = `${totalTime} min`;

            // Draw mastery pie
            drawMasteryPie();
        }

        function drawMasteryPie() {
            const canvas = document.getElementById('masteryPie');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            if (!ctx) return;

            const total = 26;
            const mastered = Math.max(0, Math.min(total, lettersMastered.size || 0));
            const progress = mastered / total;

            // Clear
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const cx = canvas.width / 2;
            const cy = canvas.height / 2;
            const r = Math.min(cx, cy) - 10;

            // Background ring
            ctx.beginPath();
            ctx.arc(cx, cy, r, 0, Math.PI * 2);
            ctx.strokeStyle = '#e5e7eb';
            ctx.lineWidth = 18;
            ctx.lineCap = 'round';
            ctx.stroke();

            // Progress arc
            if (progress > 0) {
                ctx.beginPath();
                ctx.arc(cx, cy, r, -Math.PI / 2, -Math.PI / 2 + Math.PI * 2 * progress, false);
                ctx.strokeStyle = '#10b981';
                ctx.lineWidth = 18;
                ctx.lineCap = 'round';
                ctx.stroke();
            }

            // Center text
            ctx.fillStyle = '#111827';
            ctx.font = 'bold 20px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(`${mastered}/26`, cx, cy);
        }

        // Multiplayer Functions
        function initializeMultiplayer() {
            loadPlayers();
            if (players.length > 0) {
                multiplayerMode = true;
                document.getElementById('playerSelector').style.display = 'flex';
                updatePlayerDisplay();
            }
        }

        function loadPlayers() {
            const saved = localStorage.getItem('letterLearningPlayers');
            if (saved) {
                try {
                    players = JSON.parse(saved);
                    players.forEach(player => {
                        // Ensure all player objects have required properties
                        player.letterPerformance = player.letterPerformance || {};
                        player.unlockedAchievements = new Set(player.unlockedAchievements || []);
                        player.lettersMastered = new Set(player.lettersMastered || []);
                    });
                } catch (e) {
                    console.error('Error loading players:', e);
                    players = [];
                }
            }
        }

        function savePlayers() {
            const playersToSave = players.map(player => ({
                ...player,
                unlockedAchievements: Array.from(player.unlockedAchievements || []),
                lettersMastered: Array.from(player.lettersMastered || [])
            }));
            localStorage.setItem('letterLearningPlayers', JSON.stringify(playersToSave));
        }

        function showAddPlayer() {
            selectedAvatar = 'ðŸ¦';
            document.getElementById('playerNameInput').value = '';
            document.getElementById('playerModal').style.display = 'flex';
            document.body.classList.add('modal-open');
            previouslyFocusedElement = document.activeElement;
            setTimeout(() => trapFocus(document.getElementById('playerModal').querySelector('.player-modal-content')), 50);
            // Close when tapping outside modal content
            const modal = document.getElementById('playerModal');
            modal.onclick = function (e) {
                if (e.target === modal) {
                    closePlayerModal();
                }
            };

            // Set up avatar selection
            document.querySelectorAll('.avatar-option').forEach(option => {
                option.classList.remove('selected');
                if (option.dataset.avatar === selectedAvatar) {
                    option.classList.add('selected');
                }
                option.onclick = function () {
                    document.querySelectorAll('.avatar-option').forEach(o => o.classList.remove('selected'));
                    this.classList.add('selected');
                    selectedAvatar = this.dataset.avatar;
                };
            });
        }

        function closePlayerModal() {
            document.getElementById('playerModal').style.display = 'none';
            document.body.classList.remove('modal-open');
        }

        function saveNewPlayer() {
            const name = document.getElementById('playerNameInput').value.trim();
            if (!name) {
                alert('Please enter a player name');
                return;
            }

            const newPlayer = {
                id: Date.now(),
                name: name,
                avatar: selectedAvatar,
                score: 0,
                correctAnswers: 0,
                wrongAnswers: 0,
                currentRound: 1,
                roundCorrect: 0,
                roundWrong: 0,
                letterPerformance: {},
                unlockedAchievements: new Set(),
                achievementProgress: {},
                lettersMastered: new Set(),
                bestStreak: 0,
                speedAnswers: 0,
                totalPlayTime: 0,
                roundsCompleted: 0,
                celebrationType: 'fireworks',
                createdAt: Date.now()
            };

            players.push(newPlayer);
            savePlayers();

            if (!multiplayerMode) {
                multiplayerMode = true;
                document.getElementById('playerSelector').style.display = 'flex';
            }

            updatePlayerDisplay();
            closePlayerModal();

            // Switch to new player
            switchToPlayer(players.length - 1);
        }

        function updatePlayerDisplay() {
            const playerList = document.getElementById('playerList');
            playerList.innerHTML = '';

            players.forEach((player, index) => {
                const chip = document.createElement('div');
                chip.className = 'player-chip';
                if (index === currentPlayerIndex) {
                    chip.classList.add('active');
                }

                chip.innerHTML = `
                    <div class="player-avatar">${player.avatar}</div>
                    <div>
                        <div class="player-name">${player.name}</div>
                        <div class="player-score">Score: ${player.score}</div>
                    </div>
                    ${index === currentPlayerIndex ? '<div class="player-turn-indicator"></div>' : ''}
                `;

                chip.onclick = () => switchToPlayer(index);
                playerList.appendChild(chip);
            });
        }

        function switchToPlayer(index) {
            if (index >= 0 && index < players.length) {
                // Save current player's state
                if (currentPlayer) {
                    saveCurrentPlayerState();
                }

                // Switch to new player
                currentPlayerIndex = index;
                currentPlayer = players[index];
                sessionStartTime = Date.now(); // Reset session timer for the new player

                // Load new player's state
                loadPlayerState(currentPlayer);

                // Update UI
                updatePlayerDisplay();
                updateScoreDisplay();
                updateBadgeCount();
                updateDifficultyLevel();

                // Announce player switch
                if (currentPlayer) {
                    speakPhrase(`Now playing: ${currentPlayer.name}`);
                }

                // If in game, restart for new player
                if (document.getElementById('gameArea').innerHTML.includes('option-btn')) {
                    startIdentifyGame();
                }
            }
        }

        function saveCurrentPlayerState() {
            if (!currentPlayer) return;

            currentPlayer.score = score;
            currentPlayer.correctAnswers = correctAnswers;
            currentPlayer.wrongAnswers = wrongAnswers;
            currentPlayer.currentRound = currentRound;
            currentPlayer.roundCorrect = roundCorrect;
            currentPlayer.roundWrong = roundWrong;
            currentPlayer.letterPerformance = letterPerformance;
            currentPlayer.unlockedAchievements = unlockedAchievements;
            currentPlayer.achievementProgress = achievementProgress;
            currentPlayer.lettersMastered = lettersMastered;
            currentPlayer.bestStreak = bestStreak;
            currentPlayer.speedAnswers = speedAnswers;
            currentPlayer.roundsCompleted = roundsCompleted;
            currentPlayer.celebrationType = celebrationType;

            savePlayers();
        }

        function loadPlayerState(player) {
            score = player.score || 0;
            correctAnswers = player.correctAnswers || 0;
            wrongAnswers = player.wrongAnswers || 0;
            currentRound = player.currentRound || 1;
            roundCorrect = player.roundCorrect || 0;
            roundWrong = player.roundWrong || 0;
            letterPerformance = player.letterPerformance || {};
            // Backfill SRS fields for per-player state
            const nowTs = Date.now();
            Object.keys(letterPerformance).forEach(k => {
                const perf = letterPerformance[k] || {};
                if (typeof perf.easeFactor !== 'number') perf.easeFactor = 2.5;
                if (typeof perf.interval !== 'number') perf.interval = 0;
                if (typeof perf.nextReview !== 'number') perf.nextReview = nowTs;
                if (!Array.isArray(perf.times)) perf.times = perf.times ? [perf.times] : [];
                letterPerformance[k] = perf;
            });
            unlockedAchievements = player.unlockedAchievements || new Set();
            achievementProgress = player.achievementProgress || {};
            lettersMastered = player.lettersMastered || new Set();
            bestStreak = player.bestStreak || 0;
            speedAnswers = player.speedAnswers || 0;
            roundsCompleted = player.roundsCompleted || 0;
            celebrationType = player.celebrationType || 'fireworks';
        }

        // Parent Dashboard Functions
        function openParentDashboard() {
            updateDashboard();
            document.getElementById('parentDashboard').style.display = 'block';
            previouslyFocusedElement = document.activeElement;
            setTimeout(() => trapFocus(document.getElementById('parentDashboard')), 50);
            // Close when tapping outside dashboard content
            const modal = document.getElementById('parentDashboard');
            modal.onclick = function (e) {
                if (e.target === modal) {
                    closeParentDashboard();
                }
            };
            document.body.classList.add('modal-open');
        }

        function closeParentDashboard() {
            document.getElementById('parentDashboard').style.display = 'none';
            document.body.classList.remove('modal-open');
        }

        function updateDashboard() {
            updatePlayerStats();
            updateLetterHeatmap();
            updateInsights();
            updateRecommendations();
        }

        function resetAllStatistics() {
            // Clear overall saved game data and players
            try { localStorage.removeItem('letterLearningGameData'); } catch (e) { }
            try { localStorage.removeItem('letterLearningPlayers'); } catch (e) { }
            // Reset in-memory state for current session
            score = 0; correctAnswers = 0; wrongAnswers = 0; totalQuestions = 0; currentRound = 1;
            roundCorrect = 0; roundWrong = 0; scoreAtRoundStart = 0;
            letterPerformance = {}; lettersMastered = new Set(); unlockedAchievements = new Set();
            achievementProgress = {}; bestStreak = 0; speedAnswers = 0; totalPlayTime = 0; roundsCompleted = 0;
            currentStreak = 0; lastPlayDate = null; streakHistory = [];
            players = []; currentPlayer = null; currentPlayerIndex = 0; multiplayerMode = false;
            updateBadgeCount();
            updateAchievementStats();
            initializeMultiplayer();
            updateDashboard();
            showFeedback('All statistics have been reset.', 'info');
        }

        function resetCurrentPlayerStatistics() {
            if (!multiplayerMode || !currentPlayer) {
                // Reset single-player state only
                score = 0; correctAnswers = 0; wrongAnswers = 0; totalQuestions = 0; currentRound = 1;
                roundCorrect = 0; roundWrong = 0; scoreAtRoundStart = 0;
                letterPerformance = {}; lettersMastered = new Set(); unlockedAchievements = new Set();
                achievementProgress = {}; bestStreak = 0; speedAnswers = 0; roundsCompleted = 0;
                updateBadgeCount();
                updateAchievementStats();
                saveGameData();
            } else {
                // Reset only the selected player's stats
                currentPlayer.score = 0;
                currentPlayer.correctAnswers = 0;
                currentPlayer.wrongAnswers = 0;
                currentPlayer.currentRound = 1;
                currentPlayer.roundCorrect = 0;
                currentPlayer.roundWrong = 0;
                currentPlayer.letterPerformance = {};
                currentPlayer.unlockedAchievements = new Set();
                currentPlayer.achievementProgress = {};
                currentPlayer.lettersMastered = new Set();
                currentPlayer.bestStreak = 0;
                currentPlayer.speedAnswers = 0;
                currentPlayer.roundsCompleted = 0;
                savePlayers();
                // Reload into memory
                loadPlayerState(currentPlayer);
            }
            updatePlayerDisplay();
            updateScoreDisplay();
            updateDashboard();
            showFeedback('Player statistics have been reset.', 'info');
        }

        function updatePlayerStats() {
            const grid = document.getElementById('playerStatsGrid');
            grid.innerHTML = '';

            const allPlayers = multiplayerMode ? players : [{
                name: 'Player',
                avatar: 'ðŸŒŸ',
                score,
                correctAnswers,
                wrongAnswers,
                lettersMastered,
                bestStreak,
                totalPlayTime
            }];

            allPlayers.forEach(player => {
                const card = document.createElement('div');
                card.className = 'player-stat-card';

                const accuracy = (player.correctAnswers + player.wrongAnswers) > 0 ?
                    Math.round((player.correctAnswers / (player.correctAnswers + player.wrongAnswers)) * 100) : 0;

                card.innerHTML = `
                    <div class="player-stat-header">
                        <div class="player-stat-avatar">${player.avatar || 'ðŸŒŸ'}</div>
                        <div class="player-stat-name">${player.name}</div>
                    </div>
                    <div class="stat-grid">
                        <div class="stat-item">
                            <div class="stat-value">${player.score}</div>
                            <div class="stat-label">Score</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value">${accuracy}%</div>
                            <div class="stat-label">Accuracy</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value">${player.lettersMastered ? player.lettersMastered.size : 0}</div>
                            <div class="stat-label">Letters Mastered</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value">${player.bestStreak || 0}</div>
                            <div class="stat-label">Best Streak</div>
                        </div>
                    </div>
                `;

                grid.appendChild(card);
            });
        }

        function updateLetterHeatmap() {
            const heatmap = document.getElementById('letterHeatmap');
            heatmap.innerHTML = '';

            const letters = 'abcdefghijklmnopqrstuvwxyz'.split('');

            letters.forEach(letter => {
                const cell = document.createElement('div');
                cell.className = 'heatmap-cell';
                cell.textContent = letter.toUpperCase();

                // Calculate performance across all players
                let totalCorrect = 0;
                let totalAttempts = 0;

                if (multiplayerMode) {
                    players.forEach(player => {
                        const perf = player.letterPerformance[letter];
                        if (perf) {
                            totalCorrect += perf.correct;
                            totalAttempts += perf.total;
                        }
                    });
                } else {
                    const perf = letterPerformance[letter];
                    if (perf) {
                        totalCorrect = perf.correct;
                        totalAttempts = perf.total;
                    }
                }

                const successRate = totalAttempts > 0 ? totalCorrect / totalAttempts : 0.5;

                // Color based on performance
                let color;
                if (totalAttempts === 0) {
                    color = '#e5e7eb'; // Gray for untried
                } else if (successRate < 0.5) {
                    color = '#ef4444'; // Red for struggling
                } else if (successRate < 0.8) {
                    color = '#fbbf24'; // Yellow for learning
                } else {
                    color = '#4ade80'; // Green for mastered
                }

                cell.style.background = color;
                cell.style.color = successRate > 0.5 ? 'white' : '#374151';

                // Add tooltip on hover
                cell.title = `${letter.toUpperCase()}: ${Math.round(successRate * 100)}% success rate (${totalAttempts} attempts)`;

                heatmap.appendChild(cell);
            });
        }

        function updateInsights() {
            const insightsList = document.getElementById('insightsList');
            insightsList.innerHTML = '';

            const insights = generateInsights();

            insights.forEach(insight => {
                const item = document.createElement('li');
                item.className = 'insight-item';
                item.innerHTML = `
                    <div class="insight-icon">${insight.icon}</div>
                    <div class="insight-content">
                        <div class="insight-title">${insight.title}</div>
                        <div class="insight-description">${insight.description}</div>
                    </div>
                `;
                insightsList.appendChild(item);
            });
        }

        function generateInsights() {
            const insights = [];

            // Analyze letter confusion patterns
            const confusedPairs = [['b', 'd'], ['p', 'q'], ['m', 'n'], ['v', 'w']];
            confusedPairs.forEach(([letter1, letter2]) => {
                const perf1 = letterPerformance[letter1];
                const perf2 = letterPerformance[letter2];

                if (perf1 && perf2) {
                    const success1 = perf1.total > 0 ? perf1.correct / perf1.total : 1;
                    const success2 = perf2.total > 0 ? perf2.correct / perf2.total : 1;

                    if (success1 < 0.7 && success2 < 0.7) {
                        insights.push({
                            icon: 'âš ï¸',
                            title: `Confusion between ${letter1.toUpperCase()} and ${letter2.toUpperCase()}`,
                            description: `These similar-looking letters are causing difficulty. Practice them side-by-side with physical objects shaped like the letters.`
                        });
                    }
                }
            });

            // Speed analysis
            const avgResponseTime = responseTimes.length > 0 ?
                responseTimes.reduce((a, b) => a + b, 0) / responseTimes.length : 0;

            if (avgResponseTime > 5) {
                insights.push({
                    icon: 'â±ï¸',
                    title: 'Response Time',
                    description: 'Taking time to think is good! Consider practicing letter recognition with flashcards for faster recall.'
                });
            } else if (avgResponseTime < 2) {
                insights.push({
                    icon: 'âš¡',
                    title: 'Quick Recognition',
                    description: 'Excellent letter recognition speed! Ready for more challenging activities like word building.'
                });
            }

            // Mastery progress
            const masteryPercent = Math.round((lettersMastered.size / 26) * 100);
            if (masteryPercent > 75) {
                insights.push({
                    icon: 'ðŸŽ†',
                    title: 'Near Complete Mastery!',
                    description: `${lettersMastered.size} of 26 letters mastered. Time to start focusing on writing and phonics!`
                });
            }

            if (insights.length === 0) {
                insights.push({
                    icon: 'ðŸ‘',
                    title: 'Keep Going!',
                    description: 'Regular practice is key. Try to play for at least 10 minutes each day.'
                });
            }

            return insights;
        }

        function updateRecommendations() {
            const recommendationsList = document.getElementById('recommendationsList');
            recommendationsList.innerHTML = '';

            const recommendations = generateRecommendations();

            recommendations.forEach(rec => {
                const card = document.createElement('div');
                card.className = 'recommendation-card';
                card.innerHTML = `
                    <div class="recommendation-title">
                        <span>${rec.icon}</span>
                        <span>${rec.title}</span>
                    </div>
                    <div class="recommendation-text">${rec.text}</div>
                `;
                recommendationsList.appendChild(card);
            });
        }

        function generateRecommendations() {
            const recs = [];

            // Identify problem letters
            const strugglingLetters = Object.entries(letterPerformance)
                .filter(([letter, perf]) => perf.total > 2 && (perf.correct / perf.total) < 0.6)
                .map(([letter]) => letter);

            if (strugglingLetters.length > 0) {
                recs.push({
                    icon: 'ðŸ“',
                    title: 'Practice These Letters',
                    text: `Focus on: ${strugglingLetters.map(l => l.toUpperCase()).join(', ')}. Try tracing them in sand or shaving cream for tactile learning.`
                });
            }

            // Time-based recommendations
            const currentHour = new Date().getHours();
            if (currentHour < 12) {
                recs.push({
                    icon: 'â˜€ï¸',
                    title: 'Morning Letter Hunt',
                    text: 'Great time for learning! Go on a letter hunt around the house - find objects that start with today\'s practice letters.'
                });
            } else if (currentHour < 17) {
                recs.push({
                    icon: 'ðŸŽ²',
                    title: 'Afternoon Activity',
                    text: 'Play "Letter Bingo" during snack time. Call out letters and have your child find them on their bingo card.'
                });
            } else {
                recs.push({
                    icon: 'ðŸŒ™',
                    title: 'Bedtime Letter Story',
                    text: 'End the day with a letter-focused story. Point out and trace letters as you read together.'
                });
            }

            // Achievement-based recommendations
            if (unlockedAchievements.size < 3) {
                recs.push({
                    icon: 'ðŸ†',
                    title: 'Unlock More Badges',
                    text: 'Encourage achievement hunting! Set small goals like "get 5 in a row" to unlock new badges.'
                });
            }

            return recs;
        }

        // Save/Load Functions
        function saveGameData() {
            const today = new Date().toDateString();

            const gameData = {
                score,
                correctAnswers,
                wrongAnswers,
                currentRound,
                letterPerformance,
                lettersMastered: Array.from(lettersMastered),
                unlockedAchievements: Array.from(unlockedAchievements),
                achievementProgress,
                bestStreak,
                speedAnswers,
                totalPlayTime: totalPlayTime + Math.floor((Date.now() - sessionStartTime) / 60000),
                roundsCompleted,
                lastPlayed: Date.now(),
                // Streak data
                currentStreak,
                lastPlayDate: today,
                streakHistory,
                // Settings
                focusModeEnabled,
                highContrastEnabled,
                reduceMotionEnabled,
                celebrationType,
                currentTheme,
                voiceRecordingEnabled
            };

            localStorage.setItem('letterLearningGameData', JSON.stringify(gameData));
        }

        function loadGameData() {
            const saved = localStorage.getItem('letterLearningGameData');
            if (saved) {
                try {
                    const gameData = JSON.parse(saved);

                    // Restore game state
                    score = gameData.score || 0;
                    correctAnswers = gameData.correctAnswers || 0;
                    wrongAnswers = gameData.wrongAnswers || 0;
                    currentRound = gameData.currentRound || 1;
                    letterPerformance = gameData.letterPerformance || {};
                    // Backfill SRS fields for existing saves
                    const nowTs = Date.now();
                    Object.keys(letterPerformance).forEach(k => {
                        const perf = letterPerformance[k] || {};
                        if (typeof perf.easeFactor !== 'number') perf.easeFactor = 2.5;
                        if (typeof perf.interval !== 'number') perf.interval = 0;
                        if (typeof perf.nextReview !== 'number') perf.nextReview = nowTs;
                        if (!Array.isArray(perf.times)) perf.times = perf.times ? [perf.times] : [];
                        letterPerformance[k] = perf;
                    });
                    lettersMastered = new Set(gameData.lettersMastered || []);
                    unlockedAchievements = new Set(gameData.unlockedAchievements || []);
                    achievementProgress = gameData.achievementProgress || {};
                    bestStreak = gameData.bestStreak || 0;
                    speedAnswers = gameData.speedAnswers || 0;
                    totalPlayTime = gameData.totalPlayTime || 0;
                    roundsCompleted = gameData.roundsCompleted || 0;

                    // Restore streak data
                    lastPlayDate = gameData.lastPlayDate;
                    streakHistory = gameData.streakHistory || [];
                    currentStreak = gameData.currentStreak || 0;

                    // Restore settings
                    focusModeEnabled = gameData.focusModeEnabled || false;
                    highContrastEnabled = gameData.highContrastEnabled || false;
                    reduceMotionEnabled = gameData.reduceMotionEnabled || false;
                    celebrationType = gameData.celebrationType || 'fireworks';
                    currentTheme = gameData.currentTheme || 'classic';
                    voiceRecordingEnabled = !!gameData.voiceRecordingEnabled;

                    // Check streak continuity
                    checkStreakContinuity();

                    // Apply saved settings
                    if (focusModeEnabled) {
                        document.body.classList.add('focus-mode');
                        const el = document.getElementById('focusModeSwitch');
                        if (el) { el.classList.add('active'); el.setAttribute('aria-checked', 'true'); }
                    }
                    if (highContrastEnabled) {
                        document.body.style.filter = 'contrast(1.5)';
                        const el = document.getElementById('highContrastSwitch');
                        if (el) { el.classList.add('active'); el.setAttribute('aria-checked', 'true'); }
                    }
                    if (reduceMotionEnabled) {
                        document.body.style.setProperty('--animation-duration', '0.01s');
                        const el = document.getElementById('reduceMotionSwitch');
                        if (el) { el.classList.add('active'); el.setAttribute('aria-checked', 'true'); }
                    }

                    // Update UI
                    updateScoreDisplay();
                    updateBadgeCount();
                    updateDifficultyLevel();
                    updateStreakDisplay();

                    // Check if returning player deserves a welcome back
                    if (gameData.lastPlayed) {
                        const hoursSinceLastPlay = (Date.now() - gameData.lastPlayed) / (1000 * 60 * 60);
                        if (hoursSinceLastPlay > 24) {
                            setTimeout(() => {
                                speakPhrase('Welcome back! Ready to learn more letters?');
                            }, 1000);
                        }
                    }
                } catch (e) {
                    console.error('Error loading game data:', e);
                }
            }
        }

        // Auto-save periodically
        setInterval(saveGameData, 30000); // Save every 30 seconds

        // Save on page unload
        window.addEventListener('beforeunload', saveGameData);

        // Focus Mode Functions
        function toggleFocusMode() {
            focusModeEnabled = !focusModeEnabled;
            const switchEl = document.getElementById('focusModeSwitch');

            if (focusModeEnabled) {
                document.body.classList.add('focus-mode');
                if (switchEl) { switchEl.classList.add('active'); switchEl.setAttribute('aria-checked', 'true'); }
                // Store current timer state and disable timer in focus mode
                previousTimerState = timerEnabled;
                timerEnabled = false;
                // Remove distractions while enabling focus mode
                clearAllTimers();
                cancelSpeech();
                speakPhrase('Focus mode enabled. Simplified interface activated.');
            } else {
                document.body.classList.remove('focus-mode');
                if (switchEl) { switchEl.classList.remove('active'); switchEl.setAttribute('aria-checked', 'false'); }
                // Restore previous timer state instead of always enabling
                timerEnabled = previousTimerState;
                speakPhrase('Focus mode disabled.');
            }

            saveGameData();
        }

        function toggleHighContrast() {
            highContrastEnabled = !highContrastEnabled;
            const switchEl = document.getElementById('highContrastSwitch');

            if (highContrastEnabled) {
                document.body.style.filter = 'contrast(1.5)';
                if (switchEl) { switchEl.classList.add('active'); switchEl.setAttribute('aria-checked', 'true'); }
            } else {
                document.body.style.filter = 'none';
                if (switchEl) { switchEl.classList.remove('active'); switchEl.setAttribute('aria-checked', 'false'); }
            }

            saveGameData();
        }

        function toggleReduceMotion() {
            reduceMotionEnabled = !reduceMotionEnabled;
            const switchEl = document.getElementById('reduceMotionSwitch');

            if (reduceMotionEnabled) {
                // Set all animation durations to nearly instant
                document.body.style.setProperty('--animation-duration', '0.01s');
                const style = document.createElement('style');
                style.id = 'reduce-motion-style';
                style.textContent = '* { animation-duration: 0.01s !important; transition-duration: 0.01s !important; }';
                document.head.appendChild(style);
                document.body.classList.add('reduce-motion');
                if (switchEl) { switchEl.classList.add('active'); switchEl.setAttribute('aria-checked', 'true'); }
            } else {
                document.body.style.removeProperty('--animation-duration');
                const style = document.getElementById('reduce-motion-style');
                if (style) style.remove();
                document.body.classList.remove('reduce-motion');
                if (switchEl) { switchEl.classList.remove('active'); switchEl.setAttribute('aria-checked', 'false'); }
            }

            saveGameData();
        }

        // Streak System Functions
        function checkStreakContinuity() {
            const today = new Date().toDateString();
            const yesterday = new Date(Date.now() - 86400000).toDateString();

            if (lastPlayDate === today) {
                // Already played today
                return;
            } else if (lastPlayDate === yesterday) {
                // Streak continues!
                currentStreak++;
                lastPlayDate = today;
                streakHistory.push(today);

                // Check for milestones
                if (streakMilestones.includes(currentStreak)) {
                    showStreakMilestone(currentStreak);
                }

                updateStreakDisplay();
                saveGameData();
            } else if (!lastPlayDate) {
                // First time playing
                currentStreak = 1;
                lastPlayDate = today;
                streakHistory = [today];
                updateStreakDisplay();
                saveGameData();
            } else {
                // Streak broken
                if (currentStreak > 1) {
                    speakPhrase(`Oh no! Your ${currentStreak} day streak ended. Let's start a new one!`);
                }
                currentStreak = 1;
                lastPlayDate = today;
                streakHistory = [today];
                updateStreakDisplay();
                saveGameData();
            }
        }

        function updateStreakDisplay() {
            const display = document.getElementById('streakDisplay');
            const number = document.getElementById('streakNumber');

            if (currentStreak > 1) {
                display.style.display = 'flex';
                number.textContent = currentStreak;
                // brief attention animation on update
                display.classList.add('streak-animate');
                setTimeout(() => display.classList.remove('streak-animate'), 700);

                // Add special effects for longer streaks
                if (currentStreak >= 30) {
                    display.style.background = 'linear-gradient(135deg, #ef4444, #dc2626)';
                } else if (currentStreak >= 14) {
                    display.style.background = 'linear-gradient(135deg, #f59e0b, #d97706)';
                } else if (currentStreak >= 7) {
                    display.style.background = 'linear-gradient(135deg, #fbbf24, #f59e0b)';
                }
            } else {
                display.style.display = 'none';
            }
        }

        function showStreakMilestone(days) {
            const modal = document.getElementById('streakModal');
            const icon = document.getElementById('milestoneIcon');
            const title = document.getElementById('milestoneTitle');
            const subtitle = document.getElementById('milestoneSubtitle');

            // Set milestone content
            const milestoneData = {
                3: { icon: 'ðŸŒŸ', title: '3 Day Streak!', subtitle: 'You\'re building a habit!' },
                7: { icon: 'ðŸ†', title: 'One Week Streak!', subtitle: 'Amazing consistency!' },
                14: { icon: 'ðŸŽ¯', title: 'Two Week Streak!', subtitle: 'You\'re unstoppable!' },
                30: { icon: 'ðŸ‘‘', title: 'One Month Streak!', subtitle: 'You\'re a learning champion!' },
                50: { icon: 'ðŸ’Ž', title: '50 Day Streak!', subtitle: 'Incredible dedication!' },
                100: { icon: 'ðŸŒˆ', title: '100 Day Streak!', subtitle: 'You\'re a legend!' }
            };

            const data = milestoneData[days];
            if (data) {
                icon.textContent = data.icon;
                title.textContent = data.title;
                subtitle.textContent = data.subtitle;

                // Generate calendar
                generateStreakCalendar();

                // Show modal
                modal.style.display = 'flex';
                previouslyFocusedElement = document.activeElement;
                setTimeout(() => trapFocus(modal.querySelector('.streak-modal-content')), 50);
                // Close when tapping outside content
                modal.onclick = function (e) {
                    if (e.target === modal) {
                        closeStreakModal();
                    }
                };
                document.body.classList.add('modal-open');

                // Celebration
                setTimeout(() => {
                    for (let i = 0; i < 5; i++) {
                        setTimeout(() => createConfetti(), i * 200);
                    }
                }, 500);

                // Announce achievement
                speakPhrase(`Wow! ${data.title} ${data.subtitle}`);
            }
        }

        function generateStreakCalendar() {
            const calendar = document.getElementById('streakCalendar');
            calendar.innerHTML = '';

            const today = new Date();
            const daysToShow = 28; // Show 4 weeks

            for (let i = daysToShow - 1; i >= 0; i--) {
                const date = new Date(today.getTime() - (i * 86400000));
                const dateStr = date.toDateString();
                const day = document.createElement('div');
                day.className = 'calendar-day';
                day.textContent = date.getDate();

                if (streakHistory.includes(dateStr)) {
                    day.classList.add('played');
                } else if (date < today) {
                    day.classList.add('missed');
                }

                if (dateStr === today.toDateString()) {
                    day.classList.add('today');
                }

                calendar.appendChild(day);
            }
        }

        function closeStreakModal() {
            document.getElementById('streakModal').style.display = 'none';
            document.body.classList.remove('modal-open');
        }

        // Celebration Customization Functions
        function setCelebration(type) {
            celebrationType = type;

            document.querySelectorAll('.celebration-option').forEach(option => {
                option.classList.remove('selected');
                if (option.dataset.celebration === type) {
                    option.classList.add('selected');
                }
            });

            // Preview the celebration
            createConfetti();

            // Save preference
            saveGameData();
        }

        // Initialize
        initializeMultiplayer();
        updateScoreDisplay();
        updateBadgeCount();
        updateDifficultyLevel();
        updateStreakDisplay();

        // Load saved theme
        const savedTheme = localStorage.getItem('letterLearningTheme');
        const savedPhonics = localStorage.getItem('letterLearningPhonics');
        if (savedPhonics) {
            phonicsEnabled = savedPhonics === 'on';
            setPhonicsMode(phonicsEnabled ? 'on' : 'off');
        }

        // Set saved celebration type in UI
        if (celebrationType !== 'fireworks') {
            setCelebration(celebrationType);
        }

        // Sync advanced settings UI to saved values at load
        const voiceToggleAtLoad = document.getElementById('voiceToggle');
        if (voiceToggleAtLoad) voiceToggleAtLoad.checked = !!voiceRecordingEnabled;
        const fmCheckAtLoad = document.getElementById('focusModeCheck');
        if (fmCheckAtLoad) fmCheckAtLoad.checked = !!focusModeEnabled;
        const hcCheckAtLoad = document.getElementById('highContrastCheck');
        if (hcCheckAtLoad) hcCheckAtLoad.checked = !!highContrastEnabled;
        const rmCheckAtLoad = document.getElementById('reduceMotionCheck');
        if (rmCheckAtLoad) rmCheckAtLoad.checked = !!reduceMotionEnabled;

        // Long press for parent dashboard
        let longPressTimer;
        let hintTimer;
        const settingsBtn = document.getElementById('settingsBtn');

        function startPressTimers() {
            // Hint after short press
            hintTimer = setTimeout(() => {
                showFeedback('Hold for Parent Menu', 'info');
            }, 800);
            // Open dashboard after long press
            longPressTimer = setTimeout(() => {
                openParentDashboard();
            }, 2000);
        }
        function clearPressTimers() {
            clearTimeout(hintTimer);
            clearTimeout(longPressTimer);
        }

        settingsBtn.addEventListener('touchstart', startPressTimers);
        settingsBtn.addEventListener('touchend', clearPressTimers);
        settingsBtn.addEventListener('mousedown', startPressTimers);
        settingsBtn.addEventListener('mouseup', clearPressTimers);
        settingsBtn.addEventListener('mouseleave', clearPressTimers);
        // Quick access: double-click to open Parent Dashboard
        settingsBtn.addEventListener('dblclick', (e) => {
            e.preventDefault();
            clearPressTimers();
            openParentDashboard();
        });

        // Convenience: open Parent Dashboard directly from Settings
        function openParentDashboardViaSettings() {
            closeSettings();
            setTimeout(() => openParentDashboard(), 150);
        }

        // Add keyboard support for debugging
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                closeSettings();
                closeAchievements();
                document.getElementById('roundModal').style.display = 'none';
            }
        });

        // Keyboard access for focus switches
        const focusSwitches = [
            { id: 'focusModeSwitch', handler: toggleFocusMode },
            { id: 'highContrastSwitch', handler: toggleHighContrast },
            { id: 'reduceMotionSwitch', handler: toggleReduceMotion }
        ];
        focusSwitches.forEach(({ id, handler }) => {
            const el = document.getElementById(id);
            if (el) {
                el.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' || e.key === ' ') {
                        e.preventDefault();
                        handler();
                    }
                });
            }
        });

        // Focus trap helper
        function trapFocus(modal) {
            if (!modal) return;
            const focusable = modal.querySelectorAll('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])');
            if (!focusable || focusable.length === 0) return;
            const first = focusable[0];
            const last = focusable[focusable.length - 1];
            first.focus();
            modal.addEventListener('keydown', function onKeyDown(e) {
                if (e.key !== 'Tab') return;
                if (e.shiftKey) {
                    if (document.activeElement === first) {
                        e.preventDefault();
                        last.focus();
                    }
                } else {
                    if (document.activeElement === last) {
                        e.preventDefault();
                        first.focus();
                    }
                }
            });
        }

        // Prevent pull-to-refresh on mobile
        document.addEventListener('touchmove', function (e) {
            if (e.touches.length > 1) {
                e.preventDefault();
            }
        }, { passive: false });
    </script>
</body>

</html>